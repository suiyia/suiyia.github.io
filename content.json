{"meta":{"title":"菜鸟日常","subtitle":null,"description":null,"author":"Answer","url":"http://suiyia.github.io"},"pages":[{"title":"","date":"2019-10-10T13:37:18.150Z","updated":"2019-09-19T08:54:39.785Z","comments":true,"path":"hexo-admin-ehc-images.json","permalink":"http://suiyia.github.io/hexo-admin-ehc-images.json","excerpt":"","text":"[{\"name\":\"DASHENG-900x700-1.png\",\"date\":1518959551960},{\"name\":\"DASHENG-900x700-2.png\",\"date\":1518959599098},{\"name\":\"DASHENG-900x700-3.png\",\"date\":1518959609913},{\"name\":\"DASHENG-900x700-4.png\",\"date\":1518959618105}]"},{"title":"404 Not Found：该页无法显示","date":"2019-10-10T13:37:18.184Z","updated":"2018-12-23T14:21:42.101Z","comments":false,"path":"/404.html","permalink":"http://suiyia.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-09-19T09:11:15.000Z","updated":"2019-09-19T10:33:01.855Z","comments":true,"path":"about/index.html","permalink":"http://suiyia.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2019-10-10T13:37:18.184Z","updated":"2018-12-23T14:21:42.107Z","comments":false,"path":"books/index.html","permalink":"http://suiyia.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-10T13:37:18.186Z","updated":"2018-12-23T14:21:42.109Z","comments":false,"path":"categories/index.html","permalink":"http://suiyia.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-10-10T13:37:18.196Z","updated":"2018-12-23T14:21:42.112Z","comments":false,"path":"repository/index.html","permalink":"http://suiyia.github.io/repository/index.html","excerpt":"","text":""},{"title":"callback","date":"2018-12-23T13:43:41.000Z","updated":"2018-12-23T13:43:41.903Z","comments":true,"path":"callback/index.html","permalink":"http://suiyia.github.io/callback/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-10T13:37:18.197Z","updated":"2018-12-23T14:21:42.113Z","comments":false,"path":"tags/index.html","permalink":"http://suiyia.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-10-10T13:37:18.195Z","updated":"2018-12-23T14:21:42.109Z","comments":true,"path":"links/index.html","permalink":"http://suiyia.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL学习——基础概念了解","slug":"MySQL学习——基础概念了解","date":"2019-10-10T13:44:00.000Z","updated":"2019-10-10T14:09:25.600Z","comments":true,"path":"2019/10/10/MySQL学习——基础概念了解/","link":"","permalink":"http://suiyia.github.io/2019/10/10/MySQL学习——基础概念了解/","excerpt":"","text":"MySQL 主从复制原理https://zhuanlan.zhihu.com/p/50597960MySQL主从复制涉及到三个线程主节点 binary log dump 线程当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。从节点 I/O线程当从节点上执行start slave命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点binlog dump 进程发来的更新之后，保存在本地relay-log中。从节点SQL线程SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。binlog 记录格式基于SQL语句，只需要记录会修改数据的sql语句到binlog中，减少了binlog日质量，节约I/O，提高性能。缺点是在某些情况下，会导致主从节点中数据不一致（比如sleep(),now()等）。基于行，只记录哪条数据被修改了，修改成什么样。优点是不会出现某些特定情况下的存储过程、或者函数、或者trigger的调用或者触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是修改table的时候会让日志暴增,同时增加bin log同步时间。也不能通过bin log解析获取执行过的sql语句，只能看到发生的data变更。混合模式，一般的复制使用STATEMENT模式保存到binlog，对于STATEMENT模式无法复制的操作则使用ROW模式来保存，MySQL会根据执行的SQL语句选择日志保存方式。日志类型错误日志，记录出错信息，也记录一些警告信息或者正确的信息查询日志，记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行慢查询日志，设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。二进制日志，记录对数据库执行更改的所有操作中继日志，事务日志数据类型（https://juejin.im/entry/5b57ec015188251aa8292a69）整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。实数，包括FLOAT、DOUBLE、DECIMAL。DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。字符串类型，包括 VARCHAR、CHAR、TEXT、BLOB。VARCHAR 用于存储可变长字符串，它比 CHAR 定长类型更节省空间；当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。枚举类型，把不重复的数据存储为一个预定义的集合。有时可以使用ENUM代替常用的字符串类型。ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。ENUM在内部存储时，其实存的是整数。尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。排序是按照内部存储的整数日期时间类型，尽量使用timestamp，空间效率高于datetime，用整数保存时间戳通常不方便处理。如果需要存储微妙，可以使用bigint存储。SQL 语句分类DDL：数据定义语言（create drop alter）DML：数据操作语句（insert update delete）DQL：数据查询语句（select ）DCL：数据控制语句，进行授权和权限回收（grant revoke）TPL：数据事务语句（commit collback savapoint）数据库范式减少数据冗余、查询需要多表关联第一范式：属性具有原子性，不可再分解。第二范式：记录具有唯一标识，即实体唯一性。通常需要为表加上一个列， 以存储各个实例的惟一标识。第三范式：任何字段不能由其它字段派生而来，要求字段没有冗余。第三范式具有如下特征：1， 每一列只有一个值。2， 每一行都能区分。3， 每一个表都不包含其他表已经包含的非主关键字信息。MyISAM表格将在哪里存储，并且还提供其存储格式?每个MyISAM表格以三种格式存储在磁盘上：“.frm”文件存储表定义数据文件具有“.MYD”(MYData)扩展名索引文件具有“.MYI”(MYIndex)扩展名其它一条SQL语句在MySQL中是如何执行的MySQL 主从复制原理","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://suiyia.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://suiyia.github.io/tags/MySQL/"}]},{"title":"MySQL学习——锁","slug":"MySQL学习——锁","date":"2019-10-10T13:40:00.000Z","updated":"2019-10-10T13:40:52.857Z","comments":true,"path":"2019/10/10/MySQL学习——锁/","link":"","permalink":"http://suiyia.github.io/2019/10/10/MySQL学习——锁/","excerpt":"","text":"锁加锁策略乐观锁：乐观锁总是假设最好的情况，乐观锁常见实现：版本号控制，数据行保存 version 字段，修改时会变化。MySQL-InnoDB-MVCC多版本并发控制CAS 算法（compare and swap），CAS算法涉及到三个操作数，需要读写的内存值 V，进行比较的值 A，拟写入的新值 B。 当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。CAS 常见问题ABA问题：一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值。在这段时间它的值可能被改为其他值，然后又改回A循环时间长开销大：自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。只能保证一个共享变量的原子操作：CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。悲观锁：总是假设最坏的情况，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程锁粒度分类表锁，粒度最大，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁 。行锁，粒度最小 的一种锁，只针对当前操作的行的索引进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。InnoDB支持的行级锁：Record Lock: 对索引项加锁，锁定符合条件的行。Gap Lock: 对索引项之间的“间隙”加锁，不包括记录本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。Next-key Lock： 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。相关知识点：innodb对于行的查询使用next-key lockNext-locking keying为了解决Phantom Problem幻读问题当查询的索引含有唯一属性时，将next-key lock降级为record keyGap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1锁可写分类共享锁（S），如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不 能加排他锁。获取共享锁的事务只能读数据，不能修改数据。排他锁（X），如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获取排他锁的事务既能读数据，又能修改数据。意向共享锁（IS）： 表示事务准备给数据行记入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁。意向排他锁（IX）： 表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://suiyia.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://suiyia.github.io/tags/MySQL/"}]},{"title":"MySQL学习——事务","slug":"MySQL学习——事务","date":"2019-10-10T13:39:00.000Z","updated":"2019-10-10T14:13:30.580Z","comments":true,"path":"2019/10/10/MySQL学习——事务/","link":"","permalink":"http://suiyia.github.io/2019/10/10/MySQL学习——事务/","excerpt":"","text":"事务一系列操作，事务中的操作要么全部成功，要么全部失败。事务四大特性（ACID）原子性：事务中所有操作，要么全部成功；要么撤回到执行事务之前的状态。一致性：事务的执行使得数据库从一种正确状态转换成另一种正确状态。隔离性：事务操作之间彼此独立和透明互不影响。持久性：事务一旦提交，其结果就是永久的。即便发生系统故障，也能恢复。并发事务带来的问题脏读（Dirty Read）：一个事务可以读取其他事务未提交的执行结果丢失修改（Lost to modify）：第一个事务中修改了这个数据后，第二个事务也修改了这个数据。不可重复读（Nonrepeatable Read）：在同一次事务中，同一个查询在 T1 时间内读取某一行，在 T2 时间重新读取这一行，这一行发生了 UPDATE 或者 DELETE。幻读（Phantom Read）：用户读取某一范围的数据行时，另外一个事务在范围内插入（insert）了新行，用户再次读取时，发现新的幻影行。不可重复读重点在于 update 和 delete，而幻读的重点在于 insert。InnoDB 通过多版本并发控制（MVCC，Multiversion Conccurrency Control）解决不可重复读问题，在此基础上通过间隙锁解决幻读问题。事务隔离级别（解决并发事务带来的问题）读未提交（Read Uncommited）：所以事务能够看到其它未提交事务的结果。读已提交（Read Commited）：一个事务只能看到其它已经提交事务的结果。可重复读（Repeatable Read）：MySQl 默认事务级别，确保同一事务的多个实例在并发读取数据时，会看到相同的数据行。幻读（）串行化（Serializable）：强制事务排序，使之不可能出现冲突。在读取的数据行上面加上共享锁事务保证数据一致性原理（TODO）redo log 进入 prepare 状态，记录 binlog，redo log 改为提交状态。事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的lsn(log sequence number)号; 当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://suiyia.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://suiyia.github.io/tags/MySQL/"}]},{"title":"MySQL学习——索引","slug":"MySQL学习——索引","date":"2019-10-10T13:38:00.000Z","updated":"2019-10-10T14:11:32.824Z","comments":true,"path":"2019/10/10/MySQL学习——索引/","link":"","permalink":"http://suiyia.github.io/2019/10/10/MySQL学习——索引/","excerpt":"","text":"索引索引是一种数据结构,可以帮助我们快速的进行数据的查找。InnoDB 存储引擎的默认索引实现为 B+ 树索引。索引分类普通索引（index）：最基本的索引，没有任何约束限制。唯一索引（unique）：和普通索引类似，但是具有唯一性约束，允许有空值，一个表可以有多个唯一索引。主键索引（primary key）：特殊的唯一索引，不允许有空值，保证实体完整性，一个表只能有一个主键。联合索引：将多个列组合在一起创建索引，可以覆盖多个列。（也叫复合索引，组合索引）全文索引：主要用于查找文本中的关键字，并不是直接与索引中的值进行比较。fulltext更像是一个搜索引擎，配合match against操作使用，而不是一般的where语句加like。索引实现MyISAM 和 InnoDB 都使用 B+Tree 实现。MyISAM 叶子节点存放数据记录的地址，要找到该数据还需要去该地址寻找。InnoDB 叶子节点就是数据本身，数据表的主键作为索引的 key。-聚簇索引，MySQL索引是用一种叫做聚簇索引的数据结构实现的，是一种数据存储方式，它实际上是在同一个结构中保存了B+树索引和数据行，InnoDB表是按照聚簇索引组织的（类似于Oracle的索引组织表）。聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接指向对应数据块。explain 用法字段含义(分析是否有用到索引)select_type 表示查询中每个 select 子句的类型type 表示MySQL在表中找到所需行的方式，又称“访问类型”possible_keys 指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用key 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULLkey_len 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度ref 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值Extra 包含不适合在其他列中显示但十分重要的额外信息索引失效情况% 开头的 like 模糊匹配or 前后语句没有同时使用索引数据类型出现隐式转化（字符串列查询没有使用引号）索引列进行运算","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://suiyia.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://suiyia.github.io/tags/MySQL/"}]},{"title":"剑指offer题解 | 链表中倒数第k个节点","slug":"剑指offer题解-链表中倒数第k个节点","date":"2019-09-25T14:45:00.000Z","updated":"2019-09-25T14:44:08.380Z","comments":true,"path":"2019/09/25/剑指offer题解-链表中倒数第k个节点/","link":"","permalink":"http://suiyia.github.io/2019/09/25/剑指offer题解-链表中倒数第k个节点/","excerpt":"","text":"题目描述输入一个链表，输出该链表中倒数第k个结点。解题想法设定两个标志位，low 和 high，high 先走 k-1 步，剩下的 low 和 high 一起走，high 等于 null 时就返回 low 节点考虑链表长度为空，链表长度小于 k 的情况代码实现123456789101112131415161718192021public ListNode FindKthToTail(ListNode head,int k) &#123; if (head == null)&#123; return null; &#125; ListNode low = head; ListNode high = head; for (int i = 0; i &lt;= k-1; i++) &#123; if (head == null &amp;&amp; i &lt; k)&#123; // 链表长度小于 k return null; &#125; high = head.next; head = head.next; &#125; while (high != null)&#123; low = low.next; high = high.next; &#125; return low;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 反转链表","slug":"剑指offer题解-反转链表","date":"2019-09-25T14:44:00.000Z","updated":"2019-09-25T15:36:34.199Z","comments":true,"path":"2019/09/25/剑指offer题解-反转链表/","link":"","permalink":"http://suiyia.github.io/2019/09/25/剑指offer题解-反转链表/","excerpt":"","text":"题目描述输入一个链表，反转链表后，输出新链表的表头。解题想法两个索引位保存链的指向信息，然后同步右移，原地反转代码实现1234567891011121314public ListNode ReverseList(ListNode head) &#123; if (head == null)&#123; return null; &#125; ListNode low = null; ListNode high = null; while (head != null)&#123; high = head.next; head.next = low; low = head; head = high; &#125; return low; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 调整数组顺序使奇数位于偶数前面","slug":"剑指offer题解-调整数组顺序使奇数位于偶数前面","date":"2019-09-24T15:40:00.000Z","updated":"2019-09-24T15:42:10.869Z","comments":true,"path":"2019/09/24/剑指offer题解-调整数组顺序使奇数位于偶数前面/","link":"","permalink":"http://suiyia.github.io/2019/09/24/剑指offer题解-调整数组顺序使奇数位于偶数前面/","excerpt":"","text":"题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分并保证奇数和奇数，偶数和偶数之间的相对位置不变。解题想法插入排序从左自右找到第一个偶数，然后在该位置右边找到第一个奇数，进行交换。代码实现123456789101112131415161718192021222324252627282930313233public void reOrderArray(int [] array) &#123; if (array.length == 0 || array.length == 1)&#123; return; &#125; int i = 0; int j = 0; while (i &lt; array.length)&#123; // 找到第一个偶数 while ((array[i] &amp; 1) == 1)&#123; i++; &#125; j = i + 1; while (j &lt; array.length)&#123; // 找到第一个奇数 if ((array[j] &amp; 1) == 0)&#123; j++; &#125;else &#123; break; &#125; &#125; // 插入排序 if (j &lt; array.length)&#123; int temp = array[j]; for (int k = j-1; k &gt;= i ; k--) &#123; array[k+1] = array[k]; &#125; array[i++] = temp; &#125;else &#123; break; &#125; &#125;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 数值的整数次方","slug":"剑指offer题解-数值的整数次方","date":"2019-09-24T14:22:00.000Z","updated":"2019-09-24T14:58:09.152Z","comments":true,"path":"2019/09/24/剑指offer题解-数值的整数次方/","link":"","permalink":"http://suiyia.github.io/2019/09/24/剑指offer题解-数值的整数次方/","excerpt":"","text":"题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。保证base和exponent不同时为0解题想法主要考察 指数函数 的特征以及程序的健壮性底数不能为负数底数为 0 时，0 的 n 次方始终为 0指数为 0 时，且任意数的 0 次方都是 1指数为负数时，结果是越来越小的常规思路：循环累乘，时间复杂度 0（N）递归思路：当n为偶数，a^n =（a^n/2）×（a^n/2），当 n为奇数，a^n = a^[(n-1)/2] × a^[(n-1)/2] * a代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 循环思路public double Power(double base, int exponent) &#123; if (base == 0 )&#123; return 0; &#125; if (exponent == 0)&#123; return 1; &#125; boolean flag = false; if (exponent &lt; 0)&#123; exponent = -1*exponent; flag = true; &#125; double result = 1; for (int i = 0; i &lt; exponent; i++) &#123; result = result * base; &#125; if (flag)&#123; return 1.0/result; &#125;else &#123; return result; &#125;&#125;// 递归思路public double Power1(double base, int expone if (base == 0 )&#123; return 0; &#125; if (exponent == 0)&#123; return 1; &#125; double result = 0.0; int n = Math.abs(exponent); result = Power1(base,n &gt;&gt; 1); result = result * result; if ((n &amp; 1) == 1)&#123; // 如果指数n为奇数，则要再乘一次底数base result = result * base; &#125; if (exponent &lt; 0)&#123; // 如果指数为负数，则应该求result的倒数 result = 1.0/result; &#125; return result;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 二进制中 1 的个数","slug":"剑指offer题解-二进制中-1-的个数","date":"2019-09-23T14:57:00.000Z","updated":"2019-09-24T14:22:21.274Z","comments":true,"path":"2019/09/23/剑指offer题解-二进制中-1-的个数/","link":"","permalink":"http://suiyia.github.io/2019/09/23/剑指offer题解-二进制中-1-的个数/","excerpt":"","text":"题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。解题想法位比较思路1：使用整数右移与 1 进行位比较，计算总个数。但是如果是负数，高位右移将会补 1，所以可以使用 &gt;&gt;&gt; 无符号右移或者将负数变为正数再进行右移。使用 1 左移的方式进行位比较，一直比较到 Interger.MAX_VALUE = 0x7fffffff思路2：如果一个整数不为 0，那么这个整数至少有一位是 1。如果我们把这个整数减 1，那么原来处在整数最右边的 1 就会变为 0，1 右边的 0 变为 1。其余所有位将不会受到影响。然后将两者相与，如果结果不为 0，说明原来整数最右边 1 的左边里面肯定包含 1，然后减 1 继续这么循环下去，不为 0 的次数就是 1 出现的次数。例：1100 &amp; 1011 = 1000，数字 1100 最右边的 1 左边还有一个 1代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 先变为正整数public int NumberOf12(int n) &#123; if (n == 0)&#123; return 0; &#125; int count = 0; if (n &lt; 0)&#123; n = n &amp; 0x7fffffff; count ++; &#125; while (n != 0)&#123; if ((n &amp; 1) != 0)&#123; count++; &#125; n = n &gt;&gt; 1; &#125; return count;&#125;// 整数无符号右移public int NumberOf13(int n) &#123; if (n == 0)&#123; return 0; &#125; int count = 0; while (n != 0)&#123; if ((n &amp; 1) != 0)&#123; count++; &#125; n = n &gt;&gt;&gt; 1; &#125; return count;&#125;// 1 左移public int NumberOf1(int n) &#123; if (n == 0)&#123; return 0; &#125; int count = 0; int flag = 1; while (flag != 0)&#123; if (flag &amp; n == 1)&#123; count ++; &#125; flag = flag &lt;&lt; 1; &#125; return flag;&#125;// 思路 2public int NumberOf11(int n) &#123; if (n == 0)&#123; return 0; &#125; int count = 0; while (n != 0)&#123; count ++; n = n &amp; (n-1); &#125; return count;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 矩形覆盖","slug":"剑指offer题解-矩形覆盖","date":"2019-09-23T14:49:00.000Z","updated":"2019-09-23T14:57:02.886Z","comments":true,"path":"2019/09/23/剑指offer题解-矩形覆盖/","link":"","permalink":"http://suiyia.github.io/2019/09/23/剑指offer题解-矩形覆盖/","excerpt":"","text":"题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？解题想法实质是斐波拉契数列代码实现12345678// 递归版本 public int RectCover(int target) &#123; if (n == 1) return 1; if (n == 2) return 2; return RectCover(n - 1) + RectCover(n - 2) * 2; &#125;注意点","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 变态跳台阶","slug":"剑指offer题解-变态跳台阶","date":"2019-09-23T13:52:00.000Z","updated":"2019-09-23T14:49:00.226Z","comments":true,"path":"2019/09/23/剑指offer题解-变态跳台阶/","link":"","permalink":"http://suiyia.github.io/2019/09/23/剑指offer题解-变态跳台阶/","excerpt":"","text":"题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法解题想法参考前面的斐波拉契数列第 n 层台阶可能由：第 n-1 跳一阶过来，还可能由第 n-2 跳两阶过来等，所以总情况 f（n）= f（n-2）+ f（n-1）+ … + f(1)递推关系式实现 f（n）= 2 * f（n-1）代码实现12345678910111213141516171819202122232425262728// 递归版本public int Fibonacci(int n) &#123; if (n == 0)&#123; return 0; &#125; if (n == 1)&#123; return 1; &#125; return 2 * Fibonacci(n-1);&#125; // 循环public int Fibonacci23(int n)&#123; if (n == 0)&#123; return 0; &#125; if (n == 1)&#123; return 1; &#125; int b = 1; int c = 0; for (int i = 1;i&lt;n;i++)&#123; c = 2 * b; b = c; &#125; return c;&#125;注意点","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 跳台阶","slug":"剑指offer题解-跳台阶","date":"2019-09-23T13:15:00.000Z","updated":"2019-09-23T13:51:57.234Z","comments":true,"path":"2019/09/23/剑指offer题解-跳台阶/","link":"","permalink":"http://suiyia.github.io/2019/09/23/剑指offer题解-跳台阶/","excerpt":"","text":"题目描述一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。解题想法第 n 层台阶可能由：第 n-1 跳一阶过来，还可能由第 n-2 跳两阶过来，所以总情况 f（n）= f（n-2）+ f（n-1）其实就是斐波拉契数列代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243// 递归版本public int Fibonacci(int n) &#123; if (n == 0)&#123; return 0; &#125; if (n == 1)&#123; return 1; &#125; return Fibonacci(n-1) + Fibonacci(n-2);&#125; // 循环public int Fibonacci23(int n)&#123; if (n == 0)&#123; return 0; &#125; if (n == 1 || n == 2)&#123; return 1; &#125; int a = 0; int b = 1; int c = 0; for (int i = 1;i&lt;n;i++)&#123; c = a + b; a = b; b = c; &#125; return c;&#125;// 多项式递推public int Fibonacci2(int n) &#123; if(n==0) &#123; return 0; &#125; else if(n==1||n==2) &#123; return 1; &#125; else if(n==3) &#123; return 2; &#125; else &#123; return 3*Fibonacci(n-3)+2*Fibonacci(n-4); &#125;&#125;注意点","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 斐波拉契数列","slug":"剑指offer题解-斐波拉契数列","date":"2019-09-23T12:39:00.000Z","updated":"2019-09-23T13:14:37.538Z","comments":true,"path":"2019/09/23/剑指offer题解-斐波拉契数列/","link":"","permalink":"http://suiyia.github.io/2019/09/23/剑指offer题解-斐波拉契数列/","excerpt":"","text":"题目描述大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项（从 0 开始，第 0 项为 0）。n&lt;=39解题想法递归，f（n）= f（n-1）+ f（n-2），但是每一次的迭代计算结果没有保存，很容易栈溢出循环方式，每次的结果进行累加多项关系式递推代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243// 递归版本public int Fibonacci(int n) &#123; if (n == 0)&#123; return 0; &#125; if (n == 1)&#123; return 1; &#125; return Fibonacci(n-1) + Fibonacci(n-2);&#125; // 循环public int Fibonacci23(int n)&#123; if (n == 0)&#123; return 0; &#125; if (n == 1 || n == 2)&#123; return 1; &#125; int a = 0; int b = 1; int c = 0; for (int i = 1;i&lt;n;i++)&#123; c = a + b; a = b; b = c; &#125; return c;&#125;// 多项式递推public int Fibonacci2(int n) &#123; if(n==0) &#123; return 0; &#125; else if(n==1||n==2) &#123; return 1; &#125; else if(n==3) &#123; return 2; &#125; else &#123; return 3*Fibonacci(n-3)+2*Fibonacci(n-4); &#125;&#125;注意点","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[]},{"title":"剑指offer题解 | 旋转数组的最小数字","slug":"剑指offer题解-旋转数组的最小数字","date":"2019-09-19T15:27:00.000Z","updated":"2019-09-23T12:39:25.513Z","comments":true,"path":"2019/09/19/剑指offer题解-旋转数组的最小数字/","link":"","permalink":"http://suiyia.github.io/2019/09/19/剑指offer题解-旋转数组的最小数字/","excerpt":"","text":"题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。解题想法常规思路：从头到尾遍历一遍找到最小值，时间复杂度 O（N）方法二非递减数组旋转，旋转之后可以看做是两个非递减数组的拼接，当 a[index] &gt; a[index+1] 时，最小值就是 a[index+1]。有序数组的查找，可以选择二分查找规律（数组内元素都不相同）：若 A[mid] &gt; a[low]，那么最小值一定在 mid 及 high 之间；若 A[mid] &lt; a[low]，那么最小值一定在 low 及 mid 之间注意点：如果 A[mid] = a[low]，那么就不能判断最小值在哪一个位置。例如 01111 旋转可以变为 11110 和 10111。只能从头到尾遍历代码实现方法二实现123456789101112131415161718192021222324252627282930313233343536373839404142public int minNumberInRotateArray(int [] array) &#123; if (array.length == 0)&#123; return 0; &#125; if (array.length == 1)&#123; return array[0]; &#125; int low = 0; int high = array.length - 1; while(low &lt; high)&#123; int mid = (low + high) / 2; if (low == high -1)&#123; return array[high]; &#125; if (array[mid] &gt; array[low])&#123; // 最小值在右边 low = mid; &#125;else if (array[mid] &lt; array[low])&#123; // 最小值在左边 high = mid; &#125;else &#123; // 分辨不出最小值位置 return serach(array); &#125; &#125; return -1;&#125; // 从头到尾查找一遍 public int serach(int[] array)&#123; int minValue = Integer.MAX_VALUE; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] &lt; minValue)&#123; minValue = array[i]; &#125; &#125; return minValue;&#125;注意点数组为空，或者只有一个长度的情况，考虑数组边界问题","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[]},{"title":"剑指offer题解 | 两个栈实现队列","slug":"剑指offer题解-两个栈实现队列","date":"2019-09-19T13:13:00.000Z","updated":"2019-09-19T15:13:51.892Z","comments":true,"path":"2019/09/19/剑指offer题解-两个栈实现队列/","link":"","permalink":"http://suiyia.github.io/2019/09/19/剑指offer题解-两个栈实现队列/","excerpt":"","text":"题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。时间限制：1秒 空间限制：32768K解题想法方法 1（常规思路，移动次数较多）stack1 专门用于 push 数据，stack2 专门 pop 数据。调用 pop() 方法时候，stack1 数据全部 push 到 stack2，保存 stack2 最顶上元素。pop 方法结束之前，将 stack2 的数据再推回到 stack1 中。方法 2（推荐，移动次数少）stack1 专门用于 push 数据。pop 方法调用的时候，若 stack2 为空就先将 stack1 中的全部数据推到 stack2，然后 pop stack2 中的元素；否则直接 pop stack2 中的数据。代码实现方法二123456789101112131415161718Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if (stack1.isEmpty() &amp;&amp; stack2.isEmpty())&#123; throw new RuntimeException(&quot;Empty exception!&quot;); &#125; if (stack2.isEmpty())&#123; while (!stack1.isEmpty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;注意点pop 数据考虑边界情况，栈为空","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 重建二叉树","slug":"剑指Offer题解-重建二叉树","date":"2019-09-18T14:32:00.000Z","updated":"2019-09-19T15:13:51.912Z","comments":true,"path":"2019/09/18/剑指Offer题解-重建二叉树/","link":"","permalink":"http://suiyia.github.io/2019/09/18/剑指Offer题解-重建二叉树/","excerpt":"","text":"题目描述输入一个链表，按链表从尾到头的顺序返回一个ArrayList。时间限制：1秒 空间限制：32768K解题想法方法 1. 使用栈保存遍历链表的结果，然后 push 栈输出到 ArrayList方法 2. 递归方式实现倒序输出代码实现递归方式实现12345678910111213141516171819ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; if (listNode != null)&#123; printListFromTailToHead(listNode.next); arrayList.add(listNode.val); &#125; return arrayList; &#125; class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 从尾到头打印链表","slug":"剑指Offer题解-从尾到头打印链表","date":"2019-09-17T15:18:00.000Z","updated":"2019-09-19T15:13:51.901Z","comments":true,"path":"2019/09/17/剑指Offer题解-从尾到头打印链表/","link":"","permalink":"http://suiyia.github.io/2019/09/17/剑指Offer题解-从尾到头打印链表/","excerpt":"","text":"题目描述输入一个链表，按链表从尾到头的顺序返回一个ArrayList。时间限制：1秒 空间限制：32768K解题想法方法 1. 使用栈保存遍历链表的结果，然后 push 栈输出到 ArrayList方法 2. 递归方式实现倒序输出代码实现递归方式实现12345678910111213141516171819ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; if (listNode != null)&#123; printListFromTailToHead(listNode.next); arrayList.add(listNode.val); &#125; return arrayList; &#125; class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 替换空格","slug":"替换空格-剑指Offer","date":"2019-09-17T13:31:00.000Z","updated":"2019-09-19T15:13:51.870Z","comments":true,"path":"2019/09/17/替换空格-剑指Offer/","link":"","permalink":"http://suiyia.github.io/2019/09/17/替换空格-剑指Offer/","excerpt":"","text":"题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。时间限制：1秒 空间限制：32768K解题想法不使用工具类思路：先统计空格出现次数，然后就知道了替换后的字符串长度，使用另外的字符串数组保存替换后的字符串，然后从右往左进行填充代码实现先统计空格出现的次数，出现一次空格，那么增加的长度就是加 2，N 个空格就是增加了 N*2然后用另外的数组保存替换后的字符12345678910111213141516171819202122232425262728293031public static String replaceSpace(StringBuffer str) &#123; // 统计空格数量 int spaceCount = 0; for (int i = 0; i &lt; str.length(); i++) &#123; if (str.charAt(i) == &apos; &apos;)&#123; spaceCount++; &#125; &#125; int length = str.length(); // 用另外的字符数组保存字符 char[] a = new char[length + spaceCount * 2]; // 字符数组索引，从最后面开始 int afterIndex = length + spaceCount * 2 - 1; for (int j = length - 1; j &gt;= 0; j--) &#123; if (str.charAt(j) != &apos; &apos;)&#123; // 如果不是空格，就直接赋值，索引也跟着减 a[afterIndex] = str.charAt(j); afterIndex --; &#125;else &#123; a[afterIndex] = &apos;0&apos;; a[afterIndex - 1] = &apos;2&apos;; a[afterIndex - 2] = &apos;%&apos;; afterIndex = afterIndex - 3; &#125; &#125; return String.valueOf(a); &#125;注意点从后往前填充相对简单点","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 二维数组中的查找 ","slug":"二维数组中的查找-剑指Offer","date":"2019-09-16T15:11:00.000Z","updated":"2019-09-19T15:11:08.513Z","comments":true,"path":"2019/09/16/二维数组中的查找-剑指Offer/","link":"","permalink":"http://suiyia.github.io/2019/09/16/二维数组中的查找-剑指Offer/","excerpt":"","text":"题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。时间限制：1秒 空间限制：32768K解题想法常规思路：左上角开始，每行从左到右都轮询一次。时间复杂度 O（N^2）空间复杂度 O（1）从右下角开始，每行从左往右轮询：上面一行相同列的元素比当前元素小，右边同行元素比当前元素大，那么不用全部元素比较。时间复杂度：O(行高 + 列宽)空间复杂度：O(1)从右上角开始，从右往左。原理同上从右下角开始，和常规思路类似代码实现M 行 N 列数组，寻找元素 K左下角开始寻找123456789101112131415public static boolean Find(int target, int [][] array) &#123; int i = array.length - 1; int j = 0; while (i &gt;= 0 &amp;&amp; j &lt; array[0].length)&#123; if (array[i][j] &gt; target) &#123; i--; &#125;else if(array[i][j] &lt; target)&#123; j++; &#125;else &#123; return true; &#125; &#125; return false;&#125;注意点数组边界问题常规思路，遇到有序序列进行查找时，可以使用二分查找，时间复杂度将进一步降低，时间复杂度 Mlog(n)","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"日志框架学习及Log4j 2 概念整理","slug":"Log4j-2-基本概念","date":"2019-09-04T06:52:00.000Z","updated":"2019-10-02T02:27:36.963Z","comments":true,"path":"2019/09/04/Log4j-2-基本概念/","link":"","permalink":"http://suiyia.github.io/2019/09/04/Log4j-2-基本概念/","excerpt":"","text":"日志框架分类日志框架按照功能可以分为日志接口、日志实现两部分。编写程序时，推荐使用日志接口的 API 进行方法调用，然后使用对应的日志实现框架打印日志。常用日志框架的使用方式为： Log4j2-api（接口） + Log4j2-core（实现）。SLF4J（接口）+ 其它日志框架实现。日志接口，日志的接口规范，它对用户提供了统一的日志接口，屏蔽了不同日志组件的差异。Apache Commons Logging Component，2014 年之后文档没有再更新SLF4J（Simple Logging Facade for Java），定义了各种日志框架（java.util.logging, logback, log4j 等）的抽象，是 Java 日志输出的标准接口。需引入 slf4j-api-xxx.jarslf4j-api 不同版本是互相兼容的，不同系统之间的 slf4j-api 版本不同并不会造成冲突；但是其实现类是可能存在冲突的，例如使用 slf4j-api-1.0.jar 和 slf4j-simple-1.0.jar 是没有问题的，但是使用 slf4j-simple-2.0.jar 可能存在问题。在引入相关依赖的时候，要保证 slf4j-api 的版本和其实现日志框架的版本一致！Log4J2 api，log4j 2-api 包和 slf4J 类似，定义日志输出接口规范，具体日志输出形式根据依赖的日志实现 jar 包确定日志实现，定义具体日志打印内容JDKLog，java.util.logging.Logger，jdk 自带的日志工具类，它通过 getLogger 获取日志对象、setLevel 定义日志级别、Handler 定义日志输出方式 （输出到文件、控制台、网络流）、Formatter 定义日志输出样式。需引入 slf4j-jdk14-xxx.jarLOGBack，继承于 Log4J，官网表示它可作为 log4j 的 successor（继承者），比 log4j 更好！它包括 3 个模块：logback-core，下面两个模块的基础依赖logback-classic，对 log4j 进行了显著地改进，实现了 SLF4J API，方便随时切换日志框架。logback-access，与 Servlet 容器（Tomcat、Jetty）进行集成，提供 HTTP 访问日志功能。Log4J，2015 年开始已经停止维护Log4J2 core Log4J 升级版，2019-08-06 版本更新至 2.12.1，API 相关用法不兼容 1.X 版本Log4j 2 内置概念Markers：为某条日志添加标志位，使用 %marker 进行输出1234567891011121314public void test()&#123; private static final Marker SQL_MARKER = MarkerManager.getMarker(&quot;SQL&quot;); Marker markerA = MarkerManager.getMarker(&quot;Marker A&quot;); Marker markerB = MarkerManager.getMarker(&quot;Marker B&quot;); logger.debug(markerA,&quot;your name is &#123;&#125; &quot;,&quot;Jack&quot;); logger.debug(markerB,&quot;your name is &#123;&#125; &quot;,&quot;Ma&quot;);&#125;log4j.xml：&lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M %marker - %msg%xEx%n&quot;/&gt;Console Out：10:14:02.639 DEBUG FlowTracing 60 test Marker A - your name is Jack 10:14:02.642 DEBUG FlowTracing 61 test Marker B - your name is MaLookups：在配置文件中添加变量、使用变量Appenders：定义日志事件输出方式（日志文件名称、路径、什么级别日志才能输出、文件大小等等），其实就是文件流输出定义。AsyncAppender 用另外的线程记录日志，默认使用 ArrayBlockingQueue 队列进行日志记录，当发生异常时，默认会忽略异常，记得手动开启，并使用FailoverAppender 对异常情况进行补充打印输出ConsoleAppender，控制台输出FailoverAppender，当主 Appender 失败时，它将起作用FileAppender，文件输出，当多个程序对同一文件进行输出时，各自程序之间的配置也不受影响JDBCAppender，直接写到数据库HttpAppender，http 请求发送到另外的服务接收，如果服务返回的不是 2XX，将会抛出异常。KafkaAppender，发送到 KafkaRollingFileAppender，可以滚动的文件输出，包含触发规则（触发滚动条件：时间、大小）、滚动规则（怎么进行更新：文件数量），默认日志文件个数为 7 个。等等Layouts：Appender 使用定义好的 LayOut 对 LogEvent 进行格式化输出，CSV Layouts，以 Comma Separated Value (CSV) 形式输出JSON Layout，JSON 格式输出Pattern Layout，用特殊的字符输出对应的内容，定制化强XML LayoutLocation Infomation，当日志中需要日志所在类、方法、代码行数这些信息时，会花费 1.3-5 倍的时间，相比不需要 Location Infomation 的场景。并且在使用异步的 Appender 时，默认的 Location Infomation 默认关闭，如果开启，会比不开启花费 30-100 倍的性能消耗Filters：决定哪些事件可以输出，哪些事件不能输出。过滤结果有 3 个结果，ACCEPT（允许）, DENY（拒绝输出）or NEUTRAL（中立、默认）。BurstFilter，当每秒日志输出事件速率大于一定值，将会抛弃掉级别低的日志CompositeFilter，直接在 configuration 级别添加多个过滤器DynamicThresholdFilter，根据一些属性值去动态修改该条日志的输出级别MapFilter，如果 LogEvent 中的 MapMessage 内包含特定属性，就可以选择过滤MarkerFilter、NoMarkerFilter，对应定义或者未定义 Marker 的事件进行过滤RegexFilter，正则过滤 formatted or unformatted messageThreadContextMapFilter ，对 ThreadContextMap 中的内容进行过滤ThresholdFilter，对 Level 进行过滤TimeFilter，根据某个时间点、时间段进行过滤3. Log4J 2 Java API 用法Flow Tracing日志跟踪Markers（标记）对于有特定标识需求的地方，可以使用 Marker 进行标记，并且用 %marker 进行打印输出。ThreadContextMapped Diagnostic Context（MDC）的实现，类似 request，可以存放 key-value 键值对，也可以销毁，使用 %X{key} 输出。the MDC is a map which stores the context data of the particular thread where the context is running.12345678910%X&#123;id&#125; 输出 context map 中 key = id 的值%X 输出 context map 所有值public void test()&#123; ThreadContext.put(&quot;id&quot;, &quot;321&quot;); // Add the fishtag; ThreadContext.put(&quot;name&quot;, &quot;996&quot;); // Add the fishtag; logger.debug(&quot;Message 1&quot;); logger.debug(&quot;Message 2&quot;); ThreadContext.clearAll();&#125;其他log4j-slf4j-impl 是 slf4j 转接到 log4j 2 的日志输出框架。slf4j-log4j12 是 slf4j 转接到 log4j 1.x 的日志输出框架 ，而 log4j 1.x 已经在 2015 年 8 月就停止更新了。log4j 官方建议升级到 log4j 2","categories":[],"tags":[{"name":"Log4j","slug":"Log4j","permalink":"http://suiyia.github.io/tags/Log4j/"}]},{"title":"浮点数整数转换精度丢失问题","slug":"浮点数整数转换精度丢失问题","date":"2019-08-10T09:44:00.000Z","updated":"2019-09-19T10:36:57.304Z","comments":true,"path":"2019/08/10/浮点数整数转换精度丢失问题/","link":"","permalink":"http://suiyia.github.io/2019/08/10/浮点数整数转换精度丢失问题/","excerpt":"","text":"浮点数转换精度丢失在线支付对接，支付商（微信、支付宝、银联等）的接口中，定义的金额单位不一样，有时候需要对分、元进行相互转换，转换的过程中容易出现问题。下面的例子，系统中接收的参数是元，请求接口单位是分，在转换过程中出现精度丢失，少扣了用户 1 分钱。1234567public class Main &#123; public static void main(String[] args) &#123; System.out.println((int) (0.29*100)); &#125;&#125;输出： 28错误原因0.29*100 = 28.999999999999996…浮点数强制转换成整数类型会舍弃非整数部分解决方法(int) Math.round(0.29*100) -&gt; 29浮点数大小比较错误12345678910// 例子 1System.out.println(0.1d == 0.1f); // false// 例子 2System.out.println(10.222222225f == 10.222222229f); // trueSystem.out.println(10.222222225f &gt; 10.222222229f); // falseSystem.out.println(10.222222225f &lt; 10.222222229f); // false// 例子 3Double a = Double.valueOf(&quot;0.0&quot;);Double b = Double.valueOf(&quot;-0.0&quot;);System.out.println(a.equals(b)); // false浮点数由于精度问题，并不能用 ==，&gt;，&lt; 来进行大小比较，最好的方式就是定义一个精度，用差的绝对值比较，在精度范围内就认为是相等的官方文档参考Java中的浮点数比较 == equals 和 compare","categories":[],"tags":[{"name":"浮点数","slug":"浮点数","permalink":"http://suiyia.github.io/tags/浮点数/"}]},{"title":"Springboot 项目运用 Redis 缓存数据","slug":"Springboot-项目运用-Redis-缓存数据","date":"2019-08-10T09:40:00.000Z","updated":"2019-08-10T09:51:13.059Z","comments":true,"path":"2019/08/10/Springboot-项目运用-Redis-缓存数据/","link":"","permalink":"http://suiyia.github.io/2019/08/10/Springboot-项目运用-Redis-缓存数据/","excerpt":"","text":"介绍Springboot 项目与 Redis 结合获取数据pom 依赖主要是 mybatis、redis 的相关依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748server: servlet: context-path: /web port: 8080spring: datasource: druid: # 数据库访问配置, 使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useunicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: 123456 # 连接池配置 initial-size: 5 min-idle: 5 max-active: 20 # 连接等待超时时间 max-wait: 30000 # 配置检测可以关闭的空闲连接间隔时间 time-between-eviction-runs-millis: 60000 # 配置连接在池中的最小生存时间 min-evictable-idle-time-millis: 300000 validation-query: select &apos;1&apos; from dual test-while-idle: true test-on-borrow: false test-on-return: false # 打开PSCache，并且指定每个连接上PSCache的大小 pool-prepared-statements: true max-open-prepared-statements: 20 max-pool-prepared-statement-per-connection-size: 20 # 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, &apos;wall&apos;用于防火墙 filters: stat,wall # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔 aop-patterns: com.springboot.servie.* redis: # Redis数据库索引（默认为0） database: 0 # Redis服务器地址 host: localhost # Redis服务器连接端口 port: 6379logging: level: com.example.demo.dao: debugRedis 配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123; // 自定义缓存key生成策略 @Override @Bean public KeyGenerator keyGenerator() &#123; return new KeyGenerator() &#123; @Override public Object generate(Object target, java.lang.reflect.Method method, Object... params) &#123; StringBuffer sb = new StringBuffer(); sb.append(target.getClass().getName()); sb.append(method.getName()); for (Object obj : params) &#123; sb.append(obj.toString()); &#125; return sb.toString(); &#125; &#125;; &#125; // 缓存管理器 @Bean public CacheManager cacheManager(RedisConnectionFactory connectionFactory) &#123; RedisCacheManager cacheManager = RedisCacheManager.create(connectionFactory); return cacheManager; &#125; @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123; StringRedisTemplate template = new StringRedisTemplate(factory); setSerializer(template);// 设置序列化工具 template.afterPropertiesSet(); return template; &#125; private void setSerializer(StringRedisTemplate template) &#123; @SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;) Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setValueSerializer(jackson2JsonRedisSerializer); &#125;&#125;dao 层以及实现使用 MyBatis 注解方式实现数据访问123456789101112131415@Mapperpublic interface StudentManager &#123; @Update(&quot;update student set sname=#&#123;sname&#125;,ssex=#&#123;ssex&#125; where sno=#&#123;sno&#125;&quot;) int update(Student student); @Delete(&quot;delete from student where sno=#&#123;sno&#125;&quot;) void deleteStudentBySno(String sno); @Select(&quot;select * from student where sno=#&#123;sno&#125;&quot;) @Results(id = &quot;student&quot;, value = &#123; @Result(property = &quot;sno&quot;, column = &quot;sno&quot;, javaType = String.class), @Result(property = &quot;sname&quot;, column = &quot;sname&quot;, javaType = String.class), @Result(property = &quot;ssex&quot;, column = &quot;ssex&quot;, javaType = String.class) &#125;) Student queryStudentBySno(String sno);&#125;service 层及实现queryStudentBySno 方法使用了注解 @Cacheable(key=”#p0”)，即将 id 作为 redis 中的 key 值@CacheConfig(cacheNames = “student”) 一个类中可能会有多个缓存操作，而这些缓存操作可能是重复的@Cacheable 是用来声明方法是可缓存的@CachePut 主要用于数据新增和修改操作上@CacheEvict 通常用在删除方法上，用来从缓存中移除相应数据123456789101112131415161718192021222324252627282930313233343536@CacheConfig(cacheNames = &quot;student&quot;)public interface StudentService &#123; @CachePut(key = &quot;#p0.sno&quot;) Student update(Student student); @CacheEvict(key = &quot;#p0&quot;, allEntries = true) void deleteStudentBySno(String sno); @Cacheable(key = &quot;#p0&quot;) Student queryStudentBySno(String sno);&#125;@Servicepublic class StudentServiceImpl implements StudentService &#123; @Autowired private StudentManager studentManager; @Override public Student update(Student student) &#123; this.studentManager.update(student); return this.studentManager.queryStudentBySno(student.getSno()); &#125; @Override public void deleteStudentBySno(String sno) &#123; this.studentManager.deleteStudentBySno(sno); &#125; @Override public Student queryStudentBySno(String sno) &#123; return this.studentManager.queryStudentBySno(sno); &#125;&#125;Test 用例第一次从数据库中读取，第二次直接从缓存读取123456789101112131415161718192021@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123; @Autowired private StudentService studentService; @Test public void contextLoads() &#123; System.out.println(studentService.queryStudentBySno(&quot;001&quot;).toString()); System.out.println(studentService.queryStudentBySno(&quot;001&quot;).toString()); &#125;&#125;2019-08-10 17:27:32.739 DEBUG 7140 --- [ main] c.e.d.d.S.queryStudentBySno : ==&gt; Preparing: select * from student where sno=? 2019-08-10 17:27:33.053 DEBUG 7140 --- [ main] c.e.d.d.S.queryStudentBySno : ==&gt; Parameters: 001(String)2019-08-10 17:27:33.108 DEBUG 7140 --- [ main] c.e.d.d.S.queryStudentBySno : &lt;== Total: 1Student(sno=001, sname=KangKang, ssex=M )Student(sno=001, sname=KangKang, ssex=M )总结","categories":[{"name":"Spring学习","slug":"Spring学习","permalink":"http://suiyia.github.io/categories/Spring学习/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://suiyia.github.io/tags/Springboot/"},{"name":"Redis","slug":"Redis","permalink":"http://suiyia.github.io/tags/Redis/"}]},{"title":"Springboot 与 AOP 实现","slug":"Springboot-与-AOP-实现","date":"2019-08-10T09:39:00.000Z","updated":"2019-08-10T09:51:13.073Z","comments":true,"path":"2019/08/10/Springboot-与-AOP-实现/","link":"","permalink":"http://suiyia.github.io/2019/08/10/Springboot-与-AOP-实现/","excerpt":"","text":"介绍Springboot 项目 AOP 实现，记录方法的执行过程pom 依赖druid、JdbcTemplate、aop123456789101112131415161718192021222324252627282930313233343536373839&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;代码实现Mysql 脚本12345678910CREATE TABLE SYS_LOG ( ID INT(20) NOT NULL COMMENT &apos;用户名&apos; PRIMARY KEY AUTO_INCREMENT , USERNAME VARCHAR(50) NULL COMMENT &apos;用户名&apos;, OPERATION VARCHAR(50) NULL COMMENT &apos;用户操作&apos;, TIME INT(11) NULL COMMENT &apos;响应时间&apos;, METHOD VARCHAR(1024) NULL COMMENT &apos;请求方法&apos;, PARAMS VARCHAR(1024) NULL COMMENT &apos;请求参数&apos;, IP VARCHAR(64) NULL COMMENT &apos;IP地址&apos;, CREATE_TIME DATE NULL COMMENT &apos;创建时间&apos;);实体类123456789101112131415161718192021import java.io.Serializable;import java.util.Date;import lombok.Getter;import lombok.Setter;import lombok.ToString;@Setter@Getter@ToStringpublic class SysLog implements Serializable &#123; private Integer id; private String username; private String operation; private Integer time; private String method; private String params; private String ip; private Date createTime;&#125;定义一个方法级别的 @Log 注解，需要监控的方法加上该注解就行12345@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Log &#123; String value() default &quot;&quot;;&#125;定义 dao 方法，保存日志到数据库123public interface SysLogDao &#123; void saveSysLog(SysLog sysLog);&#125;1234567891011121314151617@Componentpublic class SysLogDaoImpl implements SysLogDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public void saveSysLog(SysLog sysLog) &#123; StringBuffer sql = new StringBuffer(&quot;insert into sys_log &quot;); sql.append(&quot;(username,operation,time,method,params,ip,create_time) &quot;); sql.append(&quot;values(:username,:operation,:time,:method,&quot;); sql.append(&quot;:params,:ip,:createTime)&quot;); NamedParameterJdbcTemplate npjt = new NamedParameterJdbcTemplate(this.jdbcTemplate.getDataSource()); npjt.update(sql.toString(), new BeanPropertySqlParameterSource(sysLog)); &#125;&#125;切面切点定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@Aspect@Componentpublic class LogAspect &#123; @Autowired private SysLogDao sysLogDao; @Pointcut(&quot;@annotation(com.example.demo.annotion.Log)&quot;) public void pointcut()&#123;&#125; @Around(&quot;pointcut()&quot;) public Object around(ProceedingJoinPoint proceedingJoinPoint)&#123; Object result = null; long beginTime = System.currentTimeMillis(); try &#123; // 执行方法 result = proceedingJoinPoint.proceed(); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; // 执行时长(毫秒) long time = System.currentTimeMillis() - beginTime; // 保存日志 saveLog(proceedingJoinPoint, time); return result; &#125; private void saveLog(ProceedingJoinPoint joinPoint, long time) &#123; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); SysLog sysLog = new SysLog(); Log logAnnotation = method.getAnnotation(Log.class); if (logAnnotation != null) &#123; // 注解上的描述 sysLog.setOperation(logAnnotation.value()); &#125; // 请求的方法名 String className = joinPoint.getTarget().getClass().getName(); String methodName = signature.getName(); sysLog.setMethod(className + &quot;.&quot; + methodName + &quot;()&quot;); // 请求的方法参数值 Object[] args = joinPoint.getArgs(); // 请求的方法参数名称 LocalVariableTableParameterNameDiscoverer u = new LocalVariableTableParameterNameDiscoverer(); String[] paramNames = u.getParameterNames(method); if (args != null &amp;&amp; paramNames != null) &#123; String params = &quot;&quot;; for (int i = 0; i &lt; args.length; i++) &#123; params += &quot; &quot; + paramNames[i] + &quot;: &quot; + args[i]; &#125; sysLog.setParams(params); &#125; // 获取request HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); // 设置IP地址 sysLog.setIp(IPUtils.getIpAddr(request)); // 模拟一个用户名 sysLog.setUsername(&quot;mrbird&quot;); sysLog.setTime((int) time); sysLog.setCreateTime(new Date()); // 保存系统日志 sysLogDao.saveSysLog(sysLog); &#125;&#125;public class IPUtils &#123; /** * 获取IP地址 * * 使用Nginx等反向代理软件， 则不能通过request.getRemoteAddr()获取IP地址 如果使用了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP地址，X-Forwarded-For中第一个非unknown的有效IP字符串，则为真实IP地址 */ public static String getIpAddr(HttpServletRequest request) &#123; String ip = request.getHeader(&quot;x-forwarded-for&quot;); if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123; ip = request.getHeader(&quot;Proxy-Client-IP&quot;); &#125; if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123; ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;); &#125; if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123; ip = request.getRemoteAddr(); &#125; return &quot;0:0:0:0:0:0:0:1&quot;.equals(ip) ? &quot;127.0.0.1&quot; : ip; &#125;&#125;Controller 方法123456789101112131415161718@RestControllerpublic class TestController &#123; @Log(&quot;执行方法一&quot;) @GetMapping(&quot;/one&quot;) public void methodOne(String name) &#123; &#125; @Log(&quot;执行方法二&quot;) @GetMapping(&quot;/two&quot;) public void methodTwo() throws InterruptedException &#123; Thread.sleep(2000); &#125; @Log(&quot;执行方法三&quot;) @GetMapping(&quot;/three&quot;) public void methodThree(String name, String age) &#123; &#125;&#125;测试12345678910111213http://localhost:8080/web/one?name=KangKanghttp://localhost:8080/web/twohttp://localhost:8080/web/three?name=Mike&amp;age=25&gt; select * from sys_log order by id;ID USERNAME OPERATION TIME METHOD PARAMS IP CREATE_TIME1 mrbird 执行方法一 3 com.example.demo.web.TestController.methodOne() name: KangKang 127.0.0.1 2019-08-102 mrbird 执行方法二 2002 com.example.demo.web.TestController.methodTwo() 127.0.0.1 2019-08-103 mrbird 执行方法三 0 com.example.demo.web.TestController.methodThree() name: Mike age: 25 127.0.0.1 2019-08-104 mrbird 执行方法三 0 com.example.demo.web.TestController.methodThree() name: Mike age: 25 127.0.0.1 2019-08-105 mrbird 执行方法二 2001 com.example.demo.web.TestController.methodTwo() 127.0.0.1 2019-08-10总结切面对项目响应时间的影响待测试，现在用的项目基本没有应用到切面，等有实际落地需求在改进学习下源码","categories":[{"name":"Spring学习","slug":"Spring学习","permalink":"http://suiyia.github.io/categories/Spring学习/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://suiyia.github.io/tags/Springboot/"},{"name":"AOP","slug":"AOP","permalink":"http://suiyia.github.io/tags/AOP/"}]},{"title":"Springboot 使用 MyBatis 实现增删改查","slug":"Springboot-使用-MyBatis-实现增删改查","date":"2019-08-10T09:39:00.000Z","updated":"2019-08-10T09:51:13.110Z","comments":true,"path":"2019/08/10/Springboot-使用-MyBatis-实现增删改查/","link":"","permalink":"http://suiyia.github.io/2019/08/10/Springboot-使用-MyBatis-实现增删改查/","excerpt":"","text":"内容Springboot 项目结合 Mybatis 实现 CRUD 增删改查基本 Mysql 脚本123456789CREATE TABLE student ( sno VARCHAR(10) NOT NULL , sname VARCHAR(10) NOT NULL , ssex VARCHAR(2) NOT NULL );INSERT INTO STUDENT VALUES (&apos;001&apos;, &apos;KangKang&apos;, &apos;M &apos;);INSERT INTO STUDENT VALUES (&apos;002&apos;, &apos;Mike&apos;, &apos;M &apos;);INSERT INTO STUDEN VALUES (&apos;003&apos;, &apos;Jane&apos;, &apos;F &apos;);pom 基本包依赖1234567891011121314151617181920212223&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;配置文件 application.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869server: servlet: context-path: /web port: 8080spring: datasource: druid: # 数据库访问配置, 使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useunicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: 123456 # 连接池配置 initial-size: 5 min-idle: 5 max-active: 20 # 连接等待超时时间 max-wait: 30000 # 配置检测可以关闭的空闲连接间隔时间 time-between-eviction-runs-millis: 60000 # 配置连接在池中的最小生存时间 min-evictable-idle-time-millis: 300000 validation-query: select &apos;1&apos; from dual test-while-idle: true test-on-borrow: false test-on-return: false # 打开PSCache，并且指定每个连接上PSCache的大小 pool-prepared-statements: true max-open-prepared-statements: 20 max-pool-prepared-statement-per-connection-size: 20 # 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, &apos;wall&apos;用于防火墙 filters: stat,wall # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔 aop-patterns: com.springboot.servie.* # WebStatFilter配置 web-stat-filter: enabled: true # 添加过滤规则 url-pattern: /* # 忽略过滤的格式 exclusions: &apos;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&apos; # StatViewServlet配置 stat-view-servlet: enabled: true # 访问路径为/druid时，跳转到StatViewServlet url-pattern: /druid/* # 是否能够重置数据 reset-enable: false # 需要账号密码才能访问控制台 login-username: druid login-password: druid123 # IP白名单 # allow: 127.0.0.1 # IP黑名单（共同存在时，deny优先于allow） # deny: 192.168.1.218 # 配置StatFilter filter: stat: log-slow-sql: truemybatis: mapper-locations: classpath:mapper/*.xml configuration-properties: BEFORE代码实现接口+注解形式实现数据库读取写入1234567891011121314151617181920@Mapperpublic interface StudentManagerWithInject &#123; @Insert(&quot;insert into student(sno,sname,ssex)values(#&#123;sno&#125;,#&#123;name&#125;,#&#123;ssex&#125;)&quot;) int add(Student student); @Update(&quot;update student set sname=#&#123;name&#125;,ssex=#&#123;sex&#125; where sno=#&#123;sno&#125;&quot;) int update(Student student); @Delete(&quot;delete from student where sno=#&#123;sno&#125;&quot;) int deleteBySno(String sno); @Select(&quot;select * from student where sno=#&#123;sno&#125;&quot;) @Results(id = &quot;student&quot;,value= &#123; @Result(property = &quot;sno&quot;, column = &quot;sno&quot;, javaType = String.class), @Result(property = &quot;name&quot;, column = &quot;sname&quot;, javaType = String.class), @Result(property = &quot;sex&quot;, column = &quot;ssex&quot;, javaType = String.class) &#125;) Student queryStudentBySno(String sno);&#125;自动装配实现业务逻辑12345678910111213141516171819202122@RestControllerpublic class TestController &#123; @Autowired private StudentManagerWithInject studentManagerWithInject; @Autowired private StudentMapperWithXML studentMapperWithXML; @RequestMapping(value = &quot;/querystudent&quot;,method = RequestMethod.GET) public Student queryStudentBySno( @RequestParam String sno)&#123; return studentManagerWithInject.queryStudentBySno(sno); &#125; @RequestMapping(value = &quot;/querystudentwithxml&quot;,method = RequestMethod.GET) public Student queryStudentWithXMLBySno( @RequestParam String sno)&#123; return studentMapperWithXML.queryStudentBySno(sno); &#125;&#125;调用接口，得到结果12345678http://localhost:8080/web/querystudent?sno=001输出&#123; &quot;sno&quot;: &quot;001&quot;, &quot;name&quot;: &quot;KangKang&quot;, &quot;sex&quot;: &quot;M &quot;&#125;最后一般项目会增加一个 service 服务层，一个服务可能对应多个数据库操作，这里节省时间就没有加，工作中还是根据项目规范来。学习参考源码第一章节","categories":[{"name":"Spring学习","slug":"Spring学习","permalink":"http://suiyia.github.io/categories/Spring学习/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://suiyia.github.io/tags/Springboot/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://suiyia.github.io/tags/MyBatis/"}]},{"title":"HashMap、HashTable、ConcurrentHashMap 区别","slug":"HashMap、HashTable、ConcurrentHashMap-区别","date":"2019-04-07T06:24:00.000Z","updated":"2019-04-07T13:38:48.975Z","comments":true,"path":"2019/04/07/HashMap、HashTable、ConcurrentHashMap-区别/","link":"","permalink":"http://suiyia.github.io/2019/04/07/HashMap、HashTable、ConcurrentHashMap-区别/","excerpt":"","text":"简单总结 HashMap、Hashtable、ConcurrentHashMap 之间的区别，基于 JDK 1.8.0_191先说结论，暂时有以下几个需要注意的不同点：继承、实现接口不同初始大小、扩容倍数不同线程安全NULL KEY，NULL VALUE 支持不同计算 Hash 值的方式不同1. 继承、实现接口不同12345678public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125; public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;, Serializable &#123;HashMap、ConcurrentHashMap 都继承于 AbstractMap 抽象类，但 Hashtable 继承于 Dictionary 抽象类。AbstractMap 实现了 Map 接口，而 Dictionary 没有。这使得 AbstractMap 具有更多的功能，而 Dictionary 逐渐被弃用。2. 初始大小、扩容倍数不同HashMap1234static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16扩容部分代码：newThr = oldThr &lt;&lt; 1; // double thresholdHashtable123456public Hashtable() &#123; this(11, 0.75f);&#125;扩容部分代码：int newCapacity = (oldCapacity &lt;&lt; 1) + 1;ConcurrentHashMap12345/** * The default initial table capacity. Must be a power of 2 * (i.e., at least 1) and at most MAXIMUM_CAPACITY. */private static final int DEFAULT_CAPACITY = 16;初始大小：HashMap、ConcurrentHashMap 都是 16，Hashtable 是 11扩容倍数：HashMap、ConcurrentHashMap 2 倍、Hashtable (2n + 1) 倍。3. 线程安全12345Hashtable:public synchronized V put(K key, V value) &#123;&#125;HashMap:public V put(K key, V value) &#123;&#125;Hashtable 添加元素方法加上了 synchronized 关键字，HashMap 没有，说明 HashMap 不适用于多线程环境。ConcurrentHashMap 添加元素时，只对需要变更的地方加锁。4. NULL KEY，NULL VALUE 支持不同通过观察它们的 put 方法，得到以下结论：Hashtable、ConcurrentHashMap 的 key、value 都不能为 null。HashMap value 可以为 null，而 key 为 null 时，该元素会放在 HashMap 第一位。5. key 的索引计算方法不同计算元素存放位置，会经过两步转化。Object -&gt; int -&gt; index，先将 key 使用 hash 方法转换为一个整数数字，然后对整型数字进行转化，得到这个对象在 map 中的索引。Hashtable12int hash = key.hashCode();int index = (hash &amp; 0x7FFFFFFF) % tab.length;HashMap1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;Hashtable 直接使用对象的 hashCode，然后再使用除留余数法来获得最终的位置。HashMap 在对象的 hashCode 之上，将 hashCode 的高16位和低16位进行异或，得到最终的位置。总结后面学习将对 HashMap，ConcurrentHashMap 源码进行分析总结。ConcurrentHashMap的扩容机制（jdk1.8）HashMap 和Hashtable的区别","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://suiyia.github.io/categories/Java基础/"}],"tags":[{"name":"集合","slug":"集合","permalink":"http://suiyia.github.io/tags/集合/"}]},{"title":"ArraryList、LinkList和Vector的区别","slug":"ArraryList、LinkList和Vector的区别","date":"2019-03-24T05:53:00.000Z","updated":"2019-04-07T13:32:54.477Z","comments":true,"path":"2019/03/24/ArraryList、LinkList和Vector的区别/","link":"","permalink":"http://suiyia.github.io/2019/03/24/ArraryList、LinkList和Vector的区别/","excerpt":"","text":"本文基于 JDK 1.8.0_1911. 源码对比实现接口类对比扩容机制对比线程安全1.1 实现接口类对比12345678910public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable它们都实现 List 接口，说明具备列表的增加、删除、遍历元素等特性。ArrayList、Vector 额外实现 RandomAccess 接口，说明他们能在常量时间复杂度内快速随机访问元素。LinkedList 额外实现 Queue 接口，具备队列的入队、出队等特性。1.2 扩容机制对比ArrayList123456789101112131415private static final int DEFAULT_CAPACITY = 10; // 定义初始大小private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 定义列表存储元素数量最大值 private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 现有元素数量 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 增加后元素的数量 = 1 + 0.5 if (newCapacity - minCapacity &lt; 0) // 增加后的元素数量 &lt; 现有的空间，不扩容 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 增加后的元素数量 &gt; 大于最大值，尝试分配 Integer.MAX_VALUE 个元素，可能会抛出 OutOfMemoryError // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;Vector12345678910111213141516public Vector() &#123; this(10);&#125;protected int capacityIncrement; // 扩容数量值，Vector 初始化不指定时默认为 0private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); // 当扩容数量值小于 0，那么扩容比例为原来的两倍；否则扩容的数量为这个值。 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125;LinkList1transient int size = 0;初始大小：ArrayList、Vector 默认为 10，LinkList 不指定默认为 0扩容比例：ArrayList 以 1.5 倍进行扩容；Vector 不指定扩容比例时默认为 2 倍进行扩容1.3 线程安全性ArrayList1234567protected transient int modCount = 0;public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;Vector1234567protected transient int modCount = 0;public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125;Vector add() 方法上增加了 synchronized 关键字，使得 Vector 支持多线程环境下的元素增加删除修改操作。2. 增删改性能对比根据数据结构中知识:顺序表查找元素时间复杂度为 O(1)，适用于随机查找元素的场景。链表增减元素时间复杂度为 O(1)，适用于增减元素比较多的场景。1234567891011121314151617181920212223242526272829303132public static void main(String[] args) &#123; ArrayList arrayList = new ArrayList(); LinkedList linkedList = new LinkedList(); Vector vector = new Vector(); long t1, t2; t1 = System.nanoTime(); for (int i = 0; i &lt; 10000; i++) &#123; arrayList.add(i); &#125; t2 = System.nanoTime(); System.out.println(&quot;ArrayList add:&quot; + (t2 - t1)); t1 = System.nanoTime(); for (int i = 0; i &lt; 10000; i++) &#123; linkedList.add(i); &#125; t2 = System.nanoTime(); System.out.println(&quot;linkedList add:&quot; + (t2 - t1)); t1 = System.nanoTime(); for (int i = 0; i &lt; 10000; i++) &#123; vector.add(i); &#125; t2 = System.nanoTime(); System.out.println(&quot;vector add:&quot; + (t2 - t1));&#125; ArrayList add:6810212linkedList add:3463194vector add:4442985添加元素，ArrayList 花费时间比 LinkList 时间长。1234567891011121314151617181920212223242526272829303132333435363738public static void main(String[] args) &#123; ArrayList arrayList = new ArrayList(); LinkedList linkedList = new LinkedList(); Vector vector = new Vector(); long t1, t2; for (int i = 0; i &lt; 100000; i++) &#123; arrayList.add(i); linkedList.add(i); vector.add(i); &#125; t1 = System.nanoTime(); for (int i = 0; i &lt; 10000; i++) &#123; arrayList.get(i); &#125; t2 = System.nanoTime(); System.out.println(&quot;ArrayList get:&quot; + (t2 - t1)); t1 = System.nanoTime(); for (int i = 0; i &lt; 10000; i++) &#123; linkedList.get(i); &#125; t2 = System.nanoTime(); System.out.println(&quot;linkedList get:&quot; + (t2 - t1)); t1 = System.nanoTime(); for (int i = 0; i &lt; 10000; i++) &#123; vector.get(i); &#125; t2 = System.nanoTime(); System.out.println(&quot;vector get:&quot; + (t2 - t1));&#125; ArrayList get:72482linkedList get:107975370vector get:242634查找元素上，ArrayList 最快3. 总结将 ArrayList、LinkList 和 Vetor 进行了简单对比，总体来说：在查找元素比较频繁的场合，推荐使用 ArrayList；在修改元素比较频繁的场合，推荐使用 LinkList。Vetor 与 ArrayList 类似，区别在于扩容比例、线程安全方面。性能对比测试结果可能存在添加元素 ArrayList 花费时间比 LinkList 多的情况， 这个原因参考：ArrayList vs LinkedList vs Vector 区别","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://suiyia.github.io/categories/Java基础/"}],"tags":[{"name":"集合","slug":"集合","permalink":"http://suiyia.github.io/tags/集合/"}]},{"title":"Java字符串拼接效率对比","slug":"Java-字符串拼接效率对比","date":"2019-03-17T07:30:00.000Z","updated":"2019-04-07T13:32:54.526Z","comments":true,"path":"2019/03/17/Java-字符串拼接效率对比/","link":"","permalink":"http://suiyia.github.io/2019/03/17/Java-字符串拼接效率对比/","excerpt":"","text":"用 Google photo 搜索关键词「String」，出现了上图，有兴趣的朋友可以试试，感觉发现了新大陆…Java 中有 3 种字符串的拼接方式，了解这三种拼接方式的实现，将有益于提高自己的代码质量。本文主要讲解 String 对象的三种拼接方式，以及它们之间的效率对比。三种方式1234567891011// 方式 1String s = &quot;Hello&quot;;s += &quot;Hello&quot;;// 方式 2StringBuilder stringBuilder = new StringBuilder(&quot;Hello&quot;);stringBuilder.append(&quot;Hello&quot;);// 方式 3StringBuffer stringBuffer = new StringBuffer(&quot;Hello&quot;);stringBuffer.append(&quot;Hello&quot;);自己写个主函数，将上面 3 个方法循环执行 10000 次；执行时间 t1 &gt; t3 &gt; t2，也就是说 StringBuilder.append() 拼接最快，String += 最慢。源码解读StringBuilder.append() 拼接StringBuilder.java123456789public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence@Overridepublic StringBuilder append(String str) &#123; super.append(str); // 调用父类 append 方法 return this;&#125;AbstractStringBuilder.java123456789public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); // 调用 String 的 getChars 方法 count += len; return this;&#125;String.java123456789101112public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123; if (srcBegin &lt; 0) &#123; throw new StringIndexOutOfBoundsException(srcBegin); &#125; if (srcEnd &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(srcEnd); &#125; if (srcBegin &gt; srcEnd) &#123; throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); &#125; System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin); // 本地方法&#125;从上面 3 段代码可知，StringBuilder.append 方法调用的是父类 AbstractStringBuilder.append，父类 append 方法调用了 String 的本地方法 System.arraycopy 实现StringBuffer.append() 拼接StringBuilder.java12345678910public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence@Overridepublic synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125;StringBuffer.append 方法与 StringBuilder.append 方法类似，不同的是，append 方法加上了 synchronized 锁，说明该方法适用于多线程环境，但是加锁的过程需要耗时，所以执行时间比 StringBuilder.append 慢。String += 拼接对下面代码进行编译，生成的 class 文件使用命令 javap -c Main.class，可以反编译得到图片中的字节码。可以看到 += 实际调用的是 StringBuilder.append() 方法，所以速度会比 StringBuilder 慢。12345public static void main(String[] args) &#123; String s = &quot;Hello&quot;; s = s + &quot; World&quot;; System.out.println(s);&#125;总结所以在需要拼接字符串的场合，尽量适用 StringBuilder.append() 方法，多线程环境下则推荐 StringBuffer.append() 方法，而 String += 拼接方式任何场合都不建议使用。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://suiyia.github.io/categories/Java基础/"}],"tags":[{"name":"String","slug":"String","permalink":"http://suiyia.github.io/tags/String/"}]},{"title":"Java中的值传递","slug":"Java-中的值传递","date":"2019-02-18T15:12:00.000Z","updated":"2019-04-07T13:32:54.490Z","comments":true,"path":"2019/02/18/Java-中的值传递/","link":"","permalink":"http://suiyia.github.io/2019/02/18/Java-中的值传递/","excerpt":"","text":"几个重要概念实参、形参形式参数：定义函数名和函数体时候使用的参数，目的用来接收调用该函数时传入的参数实际参数：在调用有参函数时，主调函数与被调函数之间有数据传递关系。实际参数是调用有参方法的时候真正传递的内容。12345678 public void tes(String name)&#123; // 形式参数 name System.out.println(name);&#125;public static void main(String[] args) &#123; Test test = new Test(); test.tes(&quot;caijicoder&quot;); // 实际参数 caijicoder&#125;值类型、引用类型：值类型就是基本数据类型，8 种基本类型除外的数据类型都是引用类型。两种类型分别表示两种内存分配方式。一个值类型数据直接在栈上分配，存储所包含的值，其值就代表数据本身。一个引用类型指向的数据在堆上分配，引用类型的值是这个堆上数据的地址。12int num = 10;String str = &quot;hello&quot;;num 是基本类型（值类型），值就直接保存在变量中。str 是引用类型，变量中保存的只是实际对象的地址（0x10），而不是 Hello 这个字符串。值传递、引用传递：值传递（pass by value）：指在调用函数时，将实参复制一份传递到函数中，形参接收到的内容其实是实参的一个拷贝，函数对形参的修改并不会影响到实参引用传递（pass by reference）：指在调用函数时，将实参的地址直接传递到函数中，在函数中对参数的修改将会影响到实参值传递和引用传递属于函数调用时参数的求值策略（Evaluation Strategy），这是对调用函数时，求值和传值的方式的描述，并不指传递的内容的类型。也就是说，传递内容的类型是值类型还是引用类型（地址），与值传递、引用传递无关，并不能说传入的参数类型是值类型就是值传递。接下来重点！！！对于值传递，无论是值类型还是引用类型，都会在调用栈上创建一个副本：对于值类型而言，这个副本就是整个原始值的复制，对这个副本的操作，不影响原始值的内容。对于引用类型而言，其副本也只是这个引用的复制，指向的仍然是同一个对象。所以对副本的操作，会影响原始值。为什么 Java 只有值传递，但 C# 既有值传递，又有引用传递，这种语言设计有哪些好处？ - Hugo Gu的回答 - 知乎一个实例定义 Person 类123456789101112131415161718192021222324252627282930313233public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, age=&quot; + age + &apos;&#125;&apos;; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940public class Main &#123; private int X = 123; public void updateVlue(int value)&#123; // 传入基本数据类型 value = value + 1; System.out.println(&quot;变量value: &quot;+value); &#125; public void updateObject(Person person)&#123; // 传入引用类型 Person E = person; E.setAge(21); &#125; public void swapObject(Person A,Person B)&#123; // 传入引用类型 Person C = A; A = B; B = C; &#125; public static void main(String[] args) &#123; // 例子 1 Main main = new Main(); int X = 1; main.updateVlue(X); System.out.println(&quot;X 的值：&quot;+X); // X = 1 // 例子 2 Person A = new Person(&quot;张三&quot;,20); main.updateObject(A); System.out.println(&quot;A: &quot;+A.toString()); // A: Person&#123;name=&apos;张三&apos;, age=21&#125; // 例子 3 Person C = new Person(&quot;C&quot;,10); Person D = new Person(&quot;D&quot;,15); main.swapObject(C,D); System.out.println(&quot;C: &quot;+ C.toString()); // C: Person&#123;name=&apos;C&apos;, age=10&#125; System.out.println(&quot;D: &quot;+ D.toString()); // D: Person&#123;name=&apos;D&apos;, age=15&#125; &#125;&#125;例子1：函数传入基本数据类型（值类型参数），由于 value 是 X 的一个副本，对 value 进行操作，并没有改变原来实参的值。例子2：函数传入引用类型参数，改变了原来的值。由于值传递的缘故，传入引用类型的参数时，其值是这个地址的拷贝，指向的仍然是同一个对象，所以发生了改变。这是值传递带来的效果，与传入的对象是值类型或者引用类型没有关系！例子3：函数传入引用类型，如果 Java 是引用传递， 那么 swapObject(Person A,Person B) 中的形参 A，B 接收的就是 C 和 D 的地址，对 A，B 进行交换应该能成功的，事实上 C 和 D 并没有交换，这从反面证明了 Java 不是引用传递。参考Java 到底是值传递还是引用传递？ - Hollis的回答 - 知乎这一次，彻底解决Java的值传递和引用传递","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://suiyia.github.io/categories/Java基础/"}],"tags":[]},{"title":"Redis 简单介绍与 Jedis 常用操作","slug":"Redis简单介绍与Jedis常用操作","date":"2019-02-18T13:02:00.000Z","updated":"2019-08-10T09:51:13.097Z","comments":true,"path":"2019/02/18/Redis简单介绍与Jedis常用操作/","link":"","permalink":"http://suiyia.github.io/2019/02/18/Redis简单介绍与Jedis常用操作/","excerpt":"","text":"介绍Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。主要对 Redis 中文网 文档内容进行总结，并使用 Jedis 实现一些基本操作。使用 Jedis 实现 Redis 基本操作Jedis 是一个小而精的 Redis 客户端，用 Java 实现strings 操作123456789String result = jedis.set(\"name\",\"chx\"); // 添加 String ，result = \"OK\"result = jedis.mset(\"name\", \"chenhaoxiang\", \"age\", \"20\", \"email\", \"chxpostbox@outlook.com\"); // 同时设置多个键值对 result = \"OK\"Boolean exists = jedis.exists(\"name\"); // 是否存在 key=user 的记录result = jedis.get(\"name\"); // 获取数据，result = \"chx\"Long appendres = jedis.append(\"name\", \" is my name;\"); // 拼接，appendres = 15，拼接后字符串长度Long delres = jedis.del(\"name\"); //删除某个键值对， delres = 1//键对应 value 的自增操作，具备原子性，如果键包含错误类型的值或包含无法表示为整数的字符串，则会返回错误。此操作限于64位有符号整数。ERR value is not an integer or out of range//如果键不存在，则在执行操作之前将其设置为0。如果 age 不存在，操作后 age = 1；Long incrres = jedis.incr(\"age\"); // 用于将键的整数值递增1。 incrres = 21，递增后的值。lists 操作123456Long res1 = jedis.lpush(\"list\",\"1\"); // 头部插入一个元素，res1 = 1res1 = jedis.lpush(\"list\",\"2\"); // res1 = 2res1 = jedis.lpush(\"list\",\"3\"); // res1 = 3 返回该 List 的长度jedis.rpush(\"list\",\"5\"); // 尾部插入元素Long llen = jedis.llen(\"list\"); // List 长度，llen = 4List&lt;String&gt; list3 = jedis.lrange(\"list\",0,-1); // list3 = [3,2,1,5] 按范围取出,第一个是key，第二个是起始位置，第三个是结束位置sets 操作123456789res1 = jedis.sadd(\"set\",\"1\");res1 = jedis.sadd(\"set\",\"2\");res1 = jedis.sadd(\"set\",\"3\"); // 添加Long srem = jedis.srem(\"set\",\"2\"); // 移除某个元素Set&lt;String&gt; set1 = jedis.smembers(\"set\"); // 获取 key=set 的 SetBoolean sismember = jedis.sismember(\"set\",\"1\"); // key=set 的 Set 中是否存在元素 \"1\"String srandmember = jedis.srandmember(\"set\"); // 随机返回一个 set 元素List&lt;String&gt; list4 = jedis.srandmember(\"set\",2); // 随机返回指定个数个元素Long scar = jedis.scard(\"set\"); // set 的元素个数sorted sets 操作( TODO 用到再更新)123jedis.zadd(\"zset\",1,\"1\");jedis.zadd(\"zset\",2.0,\"2\");jedis.zadd(\"zset\",3,\"3\");Hashes 操作12345678910111213141516Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();map.put(\"name\", \"chx\");map.put(\"age\", \"100\");map.put(\"email\", \"***@outlook.com\");result = jedis.hmset(\"user\", map); // 添加 Map，result = \"OK\"String res = jedis.hget(\"user\",\"age\"); // 获取 Map 指定 key 的 value，只能获取单个 key，res = 100List&lt;String&gt; list = jedis.hmget(\"user\", \"name\", \"age\", \"email\"); // 获取 Map 指定 key 的 value，同时指定多个 key，list = [chx, 100, ***@outlook.com];Long hdel = jedis.hdel(\"user\", \"age\"); //删除 map 中的某个键值，hdel = 1Long hlen = jedis.hlen(\"user\"); // 获取 map 中的键值对个数，hlen = 2Set&lt;String&gt; set = jedis.hkeys(\"user\"); // 返回 map 中的所有 keyIterator&lt;String&gt; iterator = jedis.hkeys(\"user\").iterator(); // 迭代遍历while (iterator.hasNext())&#123; String key = iterator.next(); String value = jedis.hmget(\"user\",key).get(0);&#125;List&lt;String&gt; list2 = jedis.hvals(\"user\"); // 返回 map 中的所有 valueRedis 其它名词expire 过期Redis 允许为每一个 key 设置不同的过期时间，当它们到期时将自动从服务器上删除。主动删除：client 主动访问，发现过期，立即删除被动删除：Redis 定时随机选择一些 key 进行检测，删除过期的 key，如果删除比例高于 25%，则继续选择一些 key 进行删除管道(Pipelining)Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。发送一个命令之后只有等待服务器返回之后才会执行后续命令。管道则可以一次发送多条命令而不必立即等待服务器返回，收到命令之后，服务器会以队列形式回复命令，管道操作比较耗内存，要注意命令的大小。12345Pipeline pipeline = jedis.pipelined();for (int i = 0; i &lt; 100; i++) &#123; pipeline.set(\"1\",\"1\");&#125;pipeline.sync();Redis学习笔记7–Redis管道（pipeline）分布式缓存Redis之Pipeline（管道）事务将一组 Redis 命令放到事务中执行，MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。123456String watch = jedis.watch(\"123\");Transaction multi = jedis.multi();multi.set(\"123\",\"123\");List&lt;Object&gt; list1 = multi.exec();multi.discard();jedis.unwatch();multi 用于开启一个事务，exec 执行事务，watch 用于监测事务中 key 的变化，如果 key 被其它客户端改过了，那么整个事务会被取消，discard 用于取消事务总结这个总结主要是了解下 Jedis 常用操作。具体细节学习需要文档、项目结合学习。博客参考：【Redis】Java中使用Jedis操作Redis(Maven导入包)、创建Redis连接池","categories":[{"name":"Redis","slug":"Redis","permalink":"http://suiyia.github.io/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://suiyia.github.io/tags/Redis/"}]},{"title":"Java 常用加密算法实现","slug":"Java-常用加密算法实现","date":"2019-01-27T09:23:00.000Z","updated":"2019-08-10T02:01:15.013Z","comments":true,"path":"2019/01/27/Java-常用加密算法实现/","link":"","permalink":"http://suiyia.github.io/2019/01/27/Java-常用加密算法实现/","excerpt":"","text":"[toc]常用加密算法 Java 实现算法种类单向加密对称加密非对称加密1. 单向加密Base64，Base64 编码是从二进制到字符的过程，用 64 个字符来表示任意的二进制数据，常用于在 HTTP 加密，图片编码传输等。Java 8 内置实现1234567891011121314151617181920package com.cn.singleway;import java.io.UnsupportedEncodingException;import java.util.Base64;public class Base64Demo &#123; public static void main(String[] args) &#123; try &#123; // 编码 String encode = Base64.getEncoder().encodeToString(\"testBase64\".getBytes(\"UTF-8\")); System.out.println(encode); // 解码 byte[] decode = Base64.getDecoder().decode(\"dGVzdEJhc2U2NA==\"); System.out.println(new String(decode, \"UTF-8\")); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125;&#125;JDK 1.8 之下，引入第三方 jar 包1234567891011121314151617181920212223242526package com.cn.singleway;import org.apache.commons.codec.binary.Base64;import java.io.UnsupportedEncodingException;public class Base64Demo2 &#123; public static void main(String[] args) &#123; try &#123; String encodeBase64String = Base64.encodeBase64String(\"test\".getBytes(\"UTF-8\")); System.out.println(encodeBase64String); byte[] decodeString = Base64.decodeBase64(encodeBase64String); System.out.println(new String(decodeString,\"UTF-8\")); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125;&#125; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.11&lt;/version&gt; &lt;/dependency&gt;MD5，Message Digest algorithm 5，信息摘要算法，一般用于确保信息的传输完整一致性，校验传输的数据是否被修改，一旦原始信息被修改，生成的 MD5 值将会变得很不同1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.cn.singleway;import java.io.UnsupportedEncodingException;import java.math.BigInteger;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MD5Demo &#123; public static void test1(String s)&#123; try &#123; MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\"); byte[] after = messageDigest.digest(s.getBytes(\"UTF-8\")); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; after.length; i++) &#123; if ((0xff &amp; after[i]) &lt; 0x10) &#123; stringBuilder.append(\"0\" + Integer.toHexString((0xFF &amp; after[i]))); &#125; else &#123; stringBuilder.append(Integer.toHexString(0xFF &amp; after[i])); &#125; &#125; System.out.println(stringBuilder.toString()); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; public static void test2(String s)&#123; try &#123; // 生成一个MD5加密计算摘要 MessageDigest md = MessageDigest.getInstance(\"MD5\"); // 计算md5函数 md.update(s.getBytes()); // digest()最后确定返回md5 hash值，返回值为8为字符串。因为md5 hash值是16位的hex值，实际上就是8位的字符 // BigInteger函数则将8位的字符串转换成16位hex值，用字符串来表示；得到字符串形式的hash值 System.out.println(new BigInteger(1, md.digest()).toString(16)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; String s = \"this is MD5 test demo\"; test1(s); test2(s); &#125;&#125;SHA 家族，是一个密码散列函数家族，是 FIPS 所认证的安全散列算法，和 MD5 类似，都是对文本进行散列，产生一定长度的散列值SHA1 与 SHA212HMACHash Message Authentication Code，散列消息鉴别码，HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。122. 对称加密对称加密的意思就是信息收发都有相同的一把钥匙，消息的加密解密都用这进行DES，Data Encryption Standard，数据加密标准，速度较快，适用于加密大量数据的场合。DES算法提供CBC, OFB, CFB, ECB四种模式，MAC是基于ECB实现的。AESAdvanced Encryption Standard，高级加密标准，是下一代的加密算法标准，速度快，安全级别高；3. 非对称加密非对称加密算法是一种密钥的保密方法。 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。RSA，名称来源于发明这个算法的三个人的姓氏组成，算法大致内容就是对极大整数进行因式分解。这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长 RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.htmlDSA，Digital Signature Algorithm，数字签名算法，是一种标准的 DSS（数字签名标准）；ECC，Elliptic Curves Cryptography，椭圆曲线密码编码学。一种建立公开密钥加密的算法，基于椭圆曲线数学。ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。ECC的另一个优势是可以定义群之间的双线性映射，基于Weil对或是Tate对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。不过一个缺点是加密和解密操作的实现比其他机制花费的时间长。Base64MD5 和 SHA 家族12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; String content = \"you are my son\"; // 原文 try &#123; byte[] a; MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-1\"); a = messageDigest.digest(content.getBytes()); System.out.println(byte2hex(a)); // 333a9634d8809b5a9e8d280d82553b8fd8d4a911 messageDigest = MessageDigest.getInstance(\"SHA-256\"); a = messageDigest.digest(content.getBytes()); System.out.println(byte2hex(a)); // cdb2c97079d9a1943eea98de4201f5c4f49ecda5af2b364e1c7a5d1ae89688eb messageDigest = MessageDigest.getInstance(\"MD5\"); a = messageDigest.digest(content.getBytes()); System.out.println(byte2hex(a)); // 6fe6b9a8f8bd29f4f4f1368a0619a7ae // 第三方 MD5 算法。需要添加 jar 包 org.apache.commons.codec.digest.DigestUtils String encodeStr=DigestUtils.md5Hex(content); System.out.println(encodeStr); // 6fe6b9a8f8bd29f4f4f1368a0619a7ae &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125;&#125;public static String byte2hex(byte[] b) //二进制转字符串&#123; String hs = \"\"; String stmp = \"\"; for (int n = 0; n &lt; b.length; n++) &#123; stmp = (java.lang.Integer.toHexString(b[n] &amp; 0XFF)); if (stmp.length() == 1) &#123; hs = hs + \"0\" + stmp; &#125; else &#123; hs = hs + stmp; &#125; &#125; return hs;&#125;总结现在的加密算法大部分情况下是为了验证数据的一致性，例如传递一些参数组的时候，简单的会使用 BASE64 或 MD5 进行加密生成一个签名。复杂点就是 BASE64 编码之后再用 对称密钥再加密一次，达到比较不容易被人篡改的目的对于一些支付场景，一般使用 非对称加密算法 实现，这样的场景需要的安全性更高。其它博客参考java加解密之RSA使用","categories":[{"name":"Java 核心","slug":"Java-核心","permalink":"http://suiyia.github.io/categories/Java-核心/"}],"tags":[{"name":"加密算法","slug":"加密算法","permalink":"http://suiyia.github.io/tags/加密算法/"}]},{"title":"展望 2019 ！","slug":"展望-2019","date":"2019-01-02T14:28:00.000Z","updated":"2019-04-07T13:32:54.458Z","comments":true,"path":"2019/01/02/展望-2019/","link":"","permalink":"http://suiyia.github.io/2019/01/02/展望-2019/","excerpt":"","text":"回首 2018，毕业、入职，名校光环不再，浪潮褪去，原来我一直在裸泳。作为已经工作半年的「职场新人」，仍有许多的不足和需要学习的地方。激情是年轻人应该拥有的东西，没有梦想，和咸鱼一样，我不甘心！制定好目标，坚持的执行下去，总会有好的结果。坚持看书，每天花一个小时看书。自己思考、总结，把书中的想法总结出来，提升了思维也锻炼了写作能力。坚持写博客，从公司项目中了解框架，既熟悉了业务，也运用得了框架，这应该是头两年需要技术积累的东西。坚持锻炼，体重控制在 130 斤应该是最完美的体重，向这个目标进军，现在 140 斤。自己需要注意的地方：聆听的方式。别人与自己说话，学会聆听，学会体会别人话中表现的含义，不轻易打断别人，有时候还需要委婉地表达自己的想法。注意社交，一个人闷着屋里，并不会造出什么轮子，随时了解外面发生的事，多个周围的同事交流，结交更多的朋友，体会不同人的想法、见解，开拓自己的视野。唯一愿望：找一个可以一起吃饭、一起看电影、一起出去玩的女朋友。结语：人生就像一场马拉松，起步快的人，往往能提前看到美丽的风景，坚持久的人，必将得到丰厚的硕果，加油 2019 ！","categories":[],"tags":[]}]}