{"meta":{"title":"菜鸟日常","subtitle":null,"description":null,"author":"suiyia","url":"http://suiyia.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-12-24T14:21:24.347Z","updated":"2018-12-23T14:21:42.101Z","comments":false,"path":"/404.html","permalink":"http://suiyia.github.io//404.html","excerpt":"","text":""},{"title":"书单","date":"2018-12-23T14:21:42.107Z","updated":"2018-12-23T14:21:42.107Z","comments":false,"path":"books/index.html","permalink":"http://suiyia.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-12-23T14:21:42.109Z","updated":"2018-12-23T14:21:42.109Z","comments":false,"path":"categories/index.html","permalink":"http://suiyia.github.io/categories/index.html","excerpt":"","text":""},{"title":"callback","date":"2018-12-23T13:43:41.000Z","updated":"2018-12-23T13:43:41.903Z","comments":true,"path":"callback/index.html","permalink":"http://suiyia.github.io/callback/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-12-23T14:21:42.112Z","updated":"2018-12-23T14:21:42.112Z","comments":false,"path":"repository/index.html","permalink":"http://suiyia.github.io/repository/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-12-23T14:21:42.106Z","updated":"2018-12-23T14:21:42.106Z","comments":false,"path":"about/index.html","permalink":"http://suiyia.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2018-12-24T14:21:24.378Z","updated":"2018-12-23T14:21:42.109Z","comments":true,"path":"links/index.html","permalink":"http://suiyia.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-23T14:21:42.113Z","updated":"2018-12-23T14:21:42.113Z","comments":false,"path":"tags/index.html","permalink":"http://suiyia.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 字符串拼接效率对比","slug":"Java-字符串拼接效率对比","date":"2019-03-17T07:30:00.000Z","updated":"2019-03-17T07:43:22.112Z","comments":true,"path":"2019/03/17/Java-字符串拼接效率对比/","link":"","permalink":"http://suiyia.github.io/2019/03/17/Java-字符串拼接效率对比/","excerpt":"","text":"用 Google photo 搜索关键词「String」，出现了上图，有兴趣的朋友可以试试，感觉发现了新大陆… Java 中有 3 种字符串的拼接方式，了解这三种拼接方式的实现，将有益于提高自己的代码质量。 本文主要讲解 String 对象的三种拼接方式，以及它们之间的效率对比。 三种方式1234567891011// 方式 1String s = &quot;Hello&quot;;s += &quot;Hello&quot;;// 方式 2StringBuilder stringBuilder = new StringBuilder(&quot;Hello&quot;);stringBuilder.append(&quot;Hello&quot;);// 方式 3StringBuffer stringBuffer = new StringBuffer(&quot;Hello&quot;);stringBuffer.append(&quot;Hello&quot;); 自己写个主函数，将上面 3 个方法循环执行 10000 次； 执行时间 t1 &gt; t3 &gt; t2，也就是说 StringBuilder.append() 拼接最快，String += 最慢。 源码解读 StringBuilder.append() 拼接 StringBuilder.java123456789public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence@Overridepublic StringBuilder append(String str) &#123; super.append(str); // 调用父类 append 方法 return this;&#125; AbstractStringBuilder.java123456789public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); // 调用 String 的 getChars 方法 count += len; return this;&#125; String.java123456789101112public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123; if (srcBegin &lt; 0) &#123; throw new StringIndexOutOfBoundsException(srcBegin); &#125; if (srcEnd &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(srcEnd); &#125; if (srcBegin &gt; srcEnd) &#123; throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); &#125; System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin); // 本地方法&#125; 从上面 3 段代码可知，StringBuilder.append 方法调用的是父类 AbstractStringBuilder.append，父类 append 方法调用了 String 的本地方法 System.arraycopy 实现 StringBuffer.append() 拼接 StringBuilder.java 12345678910public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence@Overridepublic synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125; StringBuffer.append 方法与 StringBuilder.append 方法类似，不同的是，append 方法加上了 synchronized 锁，说明该方法适用于多线程环境，但是加锁的过程需要耗时，所以执行时间比 StringBuilder.append 慢。 String += 拼接 对下面代码进行编译，生成的 class 文件使用命令 javap -c Main.class，可以反编译得到图片中的字节码。 可以看到 += 实际调用的是 StringBuilder.append() 方法，所以速度会比 StringBuilder 慢。12345public static void main(String[] args) &#123; String s = &quot;Hello&quot;; s = s + &quot; World&quot;; System.out.println(s);&#125; 总结所以在需要拼接字符串的场合，尽量适用 StringBuilder.append() 方法，多线程环境下则推荐 StringBuffer.append() 方法，而 String += 拼接方式任何场合都不建议使用。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://suiyia.github.io/categories/Java基础/"}],"tags":[{"name":"String","slug":"String","permalink":"http://suiyia.github.io/tags/String/"}]},{"title":"Java 中的值传递 ","slug":"Java-中的值传递","date":"2019-02-18T15:12:00.000Z","updated":"2019-02-18T15:26:05.920Z","comments":true,"path":"2019/02/18/Java-中的值传递/","link":"","permalink":"http://suiyia.github.io/2019/02/18/Java-中的值传递/","excerpt":"","text":"几个重要概念 实参、形参 形式参数：定义函数名和函数体时候使用的参数，目的用来接收调用该函数时传入的参数 实际参数：在调用有参函数时，主调函数与被调函数之间有数据传递关系。实际参数是调用有参方法的时候真正传递的内容。 12345678 public void tes(String name)&#123; // 形式参数 name System.out.println(name);&#125;public static void main(String[] args) &#123; Test test = new Test(); test.tes(&quot;caijicoder&quot;); // 实际参数 caijicoder&#125; 值类型、引用类型： 值类型就是基本数据类型，8 种基本类型除外的数据类型都是引用类型。 两种类型分别表示两种内存分配方式。一个值类型数据直接在栈上分配，存储所包含的值，其值就代表数据本身。一个引用类型指向的数据在堆上分配，引用类型的值是这个堆上数据的地址。 12int num = 10;String str = &quot;hello&quot;; num 是基本类型（值类型），值就直接保存在变量中。str 是引用类型，变量中保存的只是实际对象的地址（0x10），而不是 Hello 这个字符串。 值传递、引用传递： 值传递（pass by value）：指在调用函数时，将实参复制一份传递到函数中，形参接收到的内容其实是实参的一个拷贝，函数对形参的修改并不会影响到实参 引用传递（pass by reference）：指在调用函数时，将实参的地址直接传递到函数中，在函数中对参数的修改将会影响到实参 值传递和引用传递属于函数调用时参数的求值策略（Evaluation Strategy），这是对调用函数时，求值和传值的方式的描述，并不指传递的内容的类型。 也就是说，传递内容的类型是值类型还是引用类型（地址），与值传递、引用传递无关，并不能说传入的参数类型是值类型就是值传递。 接下来重点！！！ 对于值传递，无论是值类型还是引用类型，都会在调用栈上创建一个副本： 对于值类型而言，这个副本就是整个原始值的复制，对这个副本的操作，不影响原始值的内容。 对于引用类型而言，其副本也只是这个引用的复制，指向的仍然是同一个对象。所以对副本的操作，会影响原始值。 为什么 Java 只有值传递，但 C# 既有值传递，又有引用传递，这种语言设计有哪些好处？ - Hugo Gu的回答 - 知乎 一个实例定义 Person 类123456789101112131415161718192021222324252627282930313233public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, age=&quot; + age + &apos;&#125;&apos;; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940public class Main &#123; private int X = 123; public void updateVlue(int value)&#123; // 传入基本数据类型 value = value + 1; System.out.println(&quot;变量value: &quot;+value); &#125; public void updateObject(Person person)&#123; // 传入引用类型 Person E = person; E.setAge(21); &#125; public void swapObject(Person A,Person B)&#123; // 传入引用类型 Person C = A; A = B; B = C; &#125; public static void main(String[] args) &#123; // 例子 1 Main main = new Main(); int X = 1; main.updateVlue(X); System.out.println(&quot;X 的值：&quot;+X); // X = 1 // 例子 2 Person A = new Person(&quot;张三&quot;,20); main.updateObject(A); System.out.println(&quot;A: &quot;+A.toString()); // A: Person&#123;name=&apos;张三&apos;, age=21&#125; // 例子 3 Person C = new Person(&quot;C&quot;,10); Person D = new Person(&quot;D&quot;,15); main.swapObject(C,D); System.out.println(&quot;C: &quot;+ C.toString()); // C: Person&#123;name=&apos;C&apos;, age=10&#125; System.out.println(&quot;D: &quot;+ D.toString()); // D: Person&#123;name=&apos;D&apos;, age=15&#125; &#125;&#125; 例子1：函数传入基本数据类型（值类型参数），由于 value 是 X 的一个副本，对 value 进行操作，并没有改变原来实参的值。 例子2：函数传入引用类型参数，改变了原来的值。由于值传递的缘故，传入引用类型的参数时，其值是这个地址的拷贝，指向的仍然是同一个对象，所以发生了改变。这是值传递带来的效果，与传入的对象是值类型或者引用类型没有关系！ 例子3：函数传入引用类型，如果 Java 是引用传递， 那么 swapObject(Person A,Person B) 中的形参 A，B 接收的就是 C 和 D 的地址，对 A，B 进行交换应该能成功的，事实上 C 和 D 并没有交换，这从反面证明了 Java 不是引用传递。 参考Java 到底是值传递还是引用传递？ - Hollis的回答 - 知乎 这一次，彻底解决Java的值传递和引用传递","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://suiyia.github.io/categories/Java基础/"}],"tags":[]},{"title":"Redis 简单介绍与 Jedis 常用操作","slug":"Redis简单介绍与Jedis常用操作","date":"2019-02-18T13:02:00.000Z","updated":"2019-02-18T13:58:14.782Z","comments":true,"path":"2019/02/18/Redis简单介绍与Jedis常用操作/","link":"","permalink":"http://suiyia.github.io/2019/02/18/Redis简单介绍与Jedis常用操作/","excerpt":"","text":"介绍 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 主要对 Redis 中文网 文档内容进行总结，并使用 Jedis 实现一些基本操作。 使用 Jedis 实现 Redis 基本操作Jedis 是一个小而精的 Redis 客户端，用 Java 实现 strings 操作 123456789String result = jedis.set(\"name\",\"chx\"); // 添加 String ，result = \"OK\"result = jedis.mset(\"name\", \"chenhaoxiang\", \"age\", \"20\", \"email\", \"chxpostbox@outlook.com\"); // 同时设置多个键值对 result = \"OK\"Boolean exists = jedis.exists(\"name\"); // 是否存在 key=user 的记录result = jedis.get(\"name\"); // 获取数据，result = \"chx\"Long appendres = jedis.append(\"name\", \" is my name;\"); // 拼接，appendres = 15，拼接后字符串长度Long delres = jedis.del(\"name\"); //删除某个键值对， delres = 1//键对应 value 的自增操作，具备原子性，如果键包含错误类型的值或包含无法表示为整数的字符串，则会返回错误。此操作限于64位有符号整数。ERR value is not an integer or out of range//如果键不存在，则在执行操作之前将其设置为0。如果 age 不存在，操作后 age = 1；Long incrres = jedis.incr(\"age\"); // 用于将键的整数值递增1。 incrres = 21，递增后的值。 lists 操作 123456Long res1 = jedis.lpush(\"list\",\"1\"); // 头部插入一个元素，res1 = 1res1 = jedis.lpush(\"list\",\"2\"); // res1 = 2res1 = jedis.lpush(\"list\",\"3\"); // res1 = 3 返回该 List 的长度jedis.rpush(\"list\",\"5\"); // 尾部插入元素Long llen = jedis.llen(\"list\"); // List 长度，llen = 4List&lt;String&gt; list3 = jedis.lrange(\"list\",0,-1); // list3 = [3,2,1,5] 按范围取出,第一个是key，第二个是起始位置，第三个是结束位置 sets 操作 123456789res1 = jedis.sadd(\"set\",\"1\");res1 = jedis.sadd(\"set\",\"2\");res1 = jedis.sadd(\"set\",\"3\"); // 添加Long srem = jedis.srem(\"set\",\"2\"); // 移除某个元素Set&lt;String&gt; set1 = jedis.smembers(\"set\"); // 获取 key=set 的 SetBoolean sismember = jedis.sismember(\"set\",\"1\"); // key=set 的 Set 中是否存在元素 \"1\"String srandmember = jedis.srandmember(\"set\"); // 随机返回一个 set 元素List&lt;String&gt; list4 = jedis.srandmember(\"set\",2); // 随机返回指定个数个元素Long scar = jedis.scard(\"set\"); // set 的元素个数 sorted sets 操作( TODO 用到再更新) 123jedis.zadd(\"zset\",1,\"1\");jedis.zadd(\"zset\",2.0,\"2\");jedis.zadd(\"zset\",3,\"3\"); Hashes 操作 12345678910111213141516Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();map.put(\"name\", \"chx\");map.put(\"age\", \"100\");map.put(\"email\", \"***@outlook.com\");result = jedis.hmset(\"user\", map); // 添加 Map，result = \"OK\"String res = jedis.hget(\"user\",\"age\"); // 获取 Map 指定 key 的 value，只能获取单个 key，res = 100List&lt;String&gt; list = jedis.hmget(\"user\", \"name\", \"age\", \"email\"); // 获取 Map 指定 key 的 value，同时指定多个 key，list = [chx, 100, ***@outlook.com];Long hdel = jedis.hdel(\"user\", \"age\"); //删除 map 中的某个键值，hdel = 1Long hlen = jedis.hlen(\"user\"); // 获取 map 中的键值对个数，hlen = 2Set&lt;String&gt; set = jedis.hkeys(\"user\"); // 返回 map 中的所有 keyIterator&lt;String&gt; iterator = jedis.hkeys(\"user\").iterator(); // 迭代遍历while (iterator.hasNext())&#123; String key = iterator.next(); String value = jedis.hmget(\"user\",key).get(0);&#125;List&lt;String&gt; list2 = jedis.hvals(\"user\"); // 返回 map 中的所有 value Redis 其它名词 expire 过期 Redis 允许为每一个 key 设置不同的过期时间，当它们到期时将自动从服务器上删除。 主动删除：client 主动访问，发现过期，立即删除 被动删除：Redis 定时随机选择一些 key 进行检测，删除过期的 key，如果删除比例高于 25%，则继续选择一些 key 进行删除 管道(Pipelining) Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。发送一个命令之后只有等待服务器返回之后才会执行后续命令。 管道则可以一次发送多条命令而不必立即等待服务器返回，收到命令之后，服务器会以队列形式回复命令，管道操作比较耗内存，要注意命令的大小。 12345Pipeline pipeline = jedis.pipelined();for (int i = 0; i &lt; 100; i++) &#123; pipeline.set(\"1\",\"1\");&#125;pipeline.sync(); Redis学习笔记7–Redis管道（pipeline） 分布式缓存Redis之Pipeline（管道） 事务 将一组 Redis 命令放到事务中执行，MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。 123456String watch = jedis.watch(\"123\");Transaction multi = jedis.multi();multi.set(\"123\",\"123\");List&lt;Object&gt; list1 = multi.exec();multi.discard();jedis.unwatch(); multi 用于开启一个事务，exec 执行事务，watch 用于监测事务中 key 的变化，如果 key 被其它客户端改过了，那么整个事务会被取消，discard 用于取消事务 总结这个总结主要是了解下 Jedis 常用操作。具体细节学习需要文档、项目结合学习。 博客参考：【Redis】Java中使用Jedis操作Redis(Maven导入包)、创建Redis连接池","categories":[{"name":"redis","slug":"redis","permalink":"http://suiyia.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://suiyia.github.io/tags/redis/"}]},{"title":"展望 2019 ！","slug":"展望-2019","date":"2019-01-02T14:28:00.000Z","updated":"2019-01-02T15:44:08.162Z","comments":true,"path":"2019/01/02/展望-2019/","link":"","permalink":"http://suiyia.github.io/2019/01/02/展望-2019/","excerpt":"","text":"回首 2018，毕业、入职，名校光环不再，浪潮褪去，原来我一直在裸泳。 作为已经工作半年的「职场新人」，仍有许多的不足和需要学习的地方。激情是年轻人应该拥有的东西，没有梦想，和咸鱼一样，我不甘心！ 制定好目标，坚持的执行下去，总会有好的结果。 坚持看书，每天花一个小时看书。自己思考、总结，把书中的想法总结出来，提升了思维也锻炼了写作能力。 坚持写博客，从公司项目中了解框架，既熟悉了业务，也运用得了框架，这应该是头两年需要技术积累的东西。 坚持锻炼，体重控制在 130 斤应该是最完美的体重，向这个目标进军，现在 140 斤。 自己需要注意的地方： 聆听的方式。别人与自己说话，学会聆听，学会体会别人话中表现的含义，不轻易打断别人，有时候还需要委婉地表达自己的想法。 注意社交，一个人闷着屋里，并不会造出什么轮子，随时了解外面发生的事，多个周围的同事交流，结交更多的朋友，体会不同人的想法、见解，开拓自己的视野。 唯一愿望： 找一个可以一起吃饭、一起看电影、一起出去玩的女朋友。 结语： 人生就像一场马拉松，起步快的人，往往能提前看到美丽的风景，坚持久的人，必将得到丰厚的硕果，加油 2019 ！","categories":[],"tags":[]}]}