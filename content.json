{"meta":{"title":"菜鸟日常","subtitle":null,"description":null,"author":"Answer","url":"http://suiyia.github.io"},"pages":[{"title":"","date":"2019-09-19T08:54:39.785Z","updated":"2019-09-19T08:54:39.785Z","comments":true,"path":"hexo-admin-ehc-images.json","permalink":"http://suiyia.github.io/hexo-admin-ehc-images.json","excerpt":"","text":"[{\"name\":\"DASHENG-900x700-1.png\",\"date\":1518959551960},{\"name\":\"DASHENG-900x700-2.png\",\"date\":1518959599098},{\"name\":\"DASHENG-900x700-3.png\",\"date\":1518959609913},{\"name\":\"DASHENG-900x700-4.png\",\"date\":1518959618105}]"},{"title":"404 Not Found：该页无法显示","date":"2018-12-24T14:21:24.347Z","updated":"2018-12-23T14:21:42.101Z","comments":false,"path":"/404.html","permalink":"http://suiyia.github.io//404.html","excerpt":"","text":""},{"title":"书单","date":"2018-12-23T14:21:42.107Z","updated":"2018-12-23T14:21:42.107Z","comments":false,"path":"books/index.html","permalink":"http://suiyia.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-12-23T14:21:42.109Z","updated":"2018-12-23T14:21:42.109Z","comments":false,"path":"categories/index.html","permalink":"http://suiyia.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-09-19T09:11:15.000Z","updated":"2019-09-19T10:33:01.855Z","comments":true,"path":"about/index.html","permalink":"http://suiyia.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"callback","date":"2018-12-23T13:43:41.000Z","updated":"2018-12-23T13:43:41.903Z","comments":true,"path":"callback/index.html","permalink":"http://suiyia.github.io/callback/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-12-24T14:21:24.378Z","updated":"2018-12-23T14:21:42.109Z","comments":true,"path":"links/index.html","permalink":"http://suiyia.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-12-23T14:21:42.112Z","updated":"2018-12-23T14:21:42.112Z","comments":false,"path":"repository/index.html","permalink":"http://suiyia.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-23T14:21:42.113Z","updated":"2018-12-23T14:21:42.113Z","comments":false,"path":"tags/index.html","permalink":"http://suiyia.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"剑指offer题解 | 矩形覆盖","slug":"剑指offer题解-矩形覆盖","date":"2019-09-23T14:49:00.000Z","updated":"2019-09-23T14:57:02.886Z","comments":true,"path":"2019/09/23/剑指offer题解-矩形覆盖/","link":"","permalink":"http://suiyia.github.io/2019/09/23/剑指offer题解-矩形覆盖/","excerpt":"","text":"题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？解题想法实质是斐波拉契数列代码实现12345678// 递归版本 public int RectCover(int target) &#123; if (n == 1) return 1; if (n == 2) return 2; return RectCover(n - 1) + RectCover(n - 2) * 2; &#125;注意点","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 变态跳台阶","slug":"剑指offer题解-变态跳台阶","date":"2019-09-23T13:52:00.000Z","updated":"2019-09-23T14:49:00.226Z","comments":true,"path":"2019/09/23/剑指offer题解-变态跳台阶/","link":"","permalink":"http://suiyia.github.io/2019/09/23/剑指offer题解-变态跳台阶/","excerpt":"","text":"题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法解题想法参考前面的斐波拉契数列第 n 层台阶可能由：第 n-1 跳一阶过来，还可能由第 n-2 跳两阶过来等，所以总情况 f（n）= f（n-2）+ f（n-1）+ … + f(1)递推关系式实现 f（n）= 2 * f（n-1）代码实现12345678910111213141516171819202122232425262728// 递归版本public int Fibonacci(int n) &#123; if (n == 0)&#123; return 0; &#125; if (n == 1)&#123; return 1; &#125; return 2 * Fibonacci(n-1);&#125; // 循环public int Fibonacci23(int n)&#123; if (n == 0)&#123; return 0; &#125; if (n == 1)&#123; return 1; &#125; int b = 1; int c = 0; for (int i = 1;i&lt;n;i++)&#123; c = 2 * b; b = c; &#125; return c;&#125;注意点","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 跳台阶","slug":"剑指offer题解-跳台阶","date":"2019-09-23T13:15:00.000Z","updated":"2019-09-23T13:51:57.234Z","comments":true,"path":"2019/09/23/剑指offer题解-跳台阶/","link":"","permalink":"http://suiyia.github.io/2019/09/23/剑指offer题解-跳台阶/","excerpt":"","text":"题目描述一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。解题想法第 n 层台阶可能由：第 n-1 跳一阶过来，还可能由第 n-2 跳两阶过来，所以总情况 f（n）= f（n-2）+ f（n-1）其实就是斐波拉契数列代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243// 递归版本public int Fibonacci(int n) &#123; if (n == 0)&#123; return 0; &#125; if (n == 1)&#123; return 1; &#125; return Fibonacci(n-1) + Fibonacci(n-2);&#125; // 循环public int Fibonacci23(int n)&#123; if (n == 0)&#123; return 0; &#125; if (n == 1 || n == 2)&#123; return 1; &#125; int a = 0; int b = 1; int c = 0; for (int i = 1;i&lt;n;i++)&#123; c = a + b; a = b; b = c; &#125; return c;&#125;// 多项式递推public int Fibonacci2(int n) &#123; if(n==0) &#123; return 0; &#125; else if(n==1||n==2) &#123; return 1; &#125; else if(n==3) &#123; return 2; &#125; else &#123; return 3*Fibonacci(n-3)+2*Fibonacci(n-4); &#125;&#125;注意点","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 斐波拉契数列","slug":"剑指offer题解-斐波拉契数列","date":"2019-09-23T12:39:00.000Z","updated":"2019-09-23T13:14:37.538Z","comments":true,"path":"2019/09/23/剑指offer题解-斐波拉契数列/","link":"","permalink":"http://suiyia.github.io/2019/09/23/剑指offer题解-斐波拉契数列/","excerpt":"","text":"题目描述大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项（从 0 开始，第 0 项为 0）。n&lt;=39解题想法递归，f（n）= f（n-1）+ f（n-2），但是每一次的迭代计算结果没有保存，很容易栈溢出循环方式，每次的结果进行累加多项关系式递推代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243// 递归版本public int Fibonacci(int n) &#123; if (n == 0)&#123; return 0; &#125; if (n == 1)&#123; return 1; &#125; return Fibonacci(n-1) + Fibonacci(n-2);&#125; // 循环public int Fibonacci23(int n)&#123; if (n == 0)&#123; return 0; &#125; if (n == 1 || n == 2)&#123; return 1; &#125; int a = 0; int b = 1; int c = 0; for (int i = 1;i&lt;n;i++)&#123; c = a + b; a = b; b = c; &#125; return c;&#125;// 多项式递推public int Fibonacci2(int n) &#123; if(n==0) &#123; return 0; &#125; else if(n==1||n==2) &#123; return 1; &#125; else if(n==3) &#123; return 2; &#125; else &#123; return 3*Fibonacci(n-3)+2*Fibonacci(n-4); &#125;&#125;注意点","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[]},{"title":"剑指offer题解 | 旋转数组的最小数字","slug":"剑指offer题解-旋转数组的最小数字","date":"2019-09-19T15:27:00.000Z","updated":"2019-09-23T12:39:25.513Z","comments":true,"path":"2019/09/19/剑指offer题解-旋转数组的最小数字/","link":"","permalink":"http://suiyia.github.io/2019/09/19/剑指offer题解-旋转数组的最小数字/","excerpt":"","text":"题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。解题想法常规思路：从头到尾遍历一遍找到最小值，时间复杂度 O（N）方法二非递减数组旋转，旋转之后可以看做是两个非递减数组的拼接，当 a[index] &gt; a[index+1] 时，最小值就是 a[index+1]。有序数组的查找，可以选择二分查找规律（数组内元素都不相同）：若 A[mid] &gt; a[low]，那么最小值一定在 mid 及 high 之间；若 A[mid] &lt; a[low]，那么最小值一定在 low 及 mid 之间注意点：如果 A[mid] = a[low]，那么就不能判断最小值在哪一个位置。例如 01111 旋转可以变为 11110 和 10111。只能从头到尾遍历代码实现方法二实现123456789101112131415161718192021222324252627282930313233343536373839404142public int minNumberInRotateArray(int [] array) &#123; if (array.length == 0)&#123; return 0; &#125; if (array.length == 1)&#123; return array[0]; &#125; int low = 0; int high = array.length - 1; while(low &lt; high)&#123; int mid = (low + high) / 2; if (low == high -1)&#123; return array[high]; &#125; if (array[mid] &gt; array[low])&#123; // 最小值在右边 low = mid; &#125;else if (array[mid] &lt; array[low])&#123; // 最小值在左边 high = mid; &#125;else &#123; // 分辨不出最小值位置 return serach(array); &#125; &#125; return -1;&#125; // 从头到尾查找一遍 public int serach(int[] array)&#123; int minValue = Integer.MAX_VALUE; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] &lt; minValue)&#123; minValue = array[i]; &#125; &#125; return minValue;&#125;注意点数组为空，或者只有一个长度的情况，考虑数组边界问题","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[]},{"title":"剑指offer题解 | 两个栈实现队列","slug":"剑指offer题解-两个栈实现队列","date":"2019-09-19T13:13:00.000Z","updated":"2019-09-19T15:13:51.892Z","comments":true,"path":"2019/09/19/剑指offer题解-两个栈实现队列/","link":"","permalink":"http://suiyia.github.io/2019/09/19/剑指offer题解-两个栈实现队列/","excerpt":"","text":"题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。时间限制：1秒 空间限制：32768K解题想法方法 1（常规思路，移动次数较多）stack1 专门用于 push 数据，stack2 专门 pop 数据。调用 pop() 方法时候，stack1 数据全部 push 到 stack2，保存 stack2 最顶上元素。pop 方法结束之前，将 stack2 的数据再推回到 stack1 中。方法 2（推荐，移动次数少）stack1 专门用于 push 数据。pop 方法调用的时候，若 stack2 为空就先将 stack1 中的全部数据推到 stack2，然后 pop stack2 中的元素；否则直接 pop stack2 中的数据。代码实现方法二123456789101112131415161718Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if (stack1.isEmpty() &amp;&amp; stack2.isEmpty())&#123; throw new RuntimeException(&quot;Empty exception!&quot;); &#125; if (stack2.isEmpty())&#123; while (!stack1.isEmpty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;注意点pop 数据考虑边界情况，栈为空","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 重建二叉树","slug":"剑指Offer题解-重建二叉树","date":"2019-09-18T14:32:00.000Z","updated":"2019-09-19T15:13:51.912Z","comments":true,"path":"2019/09/18/剑指Offer题解-重建二叉树/","link":"","permalink":"http://suiyia.github.io/2019/09/18/剑指Offer题解-重建二叉树/","excerpt":"","text":"题目描述输入一个链表，按链表从尾到头的顺序返回一个ArrayList。时间限制：1秒 空间限制：32768K解题想法方法 1. 使用栈保存遍历链表的结果，然后 push 栈输出到 ArrayList方法 2. 递归方式实现倒序输出代码实现递归方式实现12345678910111213141516171819ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; if (listNode != null)&#123; printListFromTailToHead(listNode.next); arrayList.add(listNode.val); &#125; return arrayList; &#125; class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 从尾到头打印链表","slug":"剑指Offer题解-从尾到头打印链表","date":"2019-09-17T15:18:00.000Z","updated":"2019-09-19T15:13:51.901Z","comments":true,"path":"2019/09/17/剑指Offer题解-从尾到头打印链表/","link":"","permalink":"http://suiyia.github.io/2019/09/17/剑指Offer题解-从尾到头打印链表/","excerpt":"","text":"题目描述输入一个链表，按链表从尾到头的顺序返回一个ArrayList。时间限制：1秒 空间限制：32768K解题想法方法 1. 使用栈保存遍历链表的结果，然后 push 栈输出到 ArrayList方法 2. 递归方式实现倒序输出代码实现递归方式实现12345678910111213141516171819ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; if (listNode != null)&#123; printListFromTailToHead(listNode.next); arrayList.add(listNode.val); &#125; return arrayList; &#125; class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 替换空格","slug":"替换空格-剑指Offer","date":"2019-09-17T13:31:00.000Z","updated":"2019-09-19T15:13:51.870Z","comments":true,"path":"2019/09/17/替换空格-剑指Offer/","link":"","permalink":"http://suiyia.github.io/2019/09/17/替换空格-剑指Offer/","excerpt":"","text":"题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。时间限制：1秒 空间限制：32768K解题想法不使用工具类思路：先统计空格出现次数，然后就知道了替换后的字符串长度，使用另外的字符串数组保存替换后的字符串，然后从右往左进行填充代码实现先统计空格出现的次数，出现一次空格，那么增加的长度就是加 2，N 个空格就是增加了 N*2然后用另外的数组保存替换后的字符12345678910111213141516171819202122232425262728293031public static String replaceSpace(StringBuffer str) &#123; // 统计空格数量 int spaceCount = 0; for (int i = 0; i &lt; str.length(); i++) &#123; if (str.charAt(i) == &apos; &apos;)&#123; spaceCount++; &#125; &#125; int length = str.length(); // 用另外的字符数组保存字符 char[] a = new char[length + spaceCount * 2]; // 字符数组索引，从最后面开始 int afterIndex = length + spaceCount * 2 - 1; for (int j = length - 1; j &gt;= 0; j--) &#123; if (str.charAt(j) != &apos; &apos;)&#123; // 如果不是空格，就直接赋值，索引也跟着减 a[afterIndex] = str.charAt(j); afterIndex --; &#125;else &#123; a[afterIndex] = &apos;0&apos;; a[afterIndex - 1] = &apos;2&apos;; a[afterIndex - 2] = &apos;%&apos;; afterIndex = afterIndex - 3; &#125; &#125; return String.valueOf(a); &#125;注意点从后往前填充相对简单点","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"剑指offer题解 | 二维数组中的查找 ","slug":"二维数组中的查找-剑指Offer","date":"2019-09-16T15:11:00.000Z","updated":"2019-09-19T15:11:08.513Z","comments":true,"path":"2019/09/16/二维数组中的查找-剑指Offer/","link":"","permalink":"http://suiyia.github.io/2019/09/16/二维数组中的查找-剑指Offer/","excerpt":"","text":"题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。时间限制：1秒 空间限制：32768K解题想法常规思路：左上角开始，每行从左到右都轮询一次。时间复杂度 O（N^2）空间复杂度 O（1）从右下角开始，每行从左往右轮询：上面一行相同列的元素比当前元素小，右边同行元素比当前元素大，那么不用全部元素比较。时间复杂度：O(行高 + 列宽)空间复杂度：O(1)从右上角开始，从右往左。原理同上从右下角开始，和常规思路类似代码实现M 行 N 列数组，寻找元素 K左下角开始寻找123456789101112131415public static boolean Find(int target, int [][] array) &#123; int i = array.length - 1; int j = 0; while (i &gt;= 0 &amp;&amp; j &lt; array[0].length)&#123; if (array[i][j] &gt; target) &#123; i--; &#125;else if(array[i][j] &lt; target)&#123; j++; &#125;else &#123; return true; &#125; &#125; return false;&#125;注意点数组边界问题常规思路，遇到有序序列进行查找时，可以使用二分查找，时间复杂度将进一步降低，时间复杂度 Mlog(n)","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://suiyia.github.io/categories/剑指offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://suiyia.github.io/tags/算法/"}]},{"title":"Log4j 2 基本概念","slug":"Log4j-2-基本概念","date":"2019-09-04T06:52:00.000Z","updated":"2019-09-04T07:00:04.528Z","comments":true,"path":"2019/09/04/Log4j-2-基本概念/","link":"","permalink":"http://suiyia.github.io/2019/09/04/Log4j-2-基本概念/","excerpt":"","text":"日志框架分类日志框架按照功能可以分为日志接口、日志实现两部分。编写程序时，推荐使用日志接口的 API 进行方法调用，然后使用对应的日志实现框架打印日志。日志接口，日志的接口规范，它对用户提供了统一的日志接口，屏蔽了不同日志组件的差异。Apache Commons Logging Component，2014 年之后文档没有再更新SLF4J（Simple Logging Facade for Java）日志实现，定义具体日志打印内容JDKLog，java.util.logging.LoggerLog4J，2015 年开始已经停止维护LOGBack，继承于 Log4JLog4J2 Log4J 升级版，2019-08-06 版本更新至 2.12.1，API 相关用法不兼容 1.X 版本Log4j 2 内置概念Markers：为某条日志添加标志位，使用 %marker 进行输出1234567891011121314public void test()&#123; private static final Marker SQL_MARKER = MarkerManager.getMarker(&quot;SQL&quot;); Marker markerA = MarkerManager.getMarker(&quot;Marker A&quot;); Marker markerB = MarkerManager.getMarker(&quot;Marker B&quot;); logger.debug(markerA,&quot;your name is &#123;&#125; &quot;,&quot;Jack&quot;); logger.debug(markerB,&quot;your name is &#123;&#125; &quot;,&quot;Ma&quot;);&#125;log4j.xml：&lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M %marker - %msg%xEx%n&quot;/&gt;Console Out：10:14:02.639 DEBUG FlowTracing 60 test Marker A - your name is Jack 10:14:02.642 DEBUG FlowTracing 61 test Marker B - your name is MaLookups：在配置文件中添加变量、使用变量Appenders：定义日志事件输出方式（日志文件名称、路径、什么级别日志才能输出、文件大小等等），其实就是文件流输出定义。AsyncAppender 用另外的线程记录日志，默认使用 ArrayBlockingQueue 队列进行日志记录，当发生异常时，默认会忽略异常，记得手动开启，并使用FailoverAppender 对异常情况进行补充打印输出ConsoleAppender，控制台输出FailoverAppender，当主 Appender 失败时，它将起作用FileAppender，文件输出，当多个程序对同一文件进行输出时，各自程序之间的配置也不受影响JDBCAppender，直接写到数据库HttpAppender，http 请求发送到另外的服务接收，如果服务返回的不是 2XX，将会抛出异常。KafkaAppender，发送到 KafkaRollingFileAppender，可以滚动的文件输出，包含触发规则（触发滚动条件：时间、大小）、滚动规则（怎么进行更新：文件数量），默认日志文件个数为 7 个。等等Layouts：Appender 使用定义好的 LayOut 对 LogEvent 进行格式化输出，CSV Layouts，以 Comma Separated Value (CSV) 形式输出JSON Layout，JSON 格式输出Pattern Layout，用特殊的字符输出对应的内容，定制化强XML LayoutLocation Infomation，当日志中需要日志所在类、方法、代码行数这些信息时，会花费 1.3-5 倍的时间，相比不需要 Location Infomation 的场景。并且在使用异步的 Appender 时，默认的 Location Infomation 默认关闭，如果开启，会比不开启花费 30-100 倍的性能消耗Filters：决定哪些事件可以输出，哪些事件不能输出。过滤结果有 3 个结果，ACCEPT（允许）, DENY（拒绝输出）or NEUTRAL（中立、默认）。BurstFilter，当每秒日志输出事件速率大于一定值，将会抛弃掉级别低的日志CompositeFilter，直接在 configuration 级别添加多个过滤器DynamicThresholdFilter，根据一些属性值去动态修改该条日志的输出级别MapFilter，如果 LogEvent 中的 MapMessage 内包含特定属性，就可以选择过滤MarkerFilter、NoMarkerFilter，对应定义或者未定义 Marker 的事件进行过滤RegexFilter，正则过滤 formatted or unformatted messageThreadContextMapFilter ，对 ThreadContextMap 中的内容进行过滤ThresholdFilter，对 Level 进行过滤TimeFilter，根据某个时间点、时间段进行过滤3. Java API 用法Flow Tracing日志跟踪Markers（标记）对于有特定标识需求的地方，可以使用 Marker 进行标记，并且用 %marker 进行打印输出。ThreadContextMapped Diagnostic Context（MDC）的实现，类似 request，可以存放 key-value 键值对，也可以销毁，使用 %X{key} 输出。the MDC is a map which stores the context data of the particular thread where the context is running.12345678910%X&#123;id&#125; 输出 context map 中 key = id 的值%X 输出 context map 所有值public void test()&#123; ThreadContext.put(&quot;id&quot;, &quot;321&quot;); // Add the fishtag; ThreadContext.put(&quot;name&quot;, &quot;996&quot;); // Add the fishtag; logger.debug(&quot;Message 1&quot;); logger.debug(&quot;Message 2&quot;); ThreadContext.clearAll();&#125;其他log4j-slf4j-impl 是 slf4j 转接到 log4j 2 的日志输出框架。slf4j-log4j12 是 slf4j 转接到 log4j 1.x 的日志输出框架 ，而 log4j 1.x 已经在 2015 年 8 月就停止更新了。log4j 官方建议升级到 log4j 2","categories":[{"name":"日志","slug":"日志","permalink":"http://suiyia.github.io/categories/日志/"}],"tags":[{"name":"Log4j","slug":"Log4j","permalink":"http://suiyia.github.io/tags/Log4j/"}]},{"title":"浮点数整数转换精度丢失问题","slug":"浮点数整数转换精度丢失问题","date":"2019-08-10T09:44:00.000Z","updated":"2019-09-19T10:36:57.304Z","comments":true,"path":"2019/08/10/浮点数整数转换精度丢失问题/","link":"","permalink":"http://suiyia.github.io/2019/08/10/浮点数整数转换精度丢失问题/","excerpt":"","text":"浮点数转换精度丢失在线支付对接，支付商（微信、支付宝、银联等）的接口中，定义的金额单位不一样，有时候需要对分、元进行相互转换，转换的过程中容易出现问题。下面的例子，系统中接收的参数是元，请求接口单位是分，在转换过程中出现精度丢失，少扣了用户 1 分钱。1234567public class Main &#123; public static void main(String[] args) &#123; System.out.println((int) (0.29*100)); &#125;&#125;输出： 28错误原因0.29*100 = 28.999999999999996…浮点数强制转换成整数类型会舍弃非整数部分解决方法(int) Math.round(0.29*100) -&gt; 29浮点数大小比较错误12345678910// 例子 1System.out.println(0.1d == 0.1f); // false// 例子 2System.out.println(10.222222225f == 10.222222229f); // trueSystem.out.println(10.222222225f &gt; 10.222222229f); // falseSystem.out.println(10.222222225f &lt; 10.222222229f); // false// 例子 3Double a = Double.valueOf(&quot;0.0&quot;);Double b = Double.valueOf(&quot;-0.0&quot;);System.out.println(a.equals(b)); // false浮点数由于精度问题，并不能用 ==，&gt;，&lt; 来进行大小比较，最好的方式就是定义一个精度，用差的绝对值比较，在精度范围内就认为是相等的官方文档参考Java中的浮点数比较 == equals 和 compare","categories":[],"tags":[{"name":"浮点数","slug":"浮点数","permalink":"http://suiyia.github.io/tags/浮点数/"}]},{"title":"Springboot 项目运用 Redis 缓存数据","slug":"Springboot-项目运用-Redis-缓存数据","date":"2019-08-10T09:40:00.000Z","updated":"2019-08-10T09:51:13.059Z","comments":true,"path":"2019/08/10/Springboot-项目运用-Redis-缓存数据/","link":"","permalink":"http://suiyia.github.io/2019/08/10/Springboot-项目运用-Redis-缓存数据/","excerpt":"","text":"介绍Springboot 项目与 Redis 结合获取数据pom 依赖主要是 mybatis、redis 的相关依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748server: servlet: context-path: /web port: 8080spring: datasource: druid: # 数据库访问配置, 使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useunicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: 123456 # 连接池配置 initial-size: 5 min-idle: 5 max-active: 20 # 连接等待超时时间 max-wait: 30000 # 配置检测可以关闭的空闲连接间隔时间 time-between-eviction-runs-millis: 60000 # 配置连接在池中的最小生存时间 min-evictable-idle-time-millis: 300000 validation-query: select &apos;1&apos; from dual test-while-idle: true test-on-borrow: false test-on-return: false # 打开PSCache，并且指定每个连接上PSCache的大小 pool-prepared-statements: true max-open-prepared-statements: 20 max-pool-prepared-statement-per-connection-size: 20 # 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, &apos;wall&apos;用于防火墙 filters: stat,wall # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔 aop-patterns: com.springboot.servie.* redis: # Redis数据库索引（默认为0） database: 0 # Redis服务器地址 host: localhost # Redis服务器连接端口 port: 6379logging: level: com.example.demo.dao: debugRedis 配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123; // 自定义缓存key生成策略 @Override @Bean public KeyGenerator keyGenerator() &#123; return new KeyGenerator() &#123; @Override public Object generate(Object target, java.lang.reflect.Method method, Object... params) &#123; StringBuffer sb = new StringBuffer(); sb.append(target.getClass().getName()); sb.append(method.getName()); for (Object obj : params) &#123; sb.append(obj.toString()); &#125; return sb.toString(); &#125; &#125;; &#125; // 缓存管理器 @Bean public CacheManager cacheManager(RedisConnectionFactory connectionFactory) &#123; RedisCacheManager cacheManager = RedisCacheManager.create(connectionFactory); return cacheManager; &#125; @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123; StringRedisTemplate template = new StringRedisTemplate(factory); setSerializer(template);// 设置序列化工具 template.afterPropertiesSet(); return template; &#125; private void setSerializer(StringRedisTemplate template) &#123; @SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;) Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setValueSerializer(jackson2JsonRedisSerializer); &#125;&#125;dao 层以及实现使用 MyBatis 注解方式实现数据访问123456789101112131415@Mapperpublic interface StudentManager &#123; @Update(&quot;update student set sname=#&#123;sname&#125;,ssex=#&#123;ssex&#125; where sno=#&#123;sno&#125;&quot;) int update(Student student); @Delete(&quot;delete from student where sno=#&#123;sno&#125;&quot;) void deleteStudentBySno(String sno); @Select(&quot;select * from student where sno=#&#123;sno&#125;&quot;) @Results(id = &quot;student&quot;, value = &#123; @Result(property = &quot;sno&quot;, column = &quot;sno&quot;, javaType = String.class), @Result(property = &quot;sname&quot;, column = &quot;sname&quot;, javaType = String.class), @Result(property = &quot;ssex&quot;, column = &quot;ssex&quot;, javaType = String.class) &#125;) Student queryStudentBySno(String sno);&#125;service 层及实现queryStudentBySno 方法使用了注解 @Cacheable(key=”#p0”)，即将 id 作为 redis 中的 key 值@CacheConfig(cacheNames = “student”) 一个类中可能会有多个缓存操作，而这些缓存操作可能是重复的@Cacheable 是用来声明方法是可缓存的@CachePut 主要用于数据新增和修改操作上@CacheEvict 通常用在删除方法上，用来从缓存中移除相应数据123456789101112131415161718192021222324252627282930313233343536@CacheConfig(cacheNames = &quot;student&quot;)public interface StudentService &#123; @CachePut(key = &quot;#p0.sno&quot;) Student update(Student student); @CacheEvict(key = &quot;#p0&quot;, allEntries = true) void deleteStudentBySno(String sno); @Cacheable(key = &quot;#p0&quot;) Student queryStudentBySno(String sno);&#125;@Servicepublic class StudentServiceImpl implements StudentService &#123; @Autowired private StudentManager studentManager; @Override public Student update(Student student) &#123; this.studentManager.update(student); return this.studentManager.queryStudentBySno(student.getSno()); &#125; @Override public void deleteStudentBySno(String sno) &#123; this.studentManager.deleteStudentBySno(sno); &#125; @Override public Student queryStudentBySno(String sno) &#123; return this.studentManager.queryStudentBySno(sno); &#125;&#125;Test 用例第一次从数据库中读取，第二次直接从缓存读取123456789101112131415161718192021@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123; @Autowired private StudentService studentService; @Test public void contextLoads() &#123; System.out.println(studentService.queryStudentBySno(&quot;001&quot;).toString()); System.out.println(studentService.queryStudentBySno(&quot;001&quot;).toString()); &#125;&#125;2019-08-10 17:27:32.739 DEBUG 7140 --- [ main] c.e.d.d.S.queryStudentBySno : ==&gt; Preparing: select * from student where sno=? 2019-08-10 17:27:33.053 DEBUG 7140 --- [ main] c.e.d.d.S.queryStudentBySno : ==&gt; Parameters: 001(String)2019-08-10 17:27:33.108 DEBUG 7140 --- [ main] c.e.d.d.S.queryStudentBySno : &lt;== Total: 1Student(sno=001, sname=KangKang, ssex=M )Student(sno=001, sname=KangKang, ssex=M )总结","categories":[{"name":"Spring学习","slug":"Spring学习","permalink":"http://suiyia.github.io/categories/Spring学习/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://suiyia.github.io/tags/Redis/"},{"name":"Springboot","slug":"Springboot","permalink":"http://suiyia.github.io/tags/Springboot/"}]},{"title":"Springboot 与 AOP 实现","slug":"Springboot-与-AOP-实现","date":"2019-08-10T09:39:00.000Z","updated":"2019-08-10T09:51:13.073Z","comments":true,"path":"2019/08/10/Springboot-与-AOP-实现/","link":"","permalink":"http://suiyia.github.io/2019/08/10/Springboot-与-AOP-实现/","excerpt":"","text":"介绍Springboot 项目 AOP 实现，记录方法的执行过程pom 依赖druid、JdbcTemplate、aop123456789101112131415161718192021222324252627282930313233343536373839&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;代码实现Mysql 脚本12345678910CREATE TABLE SYS_LOG ( ID INT(20) NOT NULL COMMENT &apos;用户名&apos; PRIMARY KEY AUTO_INCREMENT , USERNAME VARCHAR(50) NULL COMMENT &apos;用户名&apos;, OPERATION VARCHAR(50) NULL COMMENT &apos;用户操作&apos;, TIME INT(11) NULL COMMENT &apos;响应时间&apos;, METHOD VARCHAR(1024) NULL COMMENT &apos;请求方法&apos;, PARAMS VARCHAR(1024) NULL COMMENT &apos;请求参数&apos;, IP VARCHAR(64) NULL COMMENT &apos;IP地址&apos;, CREATE_TIME DATE NULL COMMENT &apos;创建时间&apos;);实体类123456789101112131415161718192021import java.io.Serializable;import java.util.Date;import lombok.Getter;import lombok.Setter;import lombok.ToString;@Setter@Getter@ToStringpublic class SysLog implements Serializable &#123; private Integer id; private String username; private String operation; private Integer time; private String method; private String params; private String ip; private Date createTime;&#125;定义一个方法级别的 @Log 注解，需要监控的方法加上该注解就行12345@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Log &#123; String value() default &quot;&quot;;&#125;定义 dao 方法，保存日志到数据库123public interface SysLogDao &#123; void saveSysLog(SysLog sysLog);&#125;1234567891011121314151617@Componentpublic class SysLogDaoImpl implements SysLogDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public void saveSysLog(SysLog sysLog) &#123; StringBuffer sql = new StringBuffer(&quot;insert into sys_log &quot;); sql.append(&quot;(username,operation,time,method,params,ip,create_time) &quot;); sql.append(&quot;values(:username,:operation,:time,:method,&quot;); sql.append(&quot;:params,:ip,:createTime)&quot;); NamedParameterJdbcTemplate npjt = new NamedParameterJdbcTemplate(this.jdbcTemplate.getDataSource()); npjt.update(sql.toString(), new BeanPropertySqlParameterSource(sysLog)); &#125;&#125;切面切点定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@Aspect@Componentpublic class LogAspect &#123; @Autowired private SysLogDao sysLogDao; @Pointcut(&quot;@annotation(com.example.demo.annotion.Log)&quot;) public void pointcut()&#123;&#125; @Around(&quot;pointcut()&quot;) public Object around(ProceedingJoinPoint proceedingJoinPoint)&#123; Object result = null; long beginTime = System.currentTimeMillis(); try &#123; // 执行方法 result = proceedingJoinPoint.proceed(); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; // 执行时长(毫秒) long time = System.currentTimeMillis() - beginTime; // 保存日志 saveLog(proceedingJoinPoint, time); return result; &#125; private void saveLog(ProceedingJoinPoint joinPoint, long time) &#123; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); SysLog sysLog = new SysLog(); Log logAnnotation = method.getAnnotation(Log.class); if (logAnnotation != null) &#123; // 注解上的描述 sysLog.setOperation(logAnnotation.value()); &#125; // 请求的方法名 String className = joinPoint.getTarget().getClass().getName(); String methodName = signature.getName(); sysLog.setMethod(className + &quot;.&quot; + methodName + &quot;()&quot;); // 请求的方法参数值 Object[] args = joinPoint.getArgs(); // 请求的方法参数名称 LocalVariableTableParameterNameDiscoverer u = new LocalVariableTableParameterNameDiscoverer(); String[] paramNames = u.getParameterNames(method); if (args != null &amp;&amp; paramNames != null) &#123; String params = &quot;&quot;; for (int i = 0; i &lt; args.length; i++) &#123; params += &quot; &quot; + paramNames[i] + &quot;: &quot; + args[i]; &#125; sysLog.setParams(params); &#125; // 获取request HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); // 设置IP地址 sysLog.setIp(IPUtils.getIpAddr(request)); // 模拟一个用户名 sysLog.setUsername(&quot;mrbird&quot;); sysLog.setTime((int) time); sysLog.setCreateTime(new Date()); // 保存系统日志 sysLogDao.saveSysLog(sysLog); &#125;&#125;public class IPUtils &#123; /** * 获取IP地址 * * 使用Nginx等反向代理软件， 则不能通过request.getRemoteAddr()获取IP地址 如果使用了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP地址，X-Forwarded-For中第一个非unknown的有效IP字符串，则为真实IP地址 */ public static String getIpAddr(HttpServletRequest request) &#123; String ip = request.getHeader(&quot;x-forwarded-for&quot;); if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123; ip = request.getHeader(&quot;Proxy-Client-IP&quot;); &#125; if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123; ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;); &#125; if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123; ip = request.getRemoteAddr(); &#125; return &quot;0:0:0:0:0:0:0:1&quot;.equals(ip) ? &quot;127.0.0.1&quot; : ip; &#125;&#125;Controller 方法123456789101112131415161718@RestControllerpublic class TestController &#123; @Log(&quot;执行方法一&quot;) @GetMapping(&quot;/one&quot;) public void methodOne(String name) &#123; &#125; @Log(&quot;执行方法二&quot;) @GetMapping(&quot;/two&quot;) public void methodTwo() throws InterruptedException &#123; Thread.sleep(2000); &#125; @Log(&quot;执行方法三&quot;) @GetMapping(&quot;/three&quot;) public void methodThree(String name, String age) &#123; &#125;&#125;测试12345678910111213http://localhost:8080/web/one?name=KangKanghttp://localhost:8080/web/twohttp://localhost:8080/web/three?name=Mike&amp;age=25&gt; select * from sys_log order by id;ID USERNAME OPERATION TIME METHOD PARAMS IP CREATE_TIME1 mrbird 执行方法一 3 com.example.demo.web.TestController.methodOne() name: KangKang 127.0.0.1 2019-08-102 mrbird 执行方法二 2002 com.example.demo.web.TestController.methodTwo() 127.0.0.1 2019-08-103 mrbird 执行方法三 0 com.example.demo.web.TestController.methodThree() name: Mike age: 25 127.0.0.1 2019-08-104 mrbird 执行方法三 0 com.example.demo.web.TestController.methodThree() name: Mike age: 25 127.0.0.1 2019-08-105 mrbird 执行方法二 2001 com.example.demo.web.TestController.methodTwo() 127.0.0.1 2019-08-10总结切面对项目响应时间的影响待测试，现在用的项目基本没有应用到切面，等有实际落地需求在改进学习下源码","categories":[{"name":"Spring学习","slug":"Spring学习","permalink":"http://suiyia.github.io/categories/Spring学习/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://suiyia.github.io/tags/Springboot/"},{"name":"AOP","slug":"AOP","permalink":"http://suiyia.github.io/tags/AOP/"}]},{"title":"Springboot 使用 MyBatis 实现增删改查","slug":"Springboot-使用-MyBatis-实现增删改查","date":"2019-08-10T09:39:00.000Z","updated":"2019-08-10T09:51:13.110Z","comments":true,"path":"2019/08/10/Springboot-使用-MyBatis-实现增删改查/","link":"","permalink":"http://suiyia.github.io/2019/08/10/Springboot-使用-MyBatis-实现增删改查/","excerpt":"","text":"内容Springboot 项目结合 Mybatis 实现 CRUD 增删改查基本 Mysql 脚本123456789CREATE TABLE student ( sno VARCHAR(10) NOT NULL , sname VARCHAR(10) NOT NULL , ssex VARCHAR(2) NOT NULL );INSERT INTO STUDENT VALUES (&apos;001&apos;, &apos;KangKang&apos;, &apos;M &apos;);INSERT INTO STUDENT VALUES (&apos;002&apos;, &apos;Mike&apos;, &apos;M &apos;);INSERT INTO STUDEN VALUES (&apos;003&apos;, &apos;Jane&apos;, &apos;F &apos;);pom 基本包依赖1234567891011121314151617181920212223&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;配置文件 application.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869server: servlet: context-path: /web port: 8080spring: datasource: druid: # 数据库访问配置, 使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useunicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: 123456 # 连接池配置 initial-size: 5 min-idle: 5 max-active: 20 # 连接等待超时时间 max-wait: 30000 # 配置检测可以关闭的空闲连接间隔时间 time-between-eviction-runs-millis: 60000 # 配置连接在池中的最小生存时间 min-evictable-idle-time-millis: 300000 validation-query: select &apos;1&apos; from dual test-while-idle: true test-on-borrow: false test-on-return: false # 打开PSCache，并且指定每个连接上PSCache的大小 pool-prepared-statements: true max-open-prepared-statements: 20 max-pool-prepared-statement-per-connection-size: 20 # 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, &apos;wall&apos;用于防火墙 filters: stat,wall # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔 aop-patterns: com.springboot.servie.* # WebStatFilter配置 web-stat-filter: enabled: true # 添加过滤规则 url-pattern: /* # 忽略过滤的格式 exclusions: &apos;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&apos; # StatViewServlet配置 stat-view-servlet: enabled: true # 访问路径为/druid时，跳转到StatViewServlet url-pattern: /druid/* # 是否能够重置数据 reset-enable: false # 需要账号密码才能访问控制台 login-username: druid login-password: druid123 # IP白名单 # allow: 127.0.0.1 # IP黑名单（共同存在时，deny优先于allow） # deny: 192.168.1.218 # 配置StatFilter filter: stat: log-slow-sql: truemybatis: mapper-locations: classpath:mapper/*.xml configuration-properties: BEFORE代码实现接口+注解形式实现数据库读取写入1234567891011121314151617181920@Mapperpublic interface StudentManagerWithInject &#123; @Insert(&quot;insert into student(sno,sname,ssex)values(#&#123;sno&#125;,#&#123;name&#125;,#&#123;ssex&#125;)&quot;) int add(Student student); @Update(&quot;update student set sname=#&#123;name&#125;,ssex=#&#123;sex&#125; where sno=#&#123;sno&#125;&quot;) int update(Student student); @Delete(&quot;delete from student where sno=#&#123;sno&#125;&quot;) int deleteBySno(String sno); @Select(&quot;select * from student where sno=#&#123;sno&#125;&quot;) @Results(id = &quot;student&quot;,value= &#123; @Result(property = &quot;sno&quot;, column = &quot;sno&quot;, javaType = String.class), @Result(property = &quot;name&quot;, column = &quot;sname&quot;, javaType = String.class), @Result(property = &quot;sex&quot;, column = &quot;ssex&quot;, javaType = String.class) &#125;) Student queryStudentBySno(String sno);&#125;自动装配实现业务逻辑12345678910111213141516171819202122@RestControllerpublic class TestController &#123; @Autowired private StudentManagerWithInject studentManagerWithInject; @Autowired private StudentMapperWithXML studentMapperWithXML; @RequestMapping(value = &quot;/querystudent&quot;,method = RequestMethod.GET) public Student queryStudentBySno( @RequestParam String sno)&#123; return studentManagerWithInject.queryStudentBySno(sno); &#125; @RequestMapping(value = &quot;/querystudentwithxml&quot;,method = RequestMethod.GET) public Student queryStudentWithXMLBySno( @RequestParam String sno)&#123; return studentMapperWithXML.queryStudentBySno(sno); &#125;&#125;调用接口，得到结果12345678http://localhost:8080/web/querystudent?sno=001输出&#123; &quot;sno&quot;: &quot;001&quot;, &quot;name&quot;: &quot;KangKang&quot;, &quot;sex&quot;: &quot;M &quot;&#125;最后一般项目会增加一个 service 服务层，一个服务可能对应多个数据库操作，这里节省时间就没有加，工作中还是根据项目规范来。学习参考源码第一章节","categories":[{"name":"Spring学习","slug":"Spring学习","permalink":"http://suiyia.github.io/categories/Spring学习/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://suiyia.github.io/tags/Springboot/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://suiyia.github.io/tags/MyBatis/"}]},{"title":"HashMap、HashTable、ConcurrentHashMap 区别","slug":"HashMap、HashTable、ConcurrentHashMap-区别","date":"2019-04-07T06:24:00.000Z","updated":"2019-04-07T13:38:48.975Z","comments":true,"path":"2019/04/07/HashMap、HashTable、ConcurrentHashMap-区别/","link":"","permalink":"http://suiyia.github.io/2019/04/07/HashMap、HashTable、ConcurrentHashMap-区别/","excerpt":"","text":"简单总结 HashMap、Hashtable、ConcurrentHashMap 之间的区别，基于 JDK 1.8.0_191先说结论，暂时有以下几个需要注意的不同点：继承、实现接口不同初始大小、扩容倍数不同线程安全NULL KEY，NULL VALUE 支持不同计算 Hash 值的方式不同1. 继承、实现接口不同12345678public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125; public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;, Serializable &#123;HashMap、ConcurrentHashMap 都继承于 AbstractMap 抽象类，但 Hashtable 继承于 Dictionary 抽象类。AbstractMap 实现了 Map 接口，而 Dictionary 没有。这使得 AbstractMap 具有更多的功能，而 Dictionary 逐渐被弃用。2. 初始大小、扩容倍数不同HashMap1234static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16扩容部分代码：newThr = oldThr &lt;&lt; 1; // double thresholdHashtable123456public Hashtable() &#123; this(11, 0.75f);&#125;扩容部分代码：int newCapacity = (oldCapacity &lt;&lt; 1) + 1;ConcurrentHashMap12345/** * The default initial table capacity. Must be a power of 2 * (i.e., at least 1) and at most MAXIMUM_CAPACITY. */private static final int DEFAULT_CAPACITY = 16;初始大小：HashMap、ConcurrentHashMap 都是 16，Hashtable 是 11扩容倍数：HashMap、ConcurrentHashMap 2 倍、Hashtable (2n + 1) 倍。3. 线程安全12345Hashtable:public synchronized V put(K key, V value) &#123;&#125;HashMap:public V put(K key, V value) &#123;&#125;Hashtable 添加元素方法加上了 synchronized 关键字，HashMap 没有，说明 HashMap 不适用于多线程环境。ConcurrentHashMap 添加元素时，只对需要变更的地方加锁。4. NULL KEY，NULL VALUE 支持不同通过观察它们的 put 方法，得到以下结论：Hashtable、ConcurrentHashMap 的 key、value 都不能为 null。HashMap value 可以为 null，而 key 为 null 时，该元素会放在 HashMap 第一位。5. key 的索引计算方法不同计算元素存放位置，会经过两步转化。Object -&gt; int -&gt; index，先将 key 使用 hash 方法转换为一个整数数字，然后对整型数字进行转化，得到这个对象在 map 中的索引。Hashtable12int hash = key.hashCode();int index = (hash &amp; 0x7FFFFFFF) % tab.length;HashMap1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;Hashtable 直接使用对象的 hashCode，然后再使用除留余数法来获得最终的位置。HashMap 在对象的 hashCode 之上，将 hashCode 的高16位和低16位进行异或，得到最终的位置。总结后面学习将对 HashMap，ConcurrentHashMap 源码进行分析总结。ConcurrentHashMap的扩容机制（jdk1.8）HashMap 和Hashtable的区别","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://suiyia.github.io/categories/Java基础/"}],"tags":[{"name":"集合","slug":"集合","permalink":"http://suiyia.github.io/tags/集合/"}]},{"title":"ArraryList、LinkList和Vector的区别","slug":"ArraryList、LinkList和Vector的区别","date":"2019-03-24T05:53:00.000Z","updated":"2019-04-07T13:32:54.477Z","comments":true,"path":"2019/03/24/ArraryList、LinkList和Vector的区别/","link":"","permalink":"http://suiyia.github.io/2019/03/24/ArraryList、LinkList和Vector的区别/","excerpt":"","text":"本文基于 JDK 1.8.0_1911. 源码对比实现接口类对比扩容机制对比线程安全1.1 实现接口类对比12345678910public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable它们都实现 List 接口，说明具备列表的增加、删除、遍历元素等特性。ArrayList、Vector 额外实现 RandomAccess 接口，说明他们能在常量时间复杂度内快速随机访问元素。LinkedList 额外实现 Queue 接口，具备队列的入队、出队等特性。1.2 扩容机制对比ArrayList123456789101112131415private static final int DEFAULT_CAPACITY = 10; // 定义初始大小private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 定义列表存储元素数量最大值 private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 现有元素数量 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 增加后元素的数量 = 1 + 0.5 if (newCapacity - minCapacity &lt; 0) // 增加后的元素数量 &lt; 现有的空间，不扩容 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 增加后的元素数量 &gt; 大于最大值，尝试分配 Integer.MAX_VALUE 个元素，可能会抛出 OutOfMemoryError // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;Vector12345678910111213141516public Vector() &#123; this(10);&#125;protected int capacityIncrement; // 扩容数量值，Vector 初始化不指定时默认为 0private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); // 当扩容数量值小于 0，那么扩容比例为原来的两倍；否则扩容的数量为这个值。 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125;LinkList1transient int size = 0;初始大小：ArrayList、Vector 默认为 10，LinkList 不指定默认为 0扩容比例：ArrayList 以 1.5 倍进行扩容；Vector 不指定扩容比例时默认为 2 倍进行扩容1.3 线程安全性ArrayList1234567protected transient int modCount = 0;public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;Vector1234567protected transient int modCount = 0;public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125;Vector add() 方法上增加了 synchronized 关键字，使得 Vector 支持多线程环境下的元素增加删除修改操作。2. 增删改性能对比根据数据结构中知识:顺序表查找元素时间复杂度为 O(1)，适用于随机查找元素的场景。链表增减元素时间复杂度为 O(1)，适用于增减元素比较多的场景。1234567891011121314151617181920212223242526272829303132public static void main(String[] args) &#123; ArrayList arrayList = new ArrayList(); LinkedList linkedList = new LinkedList(); Vector vector = new Vector(); long t1, t2; t1 = System.nanoTime(); for (int i = 0; i &lt; 10000; i++) &#123; arrayList.add(i); &#125; t2 = System.nanoTime(); System.out.println(&quot;ArrayList add:&quot; + (t2 - t1)); t1 = System.nanoTime(); for (int i = 0; i &lt; 10000; i++) &#123; linkedList.add(i); &#125; t2 = System.nanoTime(); System.out.println(&quot;linkedList add:&quot; + (t2 - t1)); t1 = System.nanoTime(); for (int i = 0; i &lt; 10000; i++) &#123; vector.add(i); &#125; t2 = System.nanoTime(); System.out.println(&quot;vector add:&quot; + (t2 - t1));&#125; ArrayList add:6810212linkedList add:3463194vector add:4442985添加元素，ArrayList 花费时间比 LinkList 时间长。1234567891011121314151617181920212223242526272829303132333435363738public static void main(String[] args) &#123; ArrayList arrayList = new ArrayList(); LinkedList linkedList = new LinkedList(); Vector vector = new Vector(); long t1, t2; for (int i = 0; i &lt; 100000; i++) &#123; arrayList.add(i); linkedList.add(i); vector.add(i); &#125; t1 = System.nanoTime(); for (int i = 0; i &lt; 10000; i++) &#123; arrayList.get(i); &#125; t2 = System.nanoTime(); System.out.println(&quot;ArrayList get:&quot; + (t2 - t1)); t1 = System.nanoTime(); for (int i = 0; i &lt; 10000; i++) &#123; linkedList.get(i); &#125; t2 = System.nanoTime(); System.out.println(&quot;linkedList get:&quot; + (t2 - t1)); t1 = System.nanoTime(); for (int i = 0; i &lt; 10000; i++) &#123; vector.get(i); &#125; t2 = System.nanoTime(); System.out.println(&quot;vector get:&quot; + (t2 - t1));&#125; ArrayList get:72482linkedList get:107975370vector get:242634查找元素上，ArrayList 最快3. 总结将 ArrayList、LinkList 和 Vetor 进行了简单对比，总体来说：在查找元素比较频繁的场合，推荐使用 ArrayList；在修改元素比较频繁的场合，推荐使用 LinkList。Vetor 与 ArrayList 类似，区别在于扩容比例、线程安全方面。性能对比测试结果可能存在添加元素 ArrayList 花费时间比 LinkList 多的情况， 这个原因参考：ArrayList vs LinkedList vs Vector 区别","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://suiyia.github.io/categories/Java基础/"}],"tags":[{"name":"集合","slug":"集合","permalink":"http://suiyia.github.io/tags/集合/"}]},{"title":"Java字符串拼接效率对比","slug":"Java-字符串拼接效率对比","date":"2019-03-17T07:30:00.000Z","updated":"2019-04-07T13:32:54.526Z","comments":true,"path":"2019/03/17/Java-字符串拼接效率对比/","link":"","permalink":"http://suiyia.github.io/2019/03/17/Java-字符串拼接效率对比/","excerpt":"","text":"用 Google photo 搜索关键词「String」，出现了上图，有兴趣的朋友可以试试，感觉发现了新大陆…Java 中有 3 种字符串的拼接方式，了解这三种拼接方式的实现，将有益于提高自己的代码质量。本文主要讲解 String 对象的三种拼接方式，以及它们之间的效率对比。三种方式1234567891011// 方式 1String s = &quot;Hello&quot;;s += &quot;Hello&quot;;// 方式 2StringBuilder stringBuilder = new StringBuilder(&quot;Hello&quot;);stringBuilder.append(&quot;Hello&quot;);// 方式 3StringBuffer stringBuffer = new StringBuffer(&quot;Hello&quot;);stringBuffer.append(&quot;Hello&quot;);自己写个主函数，将上面 3 个方法循环执行 10000 次；执行时间 t1 &gt; t3 &gt; t2，也就是说 StringBuilder.append() 拼接最快，String += 最慢。源码解读StringBuilder.append() 拼接StringBuilder.java123456789public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence@Overridepublic StringBuilder append(String str) &#123; super.append(str); // 调用父类 append 方法 return this;&#125;AbstractStringBuilder.java123456789public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); // 调用 String 的 getChars 方法 count += len; return this;&#125;String.java123456789101112public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123; if (srcBegin &lt; 0) &#123; throw new StringIndexOutOfBoundsException(srcBegin); &#125; if (srcEnd &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(srcEnd); &#125; if (srcBegin &gt; srcEnd) &#123; throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); &#125; System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin); // 本地方法&#125;从上面 3 段代码可知，StringBuilder.append 方法调用的是父类 AbstractStringBuilder.append，父类 append 方法调用了 String 的本地方法 System.arraycopy 实现StringBuffer.append() 拼接StringBuilder.java12345678910public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence@Overridepublic synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125;StringBuffer.append 方法与 StringBuilder.append 方法类似，不同的是，append 方法加上了 synchronized 锁，说明该方法适用于多线程环境，但是加锁的过程需要耗时，所以执行时间比 StringBuilder.append 慢。String += 拼接对下面代码进行编译，生成的 class 文件使用命令 javap -c Main.class，可以反编译得到图片中的字节码。可以看到 += 实际调用的是 StringBuilder.append() 方法，所以速度会比 StringBuilder 慢。12345public static void main(String[] args) &#123; String s = &quot;Hello&quot;; s = s + &quot; World&quot;; System.out.println(s);&#125;总结所以在需要拼接字符串的场合，尽量适用 StringBuilder.append() 方法，多线程环境下则推荐 StringBuffer.append() 方法，而 String += 拼接方式任何场合都不建议使用。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://suiyia.github.io/categories/Java基础/"}],"tags":[{"name":"String","slug":"String","permalink":"http://suiyia.github.io/tags/String/"}]},{"title":"Java中的值传递","slug":"Java-中的值传递","date":"2019-02-18T15:12:00.000Z","updated":"2019-04-07T13:32:54.490Z","comments":true,"path":"2019/02/18/Java-中的值传递/","link":"","permalink":"http://suiyia.github.io/2019/02/18/Java-中的值传递/","excerpt":"","text":"几个重要概念实参、形参形式参数：定义函数名和函数体时候使用的参数，目的用来接收调用该函数时传入的参数实际参数：在调用有参函数时，主调函数与被调函数之间有数据传递关系。实际参数是调用有参方法的时候真正传递的内容。12345678 public void tes(String name)&#123; // 形式参数 name System.out.println(name);&#125;public static void main(String[] args) &#123; Test test = new Test(); test.tes(&quot;caijicoder&quot;); // 实际参数 caijicoder&#125;值类型、引用类型：值类型就是基本数据类型，8 种基本类型除外的数据类型都是引用类型。两种类型分别表示两种内存分配方式。一个值类型数据直接在栈上分配，存储所包含的值，其值就代表数据本身。一个引用类型指向的数据在堆上分配，引用类型的值是这个堆上数据的地址。12int num = 10;String str = &quot;hello&quot;;num 是基本类型（值类型），值就直接保存在变量中。str 是引用类型，变量中保存的只是实际对象的地址（0x10），而不是 Hello 这个字符串。值传递、引用传递：值传递（pass by value）：指在调用函数时，将实参复制一份传递到函数中，形参接收到的内容其实是实参的一个拷贝，函数对形参的修改并不会影响到实参引用传递（pass by reference）：指在调用函数时，将实参的地址直接传递到函数中，在函数中对参数的修改将会影响到实参值传递和引用传递属于函数调用时参数的求值策略（Evaluation Strategy），这是对调用函数时，求值和传值的方式的描述，并不指传递的内容的类型。也就是说，传递内容的类型是值类型还是引用类型（地址），与值传递、引用传递无关，并不能说传入的参数类型是值类型就是值传递。接下来重点！！！对于值传递，无论是值类型还是引用类型，都会在调用栈上创建一个副本：对于值类型而言，这个副本就是整个原始值的复制，对这个副本的操作，不影响原始值的内容。对于引用类型而言，其副本也只是这个引用的复制，指向的仍然是同一个对象。所以对副本的操作，会影响原始值。为什么 Java 只有值传递，但 C# 既有值传递，又有引用传递，这种语言设计有哪些好处？ - Hugo Gu的回答 - 知乎一个实例定义 Person 类123456789101112131415161718192021222324252627282930313233public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, age=&quot; + age + &apos;&#125;&apos;; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940public class Main &#123; private int X = 123; public void updateVlue(int value)&#123; // 传入基本数据类型 value = value + 1; System.out.println(&quot;变量value: &quot;+value); &#125; public void updateObject(Person person)&#123; // 传入引用类型 Person E = person; E.setAge(21); &#125; public void swapObject(Person A,Person B)&#123; // 传入引用类型 Person C = A; A = B; B = C; &#125; public static void main(String[] args) &#123; // 例子 1 Main main = new Main(); int X = 1; main.updateVlue(X); System.out.println(&quot;X 的值：&quot;+X); // X = 1 // 例子 2 Person A = new Person(&quot;张三&quot;,20); main.updateObject(A); System.out.println(&quot;A: &quot;+A.toString()); // A: Person&#123;name=&apos;张三&apos;, age=21&#125; // 例子 3 Person C = new Person(&quot;C&quot;,10); Person D = new Person(&quot;D&quot;,15); main.swapObject(C,D); System.out.println(&quot;C: &quot;+ C.toString()); // C: Person&#123;name=&apos;C&apos;, age=10&#125; System.out.println(&quot;D: &quot;+ D.toString()); // D: Person&#123;name=&apos;D&apos;, age=15&#125; &#125;&#125;例子1：函数传入基本数据类型（值类型参数），由于 value 是 X 的一个副本，对 value 进行操作，并没有改变原来实参的值。例子2：函数传入引用类型参数，改变了原来的值。由于值传递的缘故，传入引用类型的参数时，其值是这个地址的拷贝，指向的仍然是同一个对象，所以发生了改变。这是值传递带来的效果，与传入的对象是值类型或者引用类型没有关系！例子3：函数传入引用类型，如果 Java 是引用传递， 那么 swapObject(Person A,Person B) 中的形参 A，B 接收的就是 C 和 D 的地址，对 A，B 进行交换应该能成功的，事实上 C 和 D 并没有交换，这从反面证明了 Java 不是引用传递。参考Java 到底是值传递还是引用传递？ - Hollis的回答 - 知乎这一次，彻底解决Java的值传递和引用传递","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://suiyia.github.io/categories/Java基础/"}],"tags":[]},{"title":"Redis 简单介绍与 Jedis 常用操作","slug":"Redis简单介绍与Jedis常用操作","date":"2019-02-18T13:02:00.000Z","updated":"2019-08-10T09:51:13.097Z","comments":true,"path":"2019/02/18/Redis简单介绍与Jedis常用操作/","link":"","permalink":"http://suiyia.github.io/2019/02/18/Redis简单介绍与Jedis常用操作/","excerpt":"","text":"介绍Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。主要对 Redis 中文网 文档内容进行总结，并使用 Jedis 实现一些基本操作。使用 Jedis 实现 Redis 基本操作Jedis 是一个小而精的 Redis 客户端，用 Java 实现strings 操作123456789String result = jedis.set(\"name\",\"chx\"); // 添加 String ，result = \"OK\"result = jedis.mset(\"name\", \"chenhaoxiang\", \"age\", \"20\", \"email\", \"chxpostbox@outlook.com\"); // 同时设置多个键值对 result = \"OK\"Boolean exists = jedis.exists(\"name\"); // 是否存在 key=user 的记录result = jedis.get(\"name\"); // 获取数据，result = \"chx\"Long appendres = jedis.append(\"name\", \" is my name;\"); // 拼接，appendres = 15，拼接后字符串长度Long delres = jedis.del(\"name\"); //删除某个键值对， delres = 1//键对应 value 的自增操作，具备原子性，如果键包含错误类型的值或包含无法表示为整数的字符串，则会返回错误。此操作限于64位有符号整数。ERR value is not an integer or out of range//如果键不存在，则在执行操作之前将其设置为0。如果 age 不存在，操作后 age = 1；Long incrres = jedis.incr(\"age\"); // 用于将键的整数值递增1。 incrres = 21，递增后的值。lists 操作123456Long res1 = jedis.lpush(\"list\",\"1\"); // 头部插入一个元素，res1 = 1res1 = jedis.lpush(\"list\",\"2\"); // res1 = 2res1 = jedis.lpush(\"list\",\"3\"); // res1 = 3 返回该 List 的长度jedis.rpush(\"list\",\"5\"); // 尾部插入元素Long llen = jedis.llen(\"list\"); // List 长度，llen = 4List&lt;String&gt; list3 = jedis.lrange(\"list\",0,-1); // list3 = [3,2,1,5] 按范围取出,第一个是key，第二个是起始位置，第三个是结束位置sets 操作123456789res1 = jedis.sadd(\"set\",\"1\");res1 = jedis.sadd(\"set\",\"2\");res1 = jedis.sadd(\"set\",\"3\"); // 添加Long srem = jedis.srem(\"set\",\"2\"); // 移除某个元素Set&lt;String&gt; set1 = jedis.smembers(\"set\"); // 获取 key=set 的 SetBoolean sismember = jedis.sismember(\"set\",\"1\"); // key=set 的 Set 中是否存在元素 \"1\"String srandmember = jedis.srandmember(\"set\"); // 随机返回一个 set 元素List&lt;String&gt; list4 = jedis.srandmember(\"set\",2); // 随机返回指定个数个元素Long scar = jedis.scard(\"set\"); // set 的元素个数sorted sets 操作( TODO 用到再更新)123jedis.zadd(\"zset\",1,\"1\");jedis.zadd(\"zset\",2.0,\"2\");jedis.zadd(\"zset\",3,\"3\");Hashes 操作12345678910111213141516Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();map.put(\"name\", \"chx\");map.put(\"age\", \"100\");map.put(\"email\", \"***@outlook.com\");result = jedis.hmset(\"user\", map); // 添加 Map，result = \"OK\"String res = jedis.hget(\"user\",\"age\"); // 获取 Map 指定 key 的 value，只能获取单个 key，res = 100List&lt;String&gt; list = jedis.hmget(\"user\", \"name\", \"age\", \"email\"); // 获取 Map 指定 key 的 value，同时指定多个 key，list = [chx, 100, ***@outlook.com];Long hdel = jedis.hdel(\"user\", \"age\"); //删除 map 中的某个键值，hdel = 1Long hlen = jedis.hlen(\"user\"); // 获取 map 中的键值对个数，hlen = 2Set&lt;String&gt; set = jedis.hkeys(\"user\"); // 返回 map 中的所有 keyIterator&lt;String&gt; iterator = jedis.hkeys(\"user\").iterator(); // 迭代遍历while (iterator.hasNext())&#123; String key = iterator.next(); String value = jedis.hmget(\"user\",key).get(0);&#125;List&lt;String&gt; list2 = jedis.hvals(\"user\"); // 返回 map 中的所有 valueRedis 其它名词expire 过期Redis 允许为每一个 key 设置不同的过期时间，当它们到期时将自动从服务器上删除。主动删除：client 主动访问，发现过期，立即删除被动删除：Redis 定时随机选择一些 key 进行检测，删除过期的 key，如果删除比例高于 25%，则继续选择一些 key 进行删除管道(Pipelining)Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。发送一个命令之后只有等待服务器返回之后才会执行后续命令。管道则可以一次发送多条命令而不必立即等待服务器返回，收到命令之后，服务器会以队列形式回复命令，管道操作比较耗内存，要注意命令的大小。12345Pipeline pipeline = jedis.pipelined();for (int i = 0; i &lt; 100; i++) &#123; pipeline.set(\"1\",\"1\");&#125;pipeline.sync();Redis学习笔记7–Redis管道（pipeline）分布式缓存Redis之Pipeline（管道）事务将一组 Redis 命令放到事务中执行，MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。123456String watch = jedis.watch(\"123\");Transaction multi = jedis.multi();multi.set(\"123\",\"123\");List&lt;Object&gt; list1 = multi.exec();multi.discard();jedis.unwatch();multi 用于开启一个事务，exec 执行事务，watch 用于监测事务中 key 的变化，如果 key 被其它客户端改过了，那么整个事务会被取消，discard 用于取消事务总结这个总结主要是了解下 Jedis 常用操作。具体细节学习需要文档、项目结合学习。博客参考：【Redis】Java中使用Jedis操作Redis(Maven导入包)、创建Redis连接池","categories":[{"name":"Redis","slug":"Redis","permalink":"http://suiyia.github.io/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://suiyia.github.io/tags/Redis/"}]},{"title":"Java 常用加密算法实现","slug":"Java-常用加密算法实现","date":"2019-01-27T09:23:00.000Z","updated":"2019-08-10T02:01:15.013Z","comments":true,"path":"2019/01/27/Java-常用加密算法实现/","link":"","permalink":"http://suiyia.github.io/2019/01/27/Java-常用加密算法实现/","excerpt":"","text":"[toc]常用加密算法 Java 实现算法种类单向加密对称加密非对称加密1. 单向加密Base64，Base64 编码是从二进制到字符的过程，用 64 个字符来表示任意的二进制数据，常用于在 HTTP 加密，图片编码传输等。Java 8 内置实现1234567891011121314151617181920package com.cn.singleway;import java.io.UnsupportedEncodingException;import java.util.Base64;public class Base64Demo &#123; public static void main(String[] args) &#123; try &#123; // 编码 String encode = Base64.getEncoder().encodeToString(\"testBase64\".getBytes(\"UTF-8\")); System.out.println(encode); // 解码 byte[] decode = Base64.getDecoder().decode(\"dGVzdEJhc2U2NA==\"); System.out.println(new String(decode, \"UTF-8\")); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125;&#125;JDK 1.8 之下，引入第三方 jar 包1234567891011121314151617181920212223242526package com.cn.singleway;import org.apache.commons.codec.binary.Base64;import java.io.UnsupportedEncodingException;public class Base64Demo2 &#123; public static void main(String[] args) &#123; try &#123; String encodeBase64String = Base64.encodeBase64String(\"test\".getBytes(\"UTF-8\")); System.out.println(encodeBase64String); byte[] decodeString = Base64.decodeBase64(encodeBase64String); System.out.println(new String(decodeString,\"UTF-8\")); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125;&#125; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.11&lt;/version&gt; &lt;/dependency&gt;MD5，Message Digest algorithm 5，信息摘要算法，一般用于确保信息的传输完整一致性，校验传输的数据是否被修改，一旦原始信息被修改，生成的 MD5 值将会变得很不同1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.cn.singleway;import java.io.UnsupportedEncodingException;import java.math.BigInteger;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MD5Demo &#123; public static void test1(String s)&#123; try &#123; MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\"); byte[] after = messageDigest.digest(s.getBytes(\"UTF-8\")); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; after.length; i++) &#123; if ((0xff &amp; after[i]) &lt; 0x10) &#123; stringBuilder.append(\"0\" + Integer.toHexString((0xFF &amp; after[i]))); &#125; else &#123; stringBuilder.append(Integer.toHexString(0xFF &amp; after[i])); &#125; &#125; System.out.println(stringBuilder.toString()); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; public static void test2(String s)&#123; try &#123; // 生成一个MD5加密计算摘要 MessageDigest md = MessageDigest.getInstance(\"MD5\"); // 计算md5函数 md.update(s.getBytes()); // digest()最后确定返回md5 hash值，返回值为8为字符串。因为md5 hash值是16位的hex值，实际上就是8位的字符 // BigInteger函数则将8位的字符串转换成16位hex值，用字符串来表示；得到字符串形式的hash值 System.out.println(new BigInteger(1, md.digest()).toString(16)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; String s = \"this is MD5 test demo\"; test1(s); test2(s); &#125;&#125;SHA 家族，是一个密码散列函数家族，是 FIPS 所认证的安全散列算法，和 MD5 类似，都是对文本进行散列，产生一定长度的散列值SHA1 与 SHA212HMACHash Message Authentication Code，散列消息鉴别码，HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。122. 对称加密对称加密的意思就是信息收发都有相同的一把钥匙，消息的加密解密都用这进行DES，Data Encryption Standard，数据加密标准，速度较快，适用于加密大量数据的场合。DES算法提供CBC, OFB, CFB, ECB四种模式，MAC是基于ECB实现的。AESAdvanced Encryption Standard，高级加密标准，是下一代的加密算法标准，速度快，安全级别高；3. 非对称加密非对称加密算法是一种密钥的保密方法。 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。RSA，名称来源于发明这个算法的三个人的姓氏组成，算法大致内容就是对极大整数进行因式分解。这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长 RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.htmlDSA，Digital Signature Algorithm，数字签名算法，是一种标准的 DSS（数字签名标准）；ECC，Elliptic Curves Cryptography，椭圆曲线密码编码学。一种建立公开密钥加密的算法，基于椭圆曲线数学。ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。ECC的另一个优势是可以定义群之间的双线性映射，基于Weil对或是Tate对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。不过一个缺点是加密和解密操作的实现比其他机制花费的时间长。Base64MD5 和 SHA 家族12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; String content = \"you are my son\"; // 原文 try &#123; byte[] a; MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-1\"); a = messageDigest.digest(content.getBytes()); System.out.println(byte2hex(a)); // 333a9634d8809b5a9e8d280d82553b8fd8d4a911 messageDigest = MessageDigest.getInstance(\"SHA-256\"); a = messageDigest.digest(content.getBytes()); System.out.println(byte2hex(a)); // cdb2c97079d9a1943eea98de4201f5c4f49ecda5af2b364e1c7a5d1ae89688eb messageDigest = MessageDigest.getInstance(\"MD5\"); a = messageDigest.digest(content.getBytes()); System.out.println(byte2hex(a)); // 6fe6b9a8f8bd29f4f4f1368a0619a7ae // 第三方 MD5 算法。需要添加 jar 包 org.apache.commons.codec.digest.DigestUtils String encodeStr=DigestUtils.md5Hex(content); System.out.println(encodeStr); // 6fe6b9a8f8bd29f4f4f1368a0619a7ae &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125;&#125;public static String byte2hex(byte[] b) //二进制转字符串&#123; String hs = \"\"; String stmp = \"\"; for (int n = 0; n &lt; b.length; n++) &#123; stmp = (java.lang.Integer.toHexString(b[n] &amp; 0XFF)); if (stmp.length() == 1) &#123; hs = hs + \"0\" + stmp; &#125; else &#123; hs = hs + stmp; &#125; &#125; return hs;&#125;总结现在的加密算法大部分情况下是为了验证数据的一致性，例如传递一些参数组的时候，简单的会使用 BASE64 或 MD5 进行加密生成一个签名。复杂点就是 BASE64 编码之后再用 对称密钥再加密一次，达到比较不容易被人篡改的目的对于一些支付场景，一般使用 非对称加密算法 实现，这样的场景需要的安全性更高。其它博客参考java加解密之RSA使用","categories":[{"name":"Java 核心","slug":"Java-核心","permalink":"http://suiyia.github.io/categories/Java-核心/"}],"tags":[{"name":"加密算法","slug":"加密算法","permalink":"http://suiyia.github.io/tags/加密算法/"}]},{"title":"展望 2019 ！","slug":"展望-2019","date":"2019-01-02T14:28:00.000Z","updated":"2019-04-07T13:32:54.458Z","comments":true,"path":"2019/01/02/展望-2019/","link":"","permalink":"http://suiyia.github.io/2019/01/02/展望-2019/","excerpt":"","text":"回首 2018，毕业、入职，名校光环不再，浪潮褪去，原来我一直在裸泳。作为已经工作半年的「职场新人」，仍有许多的不足和需要学习的地方。激情是年轻人应该拥有的东西，没有梦想，和咸鱼一样，我不甘心！制定好目标，坚持的执行下去，总会有好的结果。坚持看书，每天花一个小时看书。自己思考、总结，把书中的想法总结出来，提升了思维也锻炼了写作能力。坚持写博客，从公司项目中了解框架，既熟悉了业务，也运用得了框架，这应该是头两年需要技术积累的东西。坚持锻炼，体重控制在 130 斤应该是最完美的体重，向这个目标进军，现在 140 斤。自己需要注意的地方：聆听的方式。别人与自己说话，学会聆听，学会体会别人话中表现的含义，不轻易打断别人，有时候还需要委婉地表达自己的想法。注意社交，一个人闷着屋里，并不会造出什么轮子，随时了解外面发生的事，多个周围的同事交流，结交更多的朋友，体会不同人的想法、见解，开拓自己的视野。唯一愿望：找一个可以一起吃饭、一起看电影、一起出去玩的女朋友。结语：人生就像一场马拉松，起步快的人，往往能提前看到美丽的风景，坚持久的人，必将得到丰厚的硕果，加油 2019 ！","categories":[],"tags":[]}]}