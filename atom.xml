<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸟日常</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suiyia.github.io/"/>
  <updated>2019-12-12T07:38:35.331Z</updated>
  <id>http://suiyia.github.io/</id>
  
  <author>
    <name>Answer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 异常全面学习</title>
    <link href="http://suiyia.github.io/2019/12/10/Java-%E5%BC%82%E5%B8%B8%E5%85%A8%E9%9D%A2%E5%AD%A6%E4%B9%A0/"/>
    <id>http://suiyia.github.io/2019/12/10/Java-异常全面学习/</id>
    <published>2019-12-10T11:52:00.000Z</published>
    <updated>2019-12-12T07:38:35.331Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><h1 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h1><p><img src="/images\异常类型.png" alt="upload successful"></p><p>Error：表示不希望被程序捕获或者是程序无法处理的错误，Error 类对象由 Java 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。</p><p>Checked Exception：受检查异常，需要 try catch 捕获或者 throws 抛出；如果不处理，程序编译将不会通过。</p><p>Runtime Exception（Unchecked Exception）：运行时异常，由程序逻辑错误引起，程序应该尽可能的避免该类异常。</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常发生时，有两种处理方式：捕获、抛出</p><p>捕获：try catch</p><p>抛出：</p><ul><li><p>方法名上面抛出 throws，若方法内不抛出任何异常，也能通过编译。</p></li><li><p>方法内抛出 throw</p></li></ul><h1 id="异常抛出限制"><a href="#异常抛出限制" class="headerlink" title="异常抛出限制"></a>异常抛出限制</h1><ul><li>父类的方法没有声明异常，子类在重写该方法的时候不能声明异常；</li></ul><ul><li>子类重写父类抛出的异常方法时，可以抛出或者不抛出异常；若抛出异常，子类抛出的异常类型必须与父类方法抛出异常类型相同，或者子类抛出的异常类型是父类方法抛出异常的子类。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">错误抛出情况：子类抛出的 IOException 和 RuntimeException 不是同类型，也不是其子类。</span><br><span class="line"></span><br><span class="line">public class C &#123;</span><br><span class="line">    public void fun() throws RuntimeException&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class D extends C &#123;</span><br><span class="line">    public void fun() throws IOException,RuntimeException&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果父类抛出了 CheckedException ，那么子类重写的方法可以抛出 RuntimeException</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">正确的抛出情况：</span><br><span class="line">public class A &#123;</span><br><span class="line">    public void fun() throws IOException &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class B extends A &#123;</span><br><span class="line">    public void fun() throws IOException,RuntimeException&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>所有异常都必须是 Throwable 的子类。</p><p>如果希望写一个检查性异常类，则需要继承 Exception 类。</p><p>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</p><h1 id="异常捕获流程"><a href="#异常捕获流程" class="headerlink" title="异常捕获流程"></a>异常捕获流程</h1><p>1、try{} 里有一个 return 语句，那么紧跟在这个 try 后的 finally{} 里的 code 会不会被执行，什么时候被执行，在 return 前还是后?</p><p>答案：会执行，在方法返回调用者前执行。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;异常类型&quot;&gt;&lt;a href=&quot;#异常类型&quot; class=&quot;headerlink&quot; title=&quot;异常类型&quot;&gt;&lt;/a&gt;异常类型&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="Java 基础" scheme="http://suiyia.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型</title>
    <link href="http://suiyia.github.io/2019/12/10/Java-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://suiyia.github.io/2019/12/10/Java-泛型/</id>
    <published>2019-12-10T11:46:00.000Z</published>
    <updated>2019-12-12T07:37:27.752Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><h1 id="泛型产生场景"><a href="#泛型产生场景" class="headerlink" title="泛型产生场景"></a>泛型产生场景</h1><p>开发一个能够存储各种对象的容器，如果用 Object 进行存储，显示转换的时候可能出现异常。</p><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>定义 List<string>list = new ArrayList()，那么 list 只能添加 String 类型的元素</string></p><h1 id="泛型使用场景"><a href="#泛型使用场景" class="headerlink" title="泛型使用场景"></a>泛型使用场景</h1><ul><li>泛型类</li></ul><p>类后面添加类型参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持多个类型参数<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class MultiGenericContainer&lt;T, S&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>泛型接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">    public T next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FruitGenerator implements Generator&lt;String&gt; &#123;</span><br><span class="line">    private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;</span><br><span class="line">    @Override</span><br><span class="line">    public String next() &#123;</span><br><span class="line">        Random rand = new Random();</span><br><span class="line">        return fruits[rand.nextInt(3)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>泛型方法</li></ul><p>方法调用时可以接收不同类型的参数，编译期根据不同的参数类型进行对应处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static &lt; E &gt; void printArray( E[] inputArray )&#123;</span><br><span class="line">    // 输出数组元素            </span><br><span class="line">    for ( E element : inputArray )&#123;        </span><br><span class="line">        System.out.printf( &quot;%s &quot;, element );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h1><ul><li><p>限定通配符：</p><ul><li>E：元素</li><li>K：键</li><li>N：数字</li><li>T：类型</li><li>V：值</li><li>S、U、V 等：多参数情况中的第 2、3、4 个类型</li></ul></li><li><p>非限定通配符： ?</p><p>某些情况下，编写指定未知类型的代码很有用。问号 (?) 通配符可用于使用泛型代码表示未知类型。通配符可用于参数、字段、局部变量和返回类型。但最好不要在返回类型中使用通配符，因为确切知道方法返回的类型更安全。</p></li></ul><h1 id="泛型通配符使用注意"><a href="#泛型通配符使用注意" class="headerlink" title="泛型通配符使用注意"></a>泛型通配符使用注意</h1><p>将指定的泛型类型控制为指定的类型，需要使用上下界限定符 extends 和 super</p><p>&lt; T extends UpperBoundType&gt; list：list 中元素类型必须是 UpperBoundType 类或者是 UpperBoundType 的子类</p><p>&lt; T super LowerBoundType&gt; list：list 中元素类型必须是 LowerBoundType 或者是 LowerBoundType 的父类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class Fruit&#123;&#125;</span><br><span class="line">Class Apple extends Fruit&#123;&#125;</span><br><span class="line">Class Orange extends Fruit&#123;&#125;</span><br><span class="line">public class Plate&lt;T&gt; &#123;</span><br><span class="line">    private List&lt;T&gt; list;</span><br><span class="line">    public Plate()&#123;&#125; </span><br><span class="line">    public void add(T item)&#123;list.add(item);&#125;</span><br><span class="line">    public T get()&#123;return list.get(0);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Java 并不支持泛型的向上转型，下面写法将不会通过编译</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;Fruit&gt; plate = new Plate&lt;Apple&gt;();  //Error</span><br></pre></td></tr></table></figure><p>下面写法可以通过编译，即 plate 可以指向 Fruit 类的对象或者 Fruit 子类对象<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? extends Fruit&gt; plate = new Plate&lt;Apple&gt;();</span><br></pre></td></tr></table></figure><p></p><ol start="2"><li>extends 只能读取对象，不能添加对象</li></ol><p>因为 plate 指向 Fruit 类的对象或者 Fruit 子类对象，但是 <strong>Fruit 的子类不一定只有 Apple，还有可能是 Orange</strong> ，添加的元素不能确定是哪种具体类型。</p><p>但是 get 的时候，可以知道 get 到的元素都可以转为 Fruit 类型，所以可以读取对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? extends Fruit&gt; plate = new Plate&lt;Apple&gt;();</span><br><span class="line">plate.add(new Apple()); // Compile Error</span><br><span class="line"></span><br><span class="line">Apple apple = plate.get();  // Compile Error</span><br><span class="line">Fruit apple = plate.get(); // SUCCESS</span><br></pre></td></tr></table></figure><ol start="3"><li>super 只能添加对象，不能读取对象</li></ol><p>plate 指向 Apple 类的对象或者 Apple 父类的对象，Fruit 是 Apple 的父类，所以添加对象是可行的。</p><p>但是 get 的时候，不清楚 get 到的元素具体类型，有可能是 Apple 有可能是 Fruit，<strong>更有可能是 Fruit 的父类</strong>，只能使用 Object 去 get ，才能编译不报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? super Apple&gt; plate = new Plate&lt;Fruit&gt;();</span><br><span class="line">plate.add(new Apple()); // SUCCESS</span><br><span class="line">plate.add(new Fruit()); // Compile Error</span><br><span class="line"></span><br><span class="line">Apple apple = plate.get();  // Compile Error</span><br><span class="line">Fruit fruit = plate.get();  // Compile Error</span><br><span class="line">Object object = plate.get(); // SUCCESS</span><br></pre></td></tr></table></figure><h1 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; b = new ArrayList&lt;Integer&gt;();</span><br><span class="line">Class c1 = a.getClass();</span><br><span class="line">Class c2 = b.getClass();</span><br><span class="line">System.out.println(c1 == c2); </span><br><span class="line"></span><br><span class="line">程序输出： true</span><br></pre></td></tr></table></figure><p>泛型只存在于编译阶段，在编译阶段会进行泛型检查，检查元素是否满足类型要求，不满足时编译将不通过；</p><p>在编译后的 class 文件中，进行了泛型擦除，c1，c2 都是 ArrayList.class，不存在泛型概念。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/chanshuyi/p/deep_insight_java_generic.html" target="_blank" rel="noopener">大白话说Java泛型：入门、使用、原理</a></p><p><a href="https://juejin.im/post/5b614848e51d45355d51f792#heading-0" target="_blank" rel="noopener">深入理解Java泛型</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;泛型产生场景&quot;&gt;&lt;a href=&quot;#泛型产生场景&quot; class=&quot;headerlink&quot; title=&quot;泛型产生场景&quot;&gt;&lt;/a&gt;泛型产
      
    
    </summary>
    
      <category term="Java 基础" scheme="http://suiyia.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 序列化</title>
    <link href="http://suiyia.github.io/2019/12/10/Java-%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://suiyia.github.io/2019/12/10/Java-序列化/</id>
    <published>2019-12-10T07:43:00.000Z</published>
    <updated>2019-12-10T10:08:10.103Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li><p>什么是序列化与反序列化</p><p>序列化：将对象转换为字节序列，保存着对象的类型信息、对象的数据，对象中的数据类型</p><p>反序列化：将字节序列转换为对象</p></li><li><p>为什么序列化</p><p>将对象转换为字节序列后，对象可以保存在磁盘上、或者通过网络传输传到另外的程序中，序列化机制使得对象可以脱离程序的运行而独立存在。</p></li><li><p>序列化使用场景</p><p>实体类实现 Serializable 或者 Externalizable 接口，表明该类的实例可以序列化</p><p>所有可在网络上传输的对象都必须是可序列化的，比如 RMI（remote method invoke, 即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错。</p><p>所有需要保存到磁盘的 Java 对象都必须是可序列化的。</p></li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul><li>序列化</li></ul><p>创建 ObjectOutputStream 输出流，调用 ObjectOutputStream.writeObject() 方法</p><p>被 transient 修饰的成员变量将不会被序列化，反序列化之后得到的属性都是默认值</p><p>序列化保存的是对象的状态，静态变量属于类的状态，因此序列化并不保存静态变量。</p><ul><li>反序列化</li></ul><p>创建 ObjectInputStream 输入流，调用 ObjectInputStream.readObject() 方法</p><p>当 readObject() 找不到反序列化的类时，会抛出 ClassNotFoundException 。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><ul><li><p>序列化存储规则</p><p>同一个文件，写入同一个对象两次，第二次只会存储上一次写入的引用</p></li><li><p><a href="https://www.hollischuang.com/archives/1144" target="_blank" rel="noopener">单例与序列化的那些事儿</a></p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.hollischuang.com/archives/1140" target="_blank" rel="noopener">深入分析Java的序列化与反序列化</a></p><p><a href="https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf" target="_blank" rel="noopener">java序列化，看这篇就够了</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html" target="_blank" rel="noopener">Java 序列化的高级认识</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;
      
    
    </summary>
    
    
      <category term="Java 基础" scheme="http://suiyia.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
      <category term="序列化" scheme="http://suiyia.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>代理模式以及 Spring 中的代理实现</title>
    <link href="http://suiyia.github.io/2019/12/04/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A-Spring-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0/"/>
    <id>http://suiyia.github.io/2019/12/04/代理模式以及-Spring-中的代理实现/</id>
    <published>2019-12-04T12:11:00.000Z</published>
    <updated>2019-12-11T01:35:04.712Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li>什么是代理模式</li><li>静态代理</li><li>JDK 自带的动态代理</li><li>CGLIB 动态代理</li><li>Spring 中用到的代理</li></ul><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>意图：为其他对象提供一种代理，以控制对这个对象的访问。</p><p>例子：买火车票不一定要在火车站，去网上各个代理商那里也可以</p><p>代码思路：实体类 A 实现了接口 IA，而实体类 A 很复杂，那么使用实体类 B 去实现接口 IA，通过实体类 B 调用实体类 A 去满足功能。</p><p><strong>注意事项：</strong></p><p>1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</p><p>2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p><p><img src="/images\代理模式示例图.png" alt="upload successful"></p><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>静态代理其实就是在程序运行之前，提前写好被代理方法的代理类，编译后运行。</p><p>下面代理模式实现需要写很多代码，不建议使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 接口 A</span><br><span class="line">public interface IServiceA &#123;</span><br><span class="line">    void sayHello(String str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ServiceAImpl 实现接口 A</span><br><span class="line">public class ServiceAImpl implements IServiceA &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello(String str) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代理对象 ServiceProxyAImpl 也实现接口 A，并且构造函数必须传入接口 A 的实例</span><br><span class="line">public class ServiceProxyAImpl implements IServiceA &#123;</span><br><span class="line">    private IServiceA iServiceA;</span><br><span class="line">    public ServiceProxyAImpl(IServiceA iServiceA) &#123;</span><br><span class="line">        this.iServiceA = iServiceA;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello(String str) &#123;</span><br><span class="line">        iServiceA.sayHello(str+ &quot; is proxy &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 进行测试</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IServiceA realA = new ServiceAImpl();</span><br><span class="line">        // 传入真实对象</span><br><span class="line">        IServiceA proxyA = new ServiceProxyAImpl(realA);</span><br><span class="line">        realA.sayHello(&quot;realA&quot;);</span><br><span class="line">        // 代理对象的调用</span><br><span class="line">        proxyA.sayHello(&quot;proxyA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序输出 :</span><br><span class="line">ServiceAImpl sayrealA</span><br><span class="line">ServiceAImpl sayproxyA is proxy</span><br></pre></td></tr></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>通过反射机制，在运行时生成代理类</p><h2 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h2><p><strong>被代理的类需要是接口实现</strong></p><ol><li>java.lang.reflect.Proxy：生成动态代理类和对象；</li><li>java.lang.reflect.InvocationHandler：通过 invoke 方法实现对真实角色的代理访问。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 接口 A</span><br><span class="line">public interface IServiceA &#123;</span><br><span class="line">    void sayHello(String str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ServiceAImpl 实现接口 A</span><br><span class="line">public class ServiceAImpl implements IServiceA &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello(String str) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProxyHandler implements InvocationHandler &#123;</span><br><span class="line">    private IServiceA serviceA;</span><br><span class="line">    public ProxyHandler(IServiceA serviceA) &#123;</span><br><span class="line">        this.serviceA = serviceA;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        return method.invoke(serviceA, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MainProxy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    // 真实对象</span><br><span class="line">        IServiceA serviceA = new ServiceAImpl();</span><br><span class="line">        // 通过 Proxy 得到代理对象</span><br><span class="line">        IServiceA proxyServiceA = (IServiceA) Proxy</span><br><span class="line">            .newProxyInstance(serviceA.getClass().getClassLoader(), serviceA.getClass().getInterfaces(),</span><br><span class="line">                new ProxyHandler(serviceA));</span><br><span class="line">        serviceA.sayHello(&quot;serviceA&quot;);</span><br><span class="line">        proxyServiceA.sayHello(&quot;proxy serviceA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序输出：</span><br><span class="line">serviceA</span><br><span class="line">proxy serviceA</span><br></pre></td></tr></table></figure><h2 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h2><p><a href="http://ifeve.com/cglib-desc/" target="_blank" rel="noopener">CGLIB动态代理介绍</a></p><p><strong>通过改变字节码，对需要被代理的类，生成他的子类，子类去覆盖被代理类的方法</strong></p><p>private、final 修饰的方法不会被重写。</p><ol><li>首先实现 MethodInterceptor，方法调用会被转发到该类的 intercept() 方法。</li><li>通过 Enhancer 来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用 create() 方法得到代理对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 接口 A</span><br><span class="line">public interface IServiceA &#123;</span><br><span class="line">    void sayHello(String str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ServiceAImpl 实现接口 A</span><br><span class="line">public class ServiceAImpl implements IServiceA &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello(String str) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        return methodProxy.invokeSuper(o,objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CGLIBMain &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IServiceA serviceA = new ServiceAImpl();</span><br><span class="line">        serviceA.sayHello(&quot;serviceA&quot;);</span><br><span class="line"></span><br><span class="line">        Enhancer enhancer = new Enhancer(); // 字节码增强</span><br><span class="line">        enhancer.setSuperclass(ServiceAImpl.class); // 设置父类</span><br><span class="line">        enhancer.setCallback(new MyMethodInterceptor());  // 设置回调方法</span><br><span class="line">        IServiceA proxyA = (IServiceA) enhancer.create();</span><br><span class="line">        proxyA.sayHello(&quot;proxyA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序输出：</span><br><span class="line">serviceA</span><br><span class="line">proxyA</span><br></pre></td></tr></table></figure><h1 id="Spring-用到的代理"><a href="#Spring-用到的代理" class="headerlink" title="Spring 用到的代理"></a>Spring 用到的代理</h1><p>Spring AOP 其实就是代理模式实现</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://suiyia.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis 使用规范总结</title>
    <link href="http://suiyia.github.io/2019/12/03/Redis-%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/"/>
    <id>http://suiyia.github.io/2019/12/03/Redis-使用规范总结/</id>
    <published>2019-12-03T14:50:00.000Z</published>
    <updated>2019-12-03T14:51:14.196Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>总结 Redis 的规范用法</p><h1 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h1><ul><li>Redis 单机部署情况下，有 16 个「命名空间」，不同命名空间之间数据不共享，建议<strong>业务不相关</strong>的项目使用不同命名空间，集群部署忽略此条建议。</li></ul><ul><li>key、value 序列化方式</li></ul><p>RedisTemplate 包含 9 种序列化方式，默认使用 JdkSerializationRedisSerializer 序列化键值对，有时键值对会出现乱码。</p><p>建议 StringRedisSerializer，注意存入的 key、value 必须为 String 类型，否则会抛出类型转换异常。</p><p><a href="https://juejin.im/post/5d4928a451882505730cf610" target="_blank" rel="noopener">使用默认序列化 乱码问题</a></p><h1 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h1><ul><li><p>必须</p><ul><li><p>由小写字母、数字、英文点号、英文半角冒号组成，必须英文字母开头</p></li><li><p>格式：业务名、表名做前缀，冒号分隔，比如 mobileserver:userfreepasswordinfo:freepasswordtype</p></li><li><p>控制 key 长度，不该使用过长或含义不清的名称，上面可使用 mobileserver:userfreewd:freewdtype</p></li><li><p>不包含特殊字符：空格、换行、单双引号、下划线以及其他转义字符</p></li><li><p><strong>设置过期时间</strong></p></li><li><p>设置最大内存及最大内存淘汰策略（maxmemory-policy）参数。</p></li><li><p>客户端使用连接池</p></li></ul></li><li><p>禁止</p><ul><li><p><strong>禁止命令</strong>：keys、flushall、flushdb、CONFIG</p></li><li><p><strong>禁止 Big Key</strong>。如果 1MB 的 key 每秒重复写入 10 次，就会导致写入网络 IO 达 10MB。非字符串的 bigkey，<strong>不要使用 del 删除，使用 hscan、sscan、zscan 方式渐进式删除</strong>，同时要注意防止 bigkey 过期时间自动删除问题（例如一个 200 万的 zset 设置1小时过期，会触发 del 操作，造成阻塞）。</p></li></ul></li><li><p>建议</p><ul><li><p>所有 key 命名在同一个实体类中定义，方便管理，比如：RedisConstant.java</p></li><li><p>hash、list、set、zset 元素个数不要超过 5000</p></li><li><p>使用合适的数据类型。常见的如：String 可以用作普通的 K-V、计数类；Hash 可以用作对象如商品、经纪人等，包含较多属性的信息；List 可以用作消息队列、粉丝/关注列表等；Set 可以用于推荐；SortedSet 可以用于排行榜等。</p></li><li><p>冷热数据分离，使用不频繁的用 MySQL 代替</p></li><li><p>必须要存储的大文本数据应该压缩后存储</p></li><li><p>高并发下建议客户端添加熔断功能(例如 netflix、hystrix)</p></li><li><p>不建议过多使用 Redis 事务功能，它不支持回滚</p></li></ul></li></ul><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li><p>Redis 键过期策略</p><ul><li><p>volatile-lru：<strong>默认策略</strong>，即超过最大内存后，在过期键中使用 LRU 算法进行key 的剔除，保证不过期数据不被删除，但是可能会出现 OOM 问题。</p></li><li><p>allkeys-lru：根据 LRU 算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</p></li><li><p>allkeys-random：随机删除所有键，直到腾出足够空间为止。</p></li><li><p>volatile-random:随机删除过期键，直到腾出足够空间为止。</p></li><li><p>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</p></li><li><p>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</p></li></ul></li></ul><ul><li><p><a href="https://database.51cto.com/art/201910/605020.htm" target="_blank" rel="noopener">Redis 为什么默认 16 个数据库？</a></p></li><li><p><a href="https://blog.csdn.net/qq_30242609/article/details/71024458" target="_blank" rel="noopener">基于 Redis 的布隆过滤器的实现</a></p></li><li><p><a href="http://redisdoc.com/topic/persistence.html" target="_blank" rel="noopener">Redis 持久化</a></p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p><a href="https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px" target="_blank" rel="noopener">阿里云 Redis 开发规范</a></p></li><li><p><a href="https://www.redis.net.cn/" target="_blank" rel="noopener">Redis 中文网</a></p></li><li><p><a href="https://www.w3cschool.cn/redis_all_about/" target="_blank" rel="noopener">Redis 开发运维实践指南</a></p></li><li><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/Redis/Redis.md" target="_blank" rel="noopener">Redis 总结</a></p></li><li><p><a href="https://www.yuque.com/tangjiasanshu/tech/hpquel?language=en-us" target="_blank" rel="noopener">redis使用规范</a></p></li></ul><h1 id="模板方法（TODO）"><a href="#模板方法（TODO）" class="headerlink" title="模板方法（TODO）"></a>模板方法（TODO）</h1><p><a href="https://github.com/whvcse/RedisUtil" target="_blank" rel="noopener">RedisUtils.java</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;总结 Re
      
    
    </summary>
    
      <category term="Redis" scheme="http://suiyia.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://suiyia.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java IO 基本概念</title>
    <link href="http://suiyia.github.io/2019/11/20/Java-IO-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://suiyia.github.io/2019/11/20/Java-IO-基本概念/</id>
    <published>2019-11-20T14:33:00.000Z</published>
    <updated>2019-12-04T12:02:51.071Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li>IO 分类</li><li>同步、异步、阻塞、非阻塞理解</li><li>BIO、NIO、AIO 介绍</li><li>Linux 5 种 IO 模型</li></ul><h1 id="IO-分类"><a href="#IO-分类" class="headerlink" title="IO 分类"></a>IO 分类</h1><ul><li>按传输数据方式：</li></ul><p>字节流：以 byte 为基本单位进行，XXXStream 表示字节流</p><p>字符流：以字符为基本单位，字符又根据编码方式不同，一个字符对应不同大小的 byte。XXXReader、xxxWriter 表示字符流相关类</p><p>字节流可以处理任何类型的数据，如图片，视频等；字符流只能处理字符类型的数据。</p><ul><li>按输入输出方向：</li></ul><p>输入流（InXXX）、输出流（OutXXX）</p><h1 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h1><p>调用者是否<strong>主动等待</strong>调用的返回结果，</p><p>同步和异步关注的是消息通信机制，即消息是怎么返回的，是直接返回还是通过回调返回。</p><p>同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。</p><h1 id="阻塞、非阻塞"><a href="#阻塞、非阻塞" class="headerlink" title="阻塞、非阻塞"></a>阻塞、非阻塞</h1><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的<strong>状态</strong>.</p><p>阻塞调用是指调用结果返回之前，当前线程会被<strong>挂起</strong>，不能执行其它业务。调用线程只有在得到结果之后才会返回。</p><p>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p>你妈妈让你烧水，小时候你比较笨啊，在那里傻等着水开（<strong>同步阻塞</strong>）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（<strong>同步非阻塞</strong>）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（<strong>异步非阻塞</strong>）。</p><p><a href="https://www.jianshu.com/p/aed6067eeac9" target="_blank" rel="noopener">聊聊同步、异步、阻塞与非阻塞</a></p><h1 id="IO-类"><a href="#IO-类" class="headerlink" title="IO 类"></a>IO 类</h1><p><img src="/images\io种类.png" alt="upload successful"></p><h1 id="BIO、NIO-和-AIO-的区别"><a href="#BIO、NIO-和-AIO-的区别" class="headerlink" title="BIO、NIO 和 AIO 的区别"></a>BIO、NIO 和 AIO 的区别</h1><ul><li><p>BIO 就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</p></li><li><p>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</p></li><li><p>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p></li></ul><h1 id="Linux-5-种-IO-模型"><a href="#Linux-5-种-IO-模型" class="headerlink" title="Linux 5 种 IO 模型"></a>Linux 5 种 IO 模型</h1><p>Linux IO 模型中，会经历数据准备（等待数据到达并赋值到内核缓冲区），数据处理（从内核拷贝到进程）两个阶段l</p><ul><li>Blocking IO 同步阻塞</li></ul><p>进程阻塞在等待数据和处理数据阶段，啥也不干</p><p><img src="/images\BlockIO.png" alt="upload successful"></p><ul><li>NoBlocking IO 同步非阻塞</li></ul><p>进程轮询等待数据过程，若轮询时数据还没准备好，可以做其它事，当数据准备好之后，就阻塞在处理数据阶段，直至返回</p><p><img src="/images\noblockingIO.png" alt="upload successful"></p><ul><li>IO Multiplexing 多路复用</li></ul><p>内核每次<strong>轮询多个</strong>进程的等待数据过程，有一个准备好了，就执行后面的数据处理过程</p><p><img src="/images\io_multiplexing.png" alt="upload successful"></p><ul><li>Signal-Driven IO 信号驱动</li></ul><p>数据准备好时，进程收到信号，然后进程进行下一步的数据处理</p><p><img src="/images\signaldriven.png" alt="upload successful"></p><ul><li>Asynchronous IO</li></ul><p>进程在数据准备过程中处理其它事情，当数据等待和数据处理都完成之后，内核会向进程发送通知。</p><p><img src="/images\AsynchronousIO.png" alt="upload successful"></p><ul><li>五种 IO 模型比较</li></ul><p><img src="/images\五种IO模型比较.png" alt="upload successful"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;
      
    
    </summary>
    
      <category term="IO" scheme="http://suiyia.github.io/categories/IO/"/>
    
    
      <category term="IO" scheme="http://suiyia.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>排序算法——直接插入排序</title>
    <link href="http://suiyia.github.io/2019/10/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://suiyia.github.io/2019/10/31/排序算法——直接插入排序/</id>
    <published>2019-10-31T09:09:00.000Z</published>
    <updated>2019-10-31T09:18:36.940Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class 直接插入排序 &#123;</span><br><span class="line"></span><br><span class="line">    public static int[] order(int[] a)&#123;</span><br><span class="line"></span><br><span class="line">        if (a == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.length == 0 || a.length == 1)&#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">// 每次插入一个元素到合适位置</span><br><span class="line">        for (int i = 1; i &lt; a.length ; i++) &#123;</span><br><span class="line">// 将当前位置的值插入到合适地方</span><br><span class="line">            int currNum = a[i];</span><br><span class="line">            int j = i - 1;</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; a[j] &gt; currNum)&#123;</span><br><span class="line">                a[j + 1] = a[j];</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j + 1] = currNum;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a = &#123;6,3,2,9,5,3,1,0&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(order(a)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n*n)</p><p>空间复杂度：O(1)</p><blockquote><p>算法稳定性：假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！</p></blockquote><p>直接插入排序是稳定的排序算法</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;插入排序（
      
    
    </summary>
    
      <category term="算法" scheme="http://suiyia.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>RedisTemplate 使用及 Err 问题分析总结</title>
    <link href="http://suiyia.github.io/2019/10/31/RedisTemplate-%E4%BD%BF%E7%94%A8%E5%8F%8A-Err-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/"/>
    <id>http://suiyia.github.io/2019/10/31/RedisTemplate-使用及-Err-问题分析总结/</id>
    <published>2019-10-31T01:33:00.000Z</published>
    <updated>2019-10-31T08:45:31.800Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>有一个接口请求必须使用唯一 ID 进行请求，而该接口所属服务部署了多个。使用 Redistemplate 生成 dubbo 服务全局唯一 key 的时候，报了错误，并且这个错误不是 100% 复现。</p><p>提示无法将 value 进行自增，value 不是整数类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERR value is not an integer or out of range</span><br><span class="line">nested exception is redis.clients.jedis.exceptions.JedisDataException: ERR value is not an integer or out of range</span><br></pre></td></tr></table></figure><p>代码中利用 Redistemplate 生成唯一 ID 使用的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">Long uuid = redisTemplate.opsForValue().increment(REDIS_UUID,1);</span><br></pre></td></tr></table></figure><p>最终定位问题在 <strong>RedisTemplate 序列化</strong> 的问题上，程序初始化的时候没有指定 value 的序列化方式，默认序列化的 value 并非整型类型，导致获取自增唯一 ID 异常。</p><h1 id="基本配置与使用"><a href="#基本配置与使用" class="headerlink" title="基本配置与使用"></a>基本配置与使用</h1><p>先以 SpringBoot 2.2.0 项目为基础，介绍 RedisTemplate 的基础用法</p><ol><li><p>添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>参数配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.jedis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.jedis.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.jedis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.jedis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=20</span><br></pre></td></tr></table></figure></li><li><p>单元测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo;</span><br><span class="line"></span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line">import org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class DemoApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(&quot;aaa&quot;,&quot;111&quot;);</span><br><span class="line">        Assert.state(&quot;111&quot;.equals(stringRedisTemplate.opsForValue().get(&quot;aaa&quot;)),&quot;not equals&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h1><p>RedisTemplate 可以指定 key、value 的序列化方式，默认使用 JdkSerializationRedisSerializer。如果不指定键值对的序列化方式，可能会影响程序的正常运行。</p><p>RedisTemplate 可指定的序列化方式：</p><ul><li><p>JdkSerializationRedisSerializer，JDK 提供的序列化功能，需要序列化的类需要实现 Serializable 接口</p></li><li><p>StringRedisSerializer，默认使用 UTF-8 编码格式将 String 转为字节数组</p></li><li><p>Jackson2JsonRedisSerializer，使用 Jackson 将对象序列化为 JSON，初始化的时候指定对象类型</p></li><li><p>GenericToStringSerializer，使用带类型转换的方式，将 String 转为字节数组</p></li><li><p>GenericJackson2JsonRedisSerializer，使用带类型转换的方式，将对象转为 JSON</p></li><li><p>OxmSerializer，XML 序列化</p></li><li><p>ByteArrayRedisSerializer，将 Byte 数组原样保存</p></li></ul><h1 id="序列化实例"><a href="#序列化实例" class="headerlink" title="序列化实例"></a>序列化实例</h1><ul><li><p>JdkSerializationRedisSerializer，默认情况下，key，value 都是以二进制形式保存，保存的键值对不再是程序中定义好的类型。</p></li><li><p>默认情况带有很多转义前缀</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1()&#123;</span><br><span class="line">    // 默认的序列化方式</span><br><span class="line">    redisTemplate.opsForValue().set(&quot;default1&quot;,1);</span><br><span class="line">    redisTemplate.opsForValue().set(&quot;default2&quot;,&quot;1&quot;);</span><br><span class="line">    redisTemplate.opsForValue().set(&quot;default3&quot;,&quot;Answer&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images\redis默认序列化保存.png" alt="upload successful"></p><hr><ul><li>StringRedisSerializer<ul><li>key、value 必须是 String 类型，否则会抛出 ClassCastException</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();</span><br><span class="line">    // 指定 key value 为 String 序列化方式</span><br><span class="line">    redisTemplate.setKeySerializer(stringRedisSerializer);</span><br><span class="line">    redisTemplate.setValueSerializer(stringRedisSerializer);</span><br><span class="line">      redisTemplate.opsForValue().set(&quot;string1&quot;,1);   // java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">      redisTemplate.opsForValue().set(&quot;string3&quot;,&quot;Answer&quot;);</span><br><span class="line">      User user = new User(18,&quot;Answer&quot;);</span><br><span class="line">      redisTemplate.opsForValue().set(&quot;string4&quot;,user.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输出字符串</span><br><span class="line">本地:9&gt;get string3</span><br><span class="line">&quot;Answer&quot;</span><br><span class="line"></span><br><span class="line">输出对象，但是看不到属性信息</span><br><span class="line">本地:9&gt;get string4</span><br><span class="line">&quot;com.example.demo.User@5c77ba8f&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 重写 User 的 toString 方法</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">    return &quot;User&#123;&quot; +</span><br><span class="line">        &quot;age=&quot; + age +</span><br><span class="line">        &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">        &apos;&#125;&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">重写之后能看到属性信息</span><br><span class="line">本地:9&gt;get string4</span><br><span class="line">&quot;User&#123;age=18, name=&apos;Answer&apos;&#125;&quot;</span><br></pre></td></tr></table></figure><hr><ul><li>Jackson2JsonRedisSerializer，实体类不重写 toString 也能够获取对应属性信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3()&#123;</span><br><span class="line">    // 对象转 JSON 序列化方式，需要添加 jackson-databind</span><br><span class="line">    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class)</span><br><span class="line">    ObjectMapper om = new ObjectMapper();</span><br><span class="line">    final PolymorphicTypeValidator validator = BasicPolymorphicTypeValidator.builder()</span><br><span class="line">        .allowIfBaseType(Object.class)</span><br><span class="line">        .build();</span><br><span class="line">    om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">    om.activateDefaultTyping(validator,ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">      om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">    jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">    redisTemplate.setKeySerializer(StringRedisSerializer.UTF_8);</span><br><span class="line">    redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    redisTemplate.opsForValue().set(&quot;jackson1&quot;,1);</span><br><span class="line">    redisTemplate.opsForValue().set(&quot;jackson2&quot;,&quot;1&quot;);</span><br><span class="line">    redisTemplate.opsForValue().set(&quot;jackson3&quot;,&quot;Answer&quot;);</span><br><span class="line">    User user = new User(18,&quot;Answer&quot;);</span><br><span class="line">    redisTemplate.opsForValue().set(&quot;jackson4&quot;,user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String 类型 和 对象都能完整查看显示</span><br><span class="line">本地:9&gt;get jackson1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">本地:9&gt;get jackson2</span><br><span class="line">&quot;&quot;1&quot;&quot;</span><br><span class="line">本地:9&gt;get jackson3</span><br><span class="line">&quot;&quot;Answer&quot;&quot;</span><br><span class="line">本地:9&gt;get jackson4</span><br><span class="line">&quot;[&quot;com.example.demo.User&quot;,&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;Answer&quot;&#125;]&quot;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>使用 Redistemplate 时候，注意键值对的序列化方式</p></li><li><p>对象序列化建议使用 Jackson2JsonRedisSerializer，String 类型字符串使用 StringRedisSerializer</p></li></ul><p><a href="http://blog.didispace.com/springbootredis/" target="_blank" rel="noopener">Spring Boot中使用Redis数据库</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;有一个接口
      
    
    </summary>
    
      <category term="Redis" scheme="http://suiyia.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>一致性Hash算法</title>
    <link href="http://suiyia.github.io/2019/10/30/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/"/>
    <id>http://suiyia.github.io/2019/10/30/一致性Hash算法/</id>
    <published>2019-10-30T12:24:00.000Z</published>
    <updated>2019-12-26T14:36:26.935Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 22:36:32 GMT+0800 (GMT+08:00) --><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>在节点集群部署环境，需要对大量的请求进行均匀分发以达到负载均衡的请求。</p><p>如果是简单的<strong>对节点数量进行取模映射，当增删节点的时候，原有的映射结果，绝大部分会失效，拓展性太差。</strong></p><p><strong>此时就需要使用一致性 Hash 算法，减少在服务器数量变化的时候造成的数据迁移影响。</strong></p><blockquote><p>一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要 K/N 个关键字重新映射，其中 K 是关键字的数量，N 是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p></blockquote><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><img src="/images\一致性hashpng.png" alt="upload successful"></p><ol><li><p>首先求出服务器（节点）的哈希值，并将其配置到 [0, 2^32-1] 的圆上。</p></li><li><p>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</p></li><li><p>然后从数据映射到的位置开始<strong>顺时针查找</strong>，将数据保存到找到的第一个服务器上。</p></li><li><p>如果超过 2^32 仍然找不到服务器，就会保存到第一台服务器上。</p></li></ol><p>如图所示，节点 Node0，Node1，Node2 ，如果数据被映射到 Node0 至 Node2 之间，那么数据将会最终对应到 Node2 节点上。</p><h1 id="可能存在问题"><a href="#可能存在问题" class="headerlink" title="可能存在问题"></a>可能存在问题</h1><p><img src="/images\数据倾斜.png" alt="upload successful"></p><p><strong>数据倾斜</strong>：服务节点太少，Hash 规则将大部分的请求映射到同一台服务器上，使得某一个节点压力大。如图所示，只有两个节点，绝大部分请求将会映射到 N1</p><p><img src="/images\虚拟节点.png" alt="upload successful"></p><p><strong>解决方案</strong>：将一个物理节点拆分为多个虚拟节点，并且同一个物理节点的虚拟节点尽量均匀分布在 Hash 环上。A 添加虚拟节点 A’，如果映射到 A’，那么最终会请求节点 A。</p><h1 id="Java-实现（简单版本）"><a href="#Java-实现（简单版本）" class="headerlink" title="Java 实现（简单版本）"></a>Java 实现（简单版本）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public class DemoA &#123;</span><br><span class="line"></span><br><span class="line">// 真实节点列表，假设有 5 个节点</span><br><span class="line">    public static String[] hosts = &#123;&quot;192.168.0.0&quot;,</span><br><span class="line">        &quot;192.168.0.1&quot;,</span><br><span class="line">        &quot;192.168.0.2&quot;,</span><br><span class="line">        &quot;192.168.0.3&quot;,</span><br><span class="line">        &quot;192.168.0.4&quot;,</span><br><span class="line">        &quot;192.168.0.5&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    // 存储节点（真实+虚拟），并且能根据 key 排序</span><br><span class="line">    private static SortedMap&lt;Integer,String&gt; sortedMap = new TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 初始化加入节点，虚拟节点根据真实节点构建</span><br><span class="line">    static &#123;</span><br><span class="line">        for (String ip:hosts) &#123;</span><br><span class="line">            sortedMap.put(getHash(ip),ip);</span><br><span class="line">            System.out.println(ip + &quot;:&quot; + getHash(ip));</span><br><span class="line">            for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            // 虚拟节点只是后面加上字符串，取的时候方便根据虚拟节点找到真实节点</span><br><span class="line">                sortedMap.put(getHash(ip + &quot;&amp;&quot; + i),ip + &quot;&amp;&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 将字符串转为 int 类型，网上抄的方法</span><br><span class="line">    public static int getHash(String str)&#123;</span><br><span class="line">        final int p = 16777619;</span><br><span class="line">        int hash = (int) 2166136261L;</span><br><span class="line">        for (int i = 0; i &lt; str.length(); i++)</span><br><span class="line">            hash = (hash ^ str.charAt(i)) * p;</span><br><span class="line">        hash += hash &lt;&lt; 13;</span><br><span class="line">        hash ^= hash &gt;&gt; 7;</span><br><span class="line">        hash += hash &lt;&lt; 3;</span><br><span class="line">        hash ^= hash &gt;&gt; 17;</span><br><span class="line">        hash += hash &lt;&lt; 5;</span><br><span class="line">        // 如果算出来的值为负数则取其绝对值</span><br><span class="line">        if (hash &lt; 0)</span><br><span class="line">            hash = Math.abs(hash);</span><br><span class="line">        return hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 根据字符串获取对应节点</span><br><span class="line">    public static String get(String key)&#123;</span><br><span class="line">    // 数据映射到环的值 A</span><br><span class="line">        int hash = getHash(key);</span><br><span class="line">        String finalIP = &quot;&quot;;</span><br><span class="line">        Integer i;</span><br><span class="line">        // tailMap 返回比 hash 值大的子 Map</span><br><span class="line">        SortedMap&lt;Integer,String&gt; map = sortedMap.tailMap(hash);</span><br><span class="line">        // 如果环内没有比 hash 值大的，那么返回环的第一个节点</span><br><span class="line">        if (subMap.isEmpty())&#123;</span><br><span class="line">            i = sortedMap.firstKey();</span><br><span class="line">            finalIP = sortedMap.get(i);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">        // 返回子 Map 的第一个节点</span><br><span class="line">            i = subMap.firstKey();</span><br><span class="line">            finalIP = subMap.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果是虚拟节点，那么找到其对应真实节点</span><br><span class="line">        if (finalIP.indexOf(&quot;&amp;&quot;) &gt; 0)&#123;</span><br><span class="line">            finalIP = finalIP.substring(0,finalIP.indexOf(&quot;&amp;&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        return finalIP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] key = &#123;&quot;tes1&quot;,&quot;测试&quot;,&quot;HASH&quot;&#125;;</span><br><span class="line">        for (String s:key) &#123;</span><br><span class="line">            System.out.println(s + &quot; hash is:&quot; + getHash(s) + &quot; to：&quot; + get(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="博客参考"><a href="#博客参考" class="headerlink" title="博客参考"></a>博客参考</h1><p><a href="https://www.cnblogs.com/xrq730/p/5186728.html" target="_blank" rel="noopener">对一致性Hash算法，Java代码实现的深入研究</a></p><p><a href="https://zhuanlan.zhihu.com/p/34985026" target="_blank" rel="noopener">面试必备：什么是一致性Hash算法？</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 26 2019 22:36:32 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 单例模式</title>
    <link href="http://suiyia.github.io/2019/10/18/Java-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://suiyia.github.io/2019/10/18/Java-单例模式/</id>
    <published>2019-10-18T07:47:00.000Z</published>
    <updated>2019-10-18T09:54:18.451Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>什么是单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><p>解决什么问题：省略创建对象所花费的时间，不需要频繁创建对象，减轻 GC 压力</p><p>单例模式实现：</p><table><thead><tr><th></th><th>线程安全</th><th>并发性能好</th><th>可以延迟加载</th><th>序列化/反序列化安全</th><th>能抵御反射攻击</th></tr></thead><tbody><tr><td>饿汉式</td><td>Y</td><td>Y</td><td></td><td></td></tr><tr><td>懒汉式-不加锁</td><td></td><td>Y</td><td>Y</td><td></td></tr><tr><td>懒汉式-加锁</td><td>Y</td><td></td><td>Y</td><td></td></tr><tr><td>双重检查 Double Check</td><td>Y</td><td>Y</td><td>Y</td><td></td></tr><tr><td>静态内部类</td><td>Y</td><td>Y</td><td>Y</td><td></td></tr><tr><td>枚举</td><td>Y</td><td>Y</td><td></td><td>Y</td><td>Y</td></tr></tbody></table><h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><ul><li>用的时候加载，上面只支持单线程，下面支持多线程，但是每次获取都要加锁，没必要。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    private static Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getSingleton()&#123;</span><br><span class="line">    </span><br><span class="line">        if (singleton == null)&#123;</span><br><span class="line">        singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加锁</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    private static Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    public static synchronized Singleton getSingleton()&#123;</span><br><span class="line">    </span><br><span class="line">        if (singleton == null)&#123;</span><br><span class="line">        singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><ul><li><p>在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快。</p></li><li><p>通过类加载机制保证单例，但是如果代码中有其它方式导致类加载，就不满足单例</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    public static Singleton singleton = new Singleton();</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static getSingleton() &#123;</span><br><span class="line">    return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双重校验"><a href="#双重校验" class="headerlink" title="双重校验"></a>双重校验</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static volatile Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    public static getSingleton()&#123;</span><br><span class="line">    if (singleton == null)&#123;</span><br><span class="line">        synchronized(Singleton.class)&#123;</span><br><span class="line">            if (singleton == null)&#123;</span><br><span class="line">                singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><ul><li>Singleton 类被装载了，instance 不一定被初始化</li><li>只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类</li><li>这种方式只适用于静态域的情况<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">    private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static final Singleton getSingleton()&#123;</span><br><span class="line">    return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">INSTANCE;</span><br><span class="line">    </span><br><span class="line">    public void doSomeThing() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">单例模式</a></p><p><a href="https://juejin.im/post/5b50b0dd6fb9a04f932ff53f" target="_blank" rel="noopener">面试官所认为的单例模式</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;什么是单例
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://suiyia.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap 源码学习</title>
    <link href="http://suiyia.github.io/2019/10/16/ConcurrentHashMap-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://suiyia.github.io/2019/10/16/ConcurrentHashMap-源码学习/</id>
    <published>2019-10-16T08:37:00.000Z</published>
    <updated>2019-10-18T07:47:02.053Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><blockquote><p>本文 java version “1.8.0_221”</p></blockquote><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>与 HashMap 类似，使用数组 + 链表 + 红黑树存储键值对</p><p><img src="/images\ConcurrentHashMap.png" alt="upload successful"></p><h1 id="属性字段"><a href="#属性字段" class="headerlink" title="属性字段"></a>属性字段</h1><p>transient volatile Node&lt;K,V&gt;[] table; // 存放 bin，第一次插入数据时候进行初始化，长度为 2 的倍数</p><p>private static final int MIN_TRANSFER_STRIDE = 16 // 扩容线程每次最少要迁移16 个 hash 桶，在扩容中，参与的单个线程允许处理的最少 table 桶首节点个数，虽然适当添加线程，会使得整个扩容过程变快，但需要考虑多线程内存同时分配的问题</p><p>private transient volatile int sizeCtl;</p><ul><li>默认为 0</li><li>-1 表示正在初始化</li><li>-(1+number) 表示有 number 个线程同时在扩容，必须竞争到这个共享变量，才能进行初始化或者扩容。</li><li>正数， table 中元素数量阈值，超过这个阈值就会扩容</li></ul><p><img src="/images\sizeCtl.png" alt="upload successful"></p><p>static final int MOVED = -1; // hash for forwarding nodes</p><ul><li>ForwardingNode，在扩容时使用，如果 index 处 hash 值为 -1，表示正在扩容。</li></ul><p>static final int TREEBIN = -2; // hash for roots of trees</p><p>static final int RESERVED = -3; // hash for transient reservations</p><p>static final int HASH_BITS = 0x7fffffff; // usable bits of normal</p><h1 id="哈希桶-Table-初始化"><a href="#哈希桶-Table-初始化" class="headerlink" title="哈希桶 Table 初始化"></a>哈希桶 Table 初始化</h1><ul><li><p>根据共享变量 sizeCtl 的值来决定是否由<strong>当前线程</strong>执行初始化操作（单线程进行初始化）</p></li><li><p>sizeCtl 为正数时，表示 table 的阈值（= 0.75*n），元素个数超过这个值将会扩容。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">    while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">    // 如果共享变量 sizeCtl &lt; 0，说明有其它线程正在初始化或者扩容，让出 CPU，让其它线程先执行完</span><br><span class="line">        if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield(); // lost initialization race; just spin</span><br><span class="line">        // </span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">   // 再判断 table 是否为空</span><br><span class="line">                if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                // sc = sizeCtl &gt; 0 表示已经初始化，否则使用默认容量 16。</span><br><span class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    // sc = 0.75*n，sc 表示阈值</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="key-对应到哈希桶的过程"><a href="#key-对应到哈希桶的过程" class="headerlink" title="key 对应到哈希桶的过程"></a>key 对应到哈希桶的过程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static final int spread(int h) &#123;</span><br><span class="line">return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">index = spread(key) &amp; (length - 1)</span><br></pre></td></tr></table></figure><ul><li><p>hash 过程与 HashMap 类似，只是多了与 HASH_BITS 进行位运算</p></li><li><p>HASH_BITS 除了首位是 0，剩下的都是 1，按位与，得正数(首位为0)。就是为了让上面的 hash 值为正数</p></li></ul><h1 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h1><ol><li><p>key，value 都不能为 null，key 为 null 时抛出 NullPointerException</p></li><li><p>将 key 进行 hash 然后找到数组位置处的索引 index</p></li><li><p>若 index == key，直接返回 index 处元素</p></li><li><p>若 index 处的 hash 值小于 0，进一步调用 Node 子类的 find 方法</p></li><li><p>index 处的 hash 值不小于 0，遍历查找</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static final int TREEBIN   = -2; // hash for roots of trees</span><br><span class="line"></span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    int h = spread(key.hashCode());</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">    // 如果找到这个节点，直接返回</span><br><span class="line">        if ((eh = e.hash) == h) &#123;</span><br><span class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果 hash 值小于 0，调用 Node 的查找方法，Node 可以为链表或树</span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line">            return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">        while ((e = e.next) != null) &#123;</span><br><span class="line">            if (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h1><ol><li><p>table 为 null 或者 tab.size = 0，进行 resize。</p></li><li><p>key 进行 hash 之后取模得到的索引位置，若在桶的位置元素为 null，那么直接插入元素。</p></li><li><p>桶位置元素不为 null，那么进行比较</p></li><li><p>判断 key 是否相同：</p><ul><li>如果 key 相同，e 保存该节点</li><li>如果 key 不同，如果该是红黑树节点，那么执行红黑树的 put 方法；如果是链表节点，执行链表遍历操作，找到对应的节点并用 e 保存，如果链表长度大于 &gt;=7，就将链表转为红黑树</li></ul></li><li><p>Node e 保存找到的节点，如果没有找到返回 null</p></li><li><p>如果 size 超过阈值，进行扩容</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">// key value 均不能为 null</span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    int binCount = 0;</span><br><span class="line">    // 获取当前 table，进入死循环，直至插入成功</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        // 为空需要进行初始化</span><br><span class="line">        if (tab == null || (n = tab.length) == 0)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        // 索引所在位置没有元素，通过 casTabAt 方法插入元素并跳出循环</span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))&#123;</span><br><span class="line">                break;                   // no lock when adding to empty bin</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 索引位置处 hash = -1，表示其它线程正在扩容，helpTransfer 将帮助扩容，且元素赋值到扩容后的位置</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        // 该位置处节点为普通节点，锁住该链表头结点并在尾部添加节点</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">            // 加锁之后再判断索引位置处 key 是否相同</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                // hash &gt;= 0，通过链表遍历方式找到并替换节点</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                // 进行替换</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            if ((e = e.next) == null) &#123;</span><br><span class="line">                            // 链表尾部插入节点</span><br><span class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // index 处索引小于 0 （hash = -2 TREEBIN），并且是树节点，执行树的插入方法</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != null) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // binCount != 0 说明向链表或者红黑树中添加或修改一个节点成功</span><br><span class="line">            // binCount  == 0 说明 put 操作将一个新节点添加成为某个桶的首节点</span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line">            // &gt;= 8 就转为红黑树</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                // oldVal != null 说明此次操作是修改操作，直接返回旧值，无需下面扩容检查</span><br><span class="line">                if (oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断是否需要扩容</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h1><ul><li><p>baseCount 记录元素个数，通过 addCount 更新 baseCount，当更新失败时，addCount 中的 fullCount 会更新 counterCells</p></li><li><p>元素个数 = baseCount + counterCells.length</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    long n = sumCount();</span><br><span class="line">    return ((n &lt; 0L) ? 0 :</span><br><span class="line">            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (int)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final long sumCount() &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    long sum = baseCount;</span><br><span class="line">    if (as != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            if ((a = as[i]) != null)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 返回表长度 n 的标志位</span><br><span class="line">static final int resizeStamp(int n) &#123;</span><br><span class="line">return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 帮助扩容</span><br><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">    // tab 不为 null，传进来的节点是 ForwardingNode，并且 ForwardingNode 下一个 tab 不为 null</span><br><span class="line">    if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</span><br><span class="line">        // 生成标志位 rs</span><br><span class="line">        int rs = resizeStamp(tab.length);</span><br><span class="line">        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; 0) &#123;</span><br><span class="line">            // 如果 sizeCtl 无符号右移 16 位与上面标志位不同</span><br><span class="line">            // 或者 sizeCtl == rs + 1  （扩容结束了，不再有线程进行扩容）</span><br><span class="line">            // 或者 sizeCtl == rs + 65535  （如果达到最大帮助线程的数量，即 65535）</span><br><span class="line">            // 或者转移下标正在调整 （扩容结束）</span><br><span class="line">            // 结束循环</span><br><span class="line">            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            // 以上情况不满足， sizeCtl++ ，增加一个线程进行扩容</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</span><br><span class="line">                // 复制或者移动 bins 里面的 Node 到新的 table</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    return table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 移动或者复制 Node 到新的 table</span><br><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    int n = tab.length, stride;</span><br><span class="line">    // 计算单个线程允许处理的最少 table 桶首节点个数，不能小于 16</span><br><span class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line">    // 如果刚开始扩容，就初始化 nextTab</span><br><span class="line">    if (nextTab == null) &#123;            // initiating</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        // transferIndex 指向最后一个桶，方便从后向前遍历</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    int nextn = nextTab.length;</span><br><span class="line">    // fwd 作为标记，标记那些已经完成迁移的桶</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    boolean advance = true;</span><br><span class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</span><br><span class="line">    // i 指向当前桶，bound 指向当前线程需要处理的桶结点的区间下限</span><br><span class="line">    for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            if (--i &gt;= bound || finishing)</span><br><span class="line">                advance = false;</span><br><span class="line">            // transferIndex 本来指向最后一个桶，小于等于 0 说明处理完成    </span><br><span class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</span><br><span class="line">                i = -1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新 transferIndex，处理的桶区间为 (nextBound,nextIndex)</span><br><span class="line">            else if (U.compareAndSwapInt</span><br><span class="line">                     (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : 0))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - 1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 当前线程任务处理完成</span><br><span class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            int sc;</span><br><span class="line">            if (finishing) &#123;</span><br><span class="line">                nextTable = null;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</span><br><span class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line">                finishing = advance = true;</span><br><span class="line">                i = n; // recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 待迁移的桶为 null，在此位置添加 ForwardingNode 标记该桶已经处理过</span><br><span class="line">        else if ((f = tabAt(tab, i)) == null)</span><br><span class="line">            advance = casTabAt(tab, i, null, fwd);</span><br><span class="line">        // 该桶已经处理过</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = true; // already processed</span><br><span class="line">        else &#123;</span><br><span class="line">        // 锁住该桶</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">            // 再判断下桶有没有发生变化</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        int runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        // 整个 for 循环为了找到整个桶中最后连续的 fh &amp; n 不变的结点</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                            int b = p.hash &amp; n;</span><br><span class="line">                            if (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (runBit == 0) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 如果 fh&amp;n 不变的链表的 runbit 都是 0，则 nextTab[i] 内元素 ln 前逆序，ln 及其之后顺序</span><br><span class="line">                        // 否则，nextTab[i+n]内元素全部相对原table逆序</span><br><span class="line">                        // 这是通过一个节点一个节点的往 nextTab 添加</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            if ((ph &amp; n) == 0)</span><br><span class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            else</span><br><span class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 把两条链表整体迁移到 nextTab 中</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        // 将原桶标识位已经处理</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 红黑树的复制算法</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                        int lc = 0, hc = 0;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                            int h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, null, null);</span><br><span class="line">                            if ((h &amp; n) == 0) &#123;</span><br><span class="line">                                if ((p.prev = loTail) == null)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if ((p.prev = hiTail) == null)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sizeCtl == rs + 1 扩容结束了，不再有线程进行扩容，这个判断可以在 addCount 方法中找到答案：默认第一个线程设置 sc == rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1。<br>如果 sizeCtl == 标识符 + 1 ，说明库容结束了，没有必要再扩容了。</li></ul><h1 id="博客参考"><a href="#博客参考" class="headerlink" title="博客参考"></a>博客参考</h1><p><a href="https://juejin.im/post/5b0015ef518825428830ec80" target="_blank" rel="noopener">并发编程——ConcurrentHashMap#helpTransfer() 分析</a></p><p><a href="https://www.cnblogs.com/yangming1996/p/8031199.html" target="_blank" rel="noopener">为并发而生的 ConcurrentHashMap（Java 8）</a></p><p><a href="https://www.iteye.com/blog/wujiu-2378812" target="_blank" rel="noopener">https://www.iteye.com/blog/wujiu-2378812</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;blockquote&gt;&lt;p&gt;本文 java version “1.8.0_221”&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;结构&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="Java 集合" scheme="http://suiyia.github.io/tags/Java-%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 源码学习</title>
    <link href="http://suiyia.github.io/2019/10/15/HashMap-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://suiyia.github.io/2019/10/15/HashMap-源码学习/</id>
    <published>2019-10-15T14:07:00.000Z</published>
    <updated>2019-10-16T08:34:04.155Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><blockquote><p>本文 java version “1.8.0_221”</p></blockquote><h1 id="属性字段"><a href="#属性字段" class="headerlink" title="属性字段"></a>属性字段</h1><p>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 初始默认容量大小，如果指定容量，容量必须是 2 的倍数</p><p>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 最大的容量大小 1*2^30=1073741824 ，如果指定容量，容量必须是 2 的倍数</p><p>static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认负载因子</p><p>static final int TREEIFY_THRESHOLD = 8; // 超过 8 就变为 红黑树</p><p>static final int UNTREEIFY_THRESHOLD = 6; // 小于 6 变为链表</p><p>transient Node&lt;K,V&gt;[] table; // 存放元素的哈希桶数组</p><p>transient int size; // 当前 Map 中 键值对数量</p><p>final float loadFactor; // 负载因子</p><p>int threshold; // 当前 Map 能容纳的最大键值对数量，threshold = length * Load factor</p><p>transient int modCount; // 结构性修改的次数，用于 fail-fast 机制</p><h1 id="key-对应到哈希桶的过程"><a href="#key-对应到哈希桶的过程" class="headerlink" title="key 对应到哈希桶的过程"></a>key 对应到哈希桶的过程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">index = hash(key) &amp; (length - 1)</span><br></pre></td></tr></table></figure><ol><li><p>若 key == null，放到数组第一位</p></li><li><p>key != null，调用 Object.hashCode() 方法将 key 进行 hash 得到 h</p></li><li><p>将 h 与 h 右移 16 位后的数值进行异或得到一个 hash 值</p></li><li><p>将第 3 步得到 hash 值与数组长度减一进行与运算，得到 key 在哈希桶的索引位置。</p></li></ol><p>第 4 步非常巧妙，它通过 h&amp;(table.length -1)来得到该对象的保存位，而 HashMap 底层数组的长度总是2的n次方，这是 HashMap 在速度上的优化。当 length 总是 2 的 n 次方时，h&amp; (length-1)运算等价于对 length 取模，也就是h%length，但是 &amp; 比 % 具有更高的效率。</p><p><img src="/images\key的hash过程.png" alt="upload successful"></p><h1 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h1><ul><li><p>put 方法支持，key、value 都为 null，并且是 <strong>尾插法</strong></p></li><li><p>get 方法返回 null，有两种情况：一是不包含这个键值对，二是该键值对的键 key 对应的 value 就是 null，可以通过 containsKey 方法判断 Map 是否包含该 key</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123;  // 找到 hash 值一样的桶 </span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) // 如果第一个元素 key 相同，返回这个 Node</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);  // 如果是树节点，那么去树里面找</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))  // 在链表中找</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h1><p><img src="/images\hashmap的put方法.png" alt="upload successful"></p><ol><li><p>table 为 null 或者 tab.size = 0，进行 resize。</p></li><li><p>key 进行 hash 之后取模得到的索引位置，若在桶的位置元素为 null，那么直接插入元素。</p></li><li><p>桶位置元素不为 null，那么进行比较</p></li><li><p>判断 key 是否相同：</p><ul><li>如果 key 相同，e 保存该节点</li><li>如果 key 不同，如果该是红黑树节点，那么执行红黑树的 put 方法；如果是链表节点，执行链表遍历操作，找到对应的节点并用 e 保存，如果链表长度大于 &gt;=7，就将链表转为红黑树</li></ul></li><li><p>Node e 保存找到的节点，如果没有找到返回 null</p></li><li><p>如果 size 超过阈值，进行扩容</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // 如果 table 的在（n-1）&amp;hash 的值是 null，就新建一个节点插入在该位置</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    // 表示该索引位置有值</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        // 如果 key 相等，那么 Node e 保存原来的值用于替换</span><br><span class="line">        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">            e = p;</span><br><span class="line">        // 如果 key 最终不等，而且是树节点，执行红黑树的 put 方法</span><br><span class="line">        &#125; else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        // 如果 key 最终不等，而且是链表节点，执行链表的 put 方法</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                // 如果指针为空就挂在后面</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        // 链表数量 &gt;= 7 就转为红黑树</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 链表上面有相同的 key 的元素，那么 e 保存原来的值</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 最终 Map 中有该元素，那么进行 value 替换</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 结构修改次数加 1</span><br><span class="line">    ++modCount;</span><br><span class="line">    // 如果新增一个元素后容量大于阈值，进行扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h1><ul><li>扩容是 2 倍的倍数进行扩容</li><li>扩容后，换一个更大的数组重新映射，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        // 如果原来的桶长度已经超过最大阈值，那么数组扩大到 2^31 -1</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;  </span><br><span class="line">        // 如果原来桶长度扩大 2 倍后还是小于最大阈值，那么新阈值为原来阈值的 2 倍</span><br><span class="line">        &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)&#123;</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (oldThr &gt; 0)&#123; // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;// </span><br><span class="line">    &#125; else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line">                // 链表优化重hash的代码块</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        // 原索引</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 原索引+oldCap</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    // 原索引放到bucket里</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 原索引+oldCap放到bucket里</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="博客参考"><a href="#博客参考" class="headerlink" title="博客参考"></a>博客参考</h1><p><a href="https://lushunjian.github.io/blog/2019/01/02/HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">HashMap的底层实现</a></p><p><a href="https://blog.csdn.net/login_sonata/article/details/76598675" target="_blank" rel="noopener">Java8的HashMap详解（存储结构，功能实现，扩容优化，线程安全，遍历方法），是下面的总结</a></p><p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;blockquote&gt;&lt;p&gt;本文 java version “1.8.0_221”&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;属性字段&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="Java 集合" scheme="http://suiyia.github.io/tags/Java-%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程学习——常用类与方法</title>
    <link href="http://suiyia.github.io/2019/10/14/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>http://suiyia.github.io/2019/10/14/Java-多线程学习——常用类与方法/</id>
    <published>2019-10-14T15:04:00.000Z</published>
    <updated>2019-10-15T07:15:35.674Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>Java 中的 ThreadLocal 类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个 ThreadLocal 变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的 ThreadLocal 变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private ThreadLocal myThreadLocal = new ThreadLocal();</span><br></pre></td></tr></table></figure><p><a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="noopener">Java进阶（七）正确理解Thread Local的原理与适用场景</a></p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：</p><p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><p>2）禁止进行指令重排序。</p><p>Java 内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p><p><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a></p><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>ReentrantLock 重入锁，是实现 Lock 接口的一个类，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。</p><p>ReentrantLock还支持公平锁和非公平锁两种方式。</p><p><a href="https://my.oschina.net/u/566591/blog/1557978" target="_blank" rel="noopener">Java并发学习之ReentrantLock的工作原理及使用姿势</a></p><p><a href="https://blog.csdn.net/lipeng_bigdata/article/details/52154637" target="_blank" rel="noopener">Java并发之ReentrantLock详解</a></p><h1 id="ReentrantLock-与-Synchronized-区别"><a href="#ReentrantLock-与-Synchronized-区别" class="headerlink" title="ReentrantLock 与 Synchronized 区别"></a>ReentrantLock 与 Synchronized 区别</h1><ol><li><p>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁</p></li><li><p>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性</p></li><li><p>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的</p></li><li><p>ReentrantLock 可以实现公平锁</p></li><li><p>ReentrantLock 通过 Condition 可以绑定多个条件</p></li><li><p>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略</p></li><li><p>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现。</p></li><li><p>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock() 去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。</p></li><li><p>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。</p></li><li><p>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p></li><li><p>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。</p></li></ol><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h1><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p><table><thead><tr><th>方法\处理方式</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td>插入方法</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除方法</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查方法</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li><p>抛出异常：是指当阻塞队列满时候，再往队列里插入元素，会抛出 IllegalStateException(“Queue full”) 异常。当队列为空时，从队列里获取元素时会抛出 NoSuchElementException 异常 。</p></li><li><p>返回特殊值：插入方法会返回是否成功，成功则返回 true。移除方法，则是从队列里拿出一个元素，如果没有则返回 null</p></li><li><p>一直阻塞：当阻塞队列满时，如果生产者线程往队列里 put 元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里 take 元素，队列也会阻塞消费者线程，直到队列可用。</p></li><li><p>超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。</p></li></ul><p><a href="https://www.infoq.cn/article/java-blocking-queue" target="_blank" rel="noopener">聊聊并发（七）——Java 中的阻塞队列</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;Threa
      
    
    </summary>
    
    
      <category term="Java 多线程" scheme="http://suiyia.github.io/tags/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程学习——Synchronize</title>
    <link href="http://suiyia.github.io/2019/10/14/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Synchronize/"/>
    <id>http://suiyia.github.io/2019/10/14/Java-多线程学习——Synchronize/</id>
    <published>2019-10-14T12:00:00.000Z</published>
    <updated>2019-10-14T15:05:05.972Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><p>多线程虽然能够一定程度上解决高并发请求的问题，但是利用多线程进行开发，首先要保证的就是线程安全。</p><ul><li><p>线程安全：无论在单线程还是多线程的情况下，业务代码输出结果不变。</p></li><li><p>同步：要实现线程安全，就需要同步，即依靠认为的调度和控制，使得业务代码按照人们意向的方向进行。</p></li></ul><h1 id="关于-Synchronized-的一些概念"><a href="#关于-Synchronized-的一些概念" class="headerlink" title="关于 Synchronized 的一些概念"></a>关于 Synchronized 的一些概念</h1><ul><li><p>对象锁：在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。</p></li><li><p>类锁：在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。</p></li></ul><h1 id="Synchronized-用法"><a href="#Synchronized-用法" class="headerlink" title="Synchronized 用法"></a>Synchronized 用法</h1><ul><li>this、object（对象锁）</li><li>类.class（类锁）</li><li>方法（对象锁）</li><li>静态方法（类锁）</li></ul><h1 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h1><p><a href="https://blog.csdn.net/u010072711/article/details/75210363" target="_blank" rel="noopener">java多线程同步(wait、notify)生产者消费者简单示例</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>无论 synchronized 关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。</p></li><li><p>同一个类的不同对象的对象锁互不干扰</p></li><li><p>对象锁和类锁是独立的，互不干扰</p></li><li><p>synchronized 关键字不能继承，父类中的 synchronized 修饰方法，子类在覆盖该方法时，默认情况下不是同步的，必须显示的使用 synchronized 关键字修饰才行。</p></li><li><p>关键字 synchronize 拥有锁重入的功能，也就是在使用 synchronize 时，当一个线程的得到了一个对象的锁后，再次请求此对象是可以再次得到该对象的锁。</p></li></ul><h1 id="博客参考"><a href="#博客参考" class="headerlink" title="博客参考"></a>博客参考</h1><p><a href="https://juejin.im/post/594a24defe88c2006aa01f1c" target="_blank" rel="noopener">Java 之 synchronized 详解</a></p><p><a href="https://blog.csdn.net/luoweifu/article/details/46613015" target="_blank" rel="noopener">Java中Synchronized的用法</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;多线程虽然能够一定程度上解决高并发请求的问题，但是利用多线程进行开发，首先要保证的就是线程安全。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;线程安全：无论在单
      
    
    </summary>
    
    
      <category term="Java 多线程" scheme="http://suiyia.github.io/tags/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程学习——基础概念</title>
    <link href="http://suiyia.github.io/2019/10/14/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://suiyia.github.io/2019/10/14/Java多线程——基础概念/</id>
    <published>2019-10-14T02:52:00.000Z</published>
    <updated>2019-12-18T02:27:12.474Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 16:34:11 GMT+0800 (GMT+08:00) --><h1 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h1><ul><li><p>解释一：并行是指两个或者多个事件在<strong>同一时刻</strong>发生；而并发是指两个或多个事件在<strong>同一时间间隔</strong>发生（注意的<strong>是时间间隔</strong>，间隔是有大小的）。</p></li><li><p>解释二：并行是在<strong>不同实体</strong>上的多个事件，并发是在<strong>同一实体</strong>上的多个事件。</p></li><li><p>解释三：在<strong>一台</strong>处理器上同时处理多个任务，在<strong>多台</strong>处理器上同时处理多个任务。如 hadoop 分布式集群</p></li></ul><p>这里另外再用一张经常用的图来解释并发与并行之间的关系</p><ul><li><p>并发就像只有一台咖啡机能制造咖啡（单核 CPU）的店铺，然而有序列 A 和序列 B 两队人在排队，在一个<strong>时间段</strong>内（咖啡机可能造出多杯咖啡），序列 A 和序列 B<br>的人可能都会领取到咖啡，在这个时间段内多个人领取到咖啡这个过程称为 并发，这个时间段类似于多个 CPU 时间片，一个 CPU 时间片执行一个任务。</p></li><li><p>并行就像有两台咖啡机的店铺，然后在<strong>同一个时刻</strong>，都会有两个人领取到咖啡，这样的过程称为 并行。</p></li></ul><p><img src="/images\并发与并行1.png" alt="upload successful"></p><h1 id="Java-多线程实现方式"><a href="#Java-多线程实现方式" class="headerlink" title="Java 多线程实现方式"></a>Java 多线程实现方式</h1><p>平时所说的多线程，其实就是并发知识的底层实现，Java 现在有多种多线程的实现方式，最基础的两种方式是：</p><ul><li>方式一：继承 Thread 类（一般不用，继承会把类的特性限制太死）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;  </span><br><span class="line">　　public void run() &#123;  </span><br><span class="line">　　 System.out.println(&quot;MyThread.run()&quot;);  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line">MyThread myThread1 = new MyThread();  </span><br><span class="line">MyThread myThread2 = new MyThread();  </span><br><span class="line">myThread1.start();  </span><br><span class="line">myThread2.start();</span><br></pre></td></tr></table></figure><ul><li>方式二：实现 Runnable 接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadB implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;ThreadB&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread thread = new Thread(new ThreadB());</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><ul><li><p>还有其它实现方式，如实现 Callable 接口、Future 等，参考 <a href="https://www.cnblogs.com/felixzh/p/6036074.html" target="_blank" rel="noopener">JAVA多线程实现的四种方式</a></p></li><li><p>这里 run() 方法内的逻辑表示线程执行的业务逻辑，而让线程启动的方法是 start()</p></li><li><p>start() 方法，即启动线程的方法，通过了解 start() 源码，执行 start 时，会有两个线程并发执行，当前线程去调用 start() 方法，另外一个线程会调 run() 方法开始具体的业务逻辑。</p></li><li><p>需要注意的是，一个线程不能被启动多次，只有当它业务逻辑执行完成之时，才会启动下一次，否则会抛出 IllegalThreadStateException 异常。</p></li></ul><h1 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h1><p>根据 java.lang.Thread.State 枚举类源码可知，有 6 种不同的线程状态。<strong>These states are virtual machine states which do not reflect any operating system thread states.</strong></p><p><img src="/images\线程六种状态.png" alt="upload successful"></p><ul><li><p><strong>NEW（新建）</strong>：仅定义了一个线程对象，还未调用它的 start() 方法。</p><p>Thread state for a thread which has not yet started.</p></li><li><p><strong>RUNNABLE（可运行）</strong>：调用了线程的 start 方法，已经被 JVM 执行，但还在等待系统其它资源，如 CPU 时间片、I/O 等，根据<strong>操作系统</strong>知识可进一步将可运行状态细分为就绪、运行中两种状态（Java 并没有进一步细分）。</p><p>Thread state for a runnable thread. A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.</p><ul><li>就绪：调用了 start 方法，但没有得到 CPU 时间片的状态</li><li>运行中：得到了 CPU 时间片的状态，正在执行</li></ul></li><li><p><strong>BLOCKED（阻塞）</strong>：线程等待 monitor lock 的状态，只有得到了这个<strong>对象锁</strong>之后，状态才会由阻塞变为<strong>就绪</strong>。</p><p>等待 monitor lock 进入被锁住的代码块，或者在调用 wait() 方法之后又进入被锁住的代码块（A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling {@link Object#wait() Object.wait}.）</p></li></ul><p>// TODO 下面内容还待考证</p><pre><code>- 等待阻塞：运行的线程执行 o.wait() 方法，JVM 会把该线程放入等待队列(waitting queue)中- 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池(lock pool)中- 其他阻塞：运行的线程执行 Thread.sleep(long ms) 或t.join() 方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态，当 sleep() 状态超时、join() 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入可运行(runnable)状态</code></pre><ul><li><p><strong>WAITING（等待）</strong>：</p><p>A thread in the waiting state is waiting for another thread to perform a particular action.</p><ul><li><p>等待另一个线程的特定操作的状态，等待被其他线程唤醒</p></li><li><p>等待的过程是主动等待的，而阻塞是得不到对象锁而被动阻塞住</p></li><li><p>当线程拿到锁之后，调用相应锁对象的 wait()、join()、继承 LockSupport 类的 park() ，调用其中的方法线程就会处于这个状态。</p></li></ul></li></ul><ul><li><p><strong>TIMED_WAITING（有限期等待或超时等待）</strong>：</p><p>Thread state for a waiting thread with a specified waiting time.</p><ul><li>等待另一个线程执行<strong>指定等待时间</strong>的操作的线程处于此状态</li><li>等待另一个线程特定时间，时间过后会自动唤醒</li><li>线程执行 sleep（）、wait（long）、join（long）、LockSupport.parkNanos 、LockSupport.parkUntil 方法时会处于这种状态</li></ul></li><li><p><strong>TERMINATED（终止）</strong>：线程业务逻辑执行完成退出的状态<br>Thread state for a terminated thread.The thread has completed execution.</p></li></ul><h1 id="线程具有的方法"><a href="#线程具有的方法" class="headerlink" title="线程具有的方法"></a>线程具有的方法</h1><p>主要讲解它的方法以及状态的切换、锁持有状态</p><ul><li><p><strong>Thread.sleep(long millis)</strong>，一定是当前线程调用此方法，线程进入 TIME_WAITING 状态，但不释放对象锁，millis 后线程自动苏醒进入就绪状态。</p><p>作用：给其它线程执行机会的最佳方式。</p></li><li><p><strong>Thread.yield()</strong>，一定是当前线程调用此方法，当前线程放弃获取的 cpu 时间片，由运行状态变会就绪状态，让 OS 再次选择线程。</p><p>作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证 yield() 达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield() 不会导致阻塞。</p></li><li><p><strong>t.join()/t.join(long millis)</strong>，当前线程里调用其它线程 t 的 join 方法，当前线程进入 TIME_WAITING 状态，当前线程不释放已经持有的对象锁。线程 t 执行完毕或者 millis 时间到，当前线程进入就绪状态。</p></li><li><p><strong>obj.wait()</strong>，当前线程调用对象的 wait() 方法，当前线程释放对象锁，进入等待队列。依靠 notify()/notifyAll() 唤醒或者 wait(long timeout) timeout 时间到自动唤醒。</p></li><li><p><strong>obj.notify()</strong> 唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll() 唤醒在此对象监视器上等待的所有线程。</p></li></ul><h1 id="终止线程的-4-种方式"><a href="#终止线程的-4-种方式" class="headerlink" title="终止线程的 4 种方式"></a>终止线程的 4 种方式</h1><ul><li><p>正常结束</p></li><li><p>退出标识：有些线程需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程</p></li><li><p>Interrupt() 方法</p><ul><li><p>线程处于阻塞状态：调用 interrupt() 方法会抛出异常，此时要退出线程必须 catch 异常，并使用 break 方法退出。</p></li><li><p>线程不处于阻塞状态：使用 isInterrupted() 判断线程的中断标志来退出循环，当使用 interrupt() 方法时，中断标志就会置 true</p></li></ul></li><li><p>stop 方法：thread.stop() 调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用 thread.stop() 后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈现不一致性</p></li></ul><h1 id="wait-和-sleep-区别"><a href="#wait-和-sleep-区别" class="headerlink" title="wait 和 sleep 区别"></a>wait 和 sleep 区别</h1><p>共同点：</p><ol><li>他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。</li><li>wait() 和 sleep() 都可以通过 interrupt() 方法 打断线程的暂停状态 ，从而使线程立刻抛出 InterruptedException。<br>如果线程 A 希望立即结束线程 B，则可以对线程 B 对应的 Thread 实例调用 interrupt 方法。如果此刻线程 B 正在 wait/sleep /join，则线程 B 会立刻抛出 InterruptedException，在 catch() {} 中直接 return 即可安全地结束线程。<br>需要注意的是，InterruptedException 是线程自己从内部抛出的，并不是 interrupt() 方法抛出的。对某一线程调用 interrupt() 时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出 InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出 InterruptedException 。</li></ol><p>不同点：</p><ol><li>Thread类的方法：sleep(),yield()等 。Object的方法：wait()和notify()等</li><li>每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。<br>sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。</li><li>wait，notify 和 notifyAll 只能在同步控制方法或者同步控制块里面使用，而 sleep 可以在任何地方使用</li><li>sleep 必须捕获异常，而 wait，notify和notifyAll 不需要捕获异常</li></ol><p>所以sleep() 和 wait() 方法的最大区别是：sleep() 睡眠时，保持对象锁，仍然占有该锁；而 wait() 睡眠时，释放对象锁。但是 wait() 和 sleep() 都可以通过 interrupt() 方法打断线程的暂停状态，从而使线程立刻抛出 InterruptedException（但不建议使用该方法）。</p><h1 id="博客参考"><a href="#博客参考" class="headerlink" title="博客参考"></a>博客参考</h1><ul><li><a href="http://ifeve.com/parallel_and_con/" target="_blank" rel="noopener">并发和并行有什么区别？</a></li><li><a href="https://www.cnblogs.com/trust-freedom/p/6606594.html" target="_blank" rel="noopener">Java语言定义的线程状态分析</a></li><li><a href="https://blog.csdn.net/pange1991/article/details/53860651/" target="_blank" rel="noopener">Java线程的6种状态及切换(透彻讲解)</a></li><li><a href="http://www.importnew.com/21089.html" target="_blank" rel="noopener">Java中的多线程你只要看这一篇就够了</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 16:34:11 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;并行与并发&quot;&gt;&lt;a href=&quot;#并行与并发&quot; class=&quot;headerlink&quot; title=&quot;并行与并发&quot;&gt;&lt;/a&gt;并行与并发&lt;
      
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://suiyia.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 网络请求方法整理基于 JDK 1.8</title>
    <link href="http://suiyia.github.io/2019/10/13/Java-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86%E5%9F%BA%E4%BA%8E-JDK-1-8/"/>
    <id>http://suiyia.github.io/2019/10/13/Java-网络请求方法整理基于-JDK-1-8/</id>
    <published>2019-10-13T07:20:00.000Z</published>
    <updated>2019-10-13T07:20:51.266Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>写代码过程中发现自己对 Java 的一些 HTTP <strong>请求方法</strong>不是很熟悉，也没有一个全局的概念框架，网上的一些博客使用的方法已经被 JDK 所抛弃。</p><p>于是<strong>简单整理</strong>下 Java 中常用的 HTTP 请求方法，以及它们的适用场景等，方便自己以后使用，本文基于 JDK 1.8。</p><p>这篇文章的作用很简单：</p><ol><li>了解 Java 开发中常用的 HTTP 请求方法</li><li>了解这些方法的适用场景和注意事项</li><li>使用最新的方法，抛弃被添加 @Deprecated 注解的方法</li></ol><h1 id="1-常用的-HTTP-请求方法"><a href="#1-常用的-HTTP-请求方法" class="headerlink" title="1. 常用的 HTTP 请求方法"></a>1. 常用的 HTTP 请求方法</h1><ul><li><p><strong>Socket</strong>：又称套接字，它工作在传输层，是所有应用层 HTTP 请求的底层实现。通过 ip 地址 + 端口号 即可实现网络通信</p></li><li><p><strong>HttpURLConnection</strong>：继承了抽象类 URLConnection，源码中它定义了一些网络请求的返回码；也能够对 HTTP 请求做一些参数调整，例如使用 POST 请求、使用代理</p></li><li><p><strong>HttpClient</strong>：是 Apache 下的子项目，使用时需要引入第三方 org.apache.httpcomponents.httpclient.jar 包，它对 HTTP 请求的一些方法封装的更多，造好的轮子，使用也更加方便</p></li></ul><h1 id="2-各个-HTTP-请求方法示例"><a href="#2-各个-HTTP-请求方法示例" class="headerlink" title="2. 各个 HTTP 请求方法示例"></a>2. 各个 HTTP 请求方法示例</h1><ol><li>Socket</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SocketDemo</span><span class="params">(URL url,String content)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        url = <span class="keyword">new</span> URL(<span class="string">"https://www.apiopen.top"</span>);</span><br><span class="line">        String path = <span class="string">"/weatherApi?city=%E6%AD%A6%E6%B1%89"</span>;</span><br><span class="line">        String host = url.getHost();</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">80</span>; <span class="comment">// 请求的 端口号</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(host,port);</span><br><span class="line">        <span class="comment">// 需要添加方法头，不然无法正确运行</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream(),<span class="string">"utf-8"</span>);</span><br><span class="line">        osw.write(<span class="string">"GET "</span> + path + <span class="string">" HTTP/1.1\r\n"</span>);</span><br><span class="line">        osw.write(<span class="string">"Host: "</span> + host + <span class="string">" \r\n"</span>);</span><br><span class="line">        osw.write(<span class="string">"Connection: Keep-Alive\r\n"</span>);</span><br><span class="line">        osw.write(<span class="string">"Content-Type: application/x-www-form-urlencoded; charset=utf-8 \r\n"</span>);</span><br><span class="line">        osw.write(<span class="string">"\r\n"</span>);</span><br><span class="line">        <span class="comment">// 获取响应结果并输出</span></span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        String readLine;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> ((readLine = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(readLine);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuffer.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>HttpURLConnection</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HttpURLConnection</span><span class="params">(URL url, String content)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span><br><span class="line">        connection.setDoInput(<span class="keyword">true</span>); <span class="comment">// 表示 getOutput() 的时候能起作用</span></span><br><span class="line">        connection.setDoOutput(<span class="keyword">true</span>); <span class="comment">// 表示 getInput() 的时候能起作用</span></span><br><span class="line">        connection.setUseCaches(<span class="keyword">false</span>); <span class="comment">// 不使用缓存</span></span><br><span class="line">        connection.setRequestMethod(<span class="string">"POST"</span>); <span class="comment">// POST 请求</span></span><br><span class="line"></span><br><span class="line">        OutputStream outputStream = connection.getOutputStream();</span><br><span class="line">        outputStream.write(content.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        outputStream.close();</span><br><span class="line">        <span class="comment">// 获取响应结果并输出</span></span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(connection.getInputStream()));</span><br><span class="line">        String readLine;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> ((readLine = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(readLine);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuffer.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>HttpClient</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HTTPClient</span><span class="params">(URL url,String content)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HttpClient client = HttpClients.createDefault();</span><br><span class="line">        HttpPost post = <span class="keyword">new</span> HttpPost(url.toString()); <span class="comment">// 执行 POST 请求，GET 请求有 HttpGet</span></span><br><span class="line">        CloseableHttpResponse response = (CloseableHttpResponse) client.execute(post); <span class="comment">// 得到返回结果</span></span><br><span class="line">        System.out.println(EntityUtils.toString(response.getEntity()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"https://www.apiopen.top/weatherApi?city=%E6%AD%A6%E6%B1%89"</span>);</span><br><span class="line">        String content = <span class="string">"123"</span>;</span><br><span class="line">        HttpURLConnection(url, content);</span><br><span class="line">        HTTPClient(url,content);</span><br><span class="line">        SocketDemo(url,content);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>上面各个方法适用场景</p><ul><li><p>上面三个方法返回结果都是一样的，看<strong>代码量</strong>都知道使用哪个好，时间紧迫的时候直接用别人造好的轮子很有必要</p></li><li><p>但是想提升内功，建议先学习 Socket 通信等知识，对自己以后的提升帮助会很大，<strong>机会总是留给有意无意有准备的人</strong></p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;写代码过程
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>本地运行 Kafka 与 Zookeeper </title>
    <link href="http://suiyia.github.io/2019/10/13/%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C-Kafka-%E4%B8%8E-Zookeeper/"/>
    <id>http://suiyia.github.io/2019/10/13/本地运行-Kafka-与-Zookeeper/</id>
    <published>2019-10-13T07:17:00.000Z</published>
    <updated>2019-10-13T07:18:56.975Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>本地运行 kafka，运行生产消费实例。</p><p>Kafka 是一个分布式发布-订阅消息系统。<br>Zookeeper 是一个高性能分布式应用协调服务。<br>他们之间的关系 <a href="https://www.jianshu.com/p/31b1a37e43ef" target="_blank" rel="noopener">参考</a></p><h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><ol><li>安装 Zookeeper</li></ol><ul><li><p><a href="https://github.com/alibaba/canal/wiki/Zookeeper-QuickStart" target="_blank" rel="noopener">参考配置地址</a></p></li><li><p>注意 <strong>环境变量</strong> 配置，<strong>配置文件重命名</strong></p></li><li><p>启动方式：Windows 平台直接点击 zkServer.cmd，Linux 平台 ./zkServer.sh start</p></li><li><p>Zookeeper 可视化（可选）：安装 <a href="https://github.com/DeemOpen/zkui" target="_blank" rel="noopener">zk ui</a>，先用 maven 打包，再修改配置文件，再启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#vim config.cfg</span><br><span class="line">serverPort=9090     #指定端口</span><br><span class="line">zkServer=localhost:2181</span><br><span class="line">sessionTimeout=300000</span><br><span class="line"></span><br><span class="line">java -jar target/zkui-2.0-SNAPSHOT-jar-with-dependencies.jar &amp;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>安装 Kafka</li></ol><ul><li><a href="https://kafka.apache.org/downloads" target="_blank" rel="noopener">下载地址</a>，下载二进制文件，即 <strong>Binary downloads</strong></li><li>config/server.properties 配置，<a href="https://github.com/alibaba/canal/wiki/Kafka-QuickStart" target="_blank" rel="noopener">参考</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listeners=PLAINTEXT://:9092</span><br><span class="line">advertised.listeners=PLAINTEXT://192.168.2.104:9092  # 对应 kafka 运行的机器的 ip 地址</span><br><span class="line">zookeeper.connect=localhost:2181</span><br></pre></td></tr></table></figure></li></ul><h1 id="运行调试"><a href="#运行调试" class="headerlink" title="运行调试"></a>运行调试</h1><p>启动 Kafka，Windows 进入 C:\canal\kafka_2.11-2.0.1\bin\windows 目录下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-server-start.bat ../../config/server.properties</span><br></pre></td></tr></table></figure><p></p><p>新建 topic 为 testDemo 的 Producer，bin\windows 目录下，在该窗口输入任意字符<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-producer.bat --broker-list localhost:9092 --topic testDemo</span><br><span class="line">&gt; 123</span><br></pre></td></tr></table></figure><p></p><p>新建 Consumer，接收 topic 为 testDemo 的消息，bin\windows 目录下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic testDemo</span><br></pre></td></tr></table></figure><p></p><ul><li><a href="https://blog.csdn.net/u012050154/article/details/76270655" target="_blank" rel="noopener">运行参考</a></li></ul><p>查看这个 kafka 服务下所有的 topic<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics.bat --list --zookeeper 127.0.0.1:2181</span><br></pre></td></tr></table></figure><p></p><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ul><li><p>consumer zookeeper is not a recognized option</p><p><a href="https://blog.csdn.net/csdn_sunlighting/article/details/81516646" target="_blank" rel="noopener">办法</a>：版本问题，使用 –bootstrap-server 代替 –zookeeper-server</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;本地运行 
      
    
    </summary>
    
    
      <category term="kafka" scheme="http://suiyia.github.io/tags/kafka/"/>
    
      <category term="Zookeeper" scheme="http://suiyia.github.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Java 基本数据类型与包装类</title>
    <link href="http://suiyia.github.io/2019/10/13/Java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://suiyia.github.io/2019/10/13/Java-基本数据类型与包装类/</id>
    <published>2019-10-13T07:15:00.000Z</published>
    <updated>2019-10-13T07:16:35.451Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>本文主要介绍基本数据类型相关概念、自动拆装箱机制和可能遇到的问题阐述。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>1. </strong>8<strong> 种基本数据类型，具体可以分为下面 3 类：</strong></p><ul><li>数值型<ul><li>整数型：byte、short、int、long</li><li>浮点型：float、double</li></ul></li><li>字符型：char</li><li>布尔型：boolean</li></ul><table><thead><tr><th>基本数据类型</th><th>长度</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>字节、1 byte 就是 1 个字节，8 位二进制，-128 ~ 127</td><td>0</td></tr><tr><td>short</td><td>2 字节，16 位，-2^15 ~ 2^15 - 1</td><td>0</td></tr><tr><td>int</td><td>4 字节，32 位，-2^31 ~ 2^31 - 1</td><td>0</td></tr><tr><td>long</td><td>8 字节，64 位，-2^63 ~ 2^63 -1</td><td>0</td></tr><tr><td>float</td><td>4 字节，32 位；最高位符号位，8 位指数，23 位做基数</td><td>0.0</td></tr><tr><td>double</td><td>8 字节，64 位，最高位符号位，11 位做指数，52 位做基数</td><td>0.0</td></tr><tr><td>char</td><td>2 字节，单一的 16 位 Unicode 字符，最小值是 ‘\u0000’（即为0），最大值是 ‘\uffff’（即为65,535），可以当整数来用，它的每一个字符都对应一个数字</td><td>‘\u0000’</td></tr><tr><td>boolean</td><td></td><td>false</td></tr></tbody></table><blockquote><p>数据类型是程序设计语言描述事物、对象的方法。Java数据类型分为内置类型和扩展类型两大类。内置类型就是 Java 语言本身提供的基本数据类型，比如，整型数，浮点数，字符，布尔值等等。而扩展类型则是Java语言根据基本类型扩展出的其他类型，Java要求所有的扩展类型都必须包括在类定义里面，这就是Java为什么是面向对象编程语言的原因。 <a href="https://zh.wikibooks.org/zh-hans/Java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">Java/数据类型</a></p></blockquote><p><strong>2. 包装类：数值型包装类继承于 Number 类，而 Boolean、Character 自己对基本类型数据进行了封装。</strong></p><ul><li>Byte，public final class Byte extends Number implements Comparable<byte></byte></li><li>Short，public final class Short extends Number implements Comparable<short></short></li><li>Integer</li><li>Long</li><li>Float</li><li>double</li><li>Character</li><li>Boolean</li></ul><p><strong>3. 为什么需要包装类？</strong></p><ul><li><p>Java 是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将 int 、double 等类型放进去的。因为集合的容器要求元素是 Object 类型。</p></li><li><p>为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p></li></ul><h3 id="一些操作"><a href="#一些操作" class="headerlink" title="一些操作"></a>一些操作</h3><p><strong>1. 基本数据类型与包装类型的转换</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">Integer a = Integer.valueOf(i);</span><br><span class="line"></span><br><span class="line">Integer b = new Integer(1);</span><br><span class="line">int j = b.intValue();</span><br></pre></td></tr></table></figure><p></p><p>基本数据类型 -&gt; 包装类型： valueOf 方法；<br>包装类型 -&gt; 基本数据类型： xxxValue 方法</p><p><strong>2. 自动拆装箱机制</strong></p><p>Java 1.5 引入自动装箱和拆箱机制，即将基本数据类型与对应的包装类型进行<strong>自动转换</strong>，自动拆装箱的实现就是应用的 valueOf 方法与 xxxValue 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">integerList.add(1); // 自动装箱，集合声明的元素为 Integer 类型，但可以直接添加 int 类型数据</span><br><span class="line"></span><br><span class="line">Integer a = new Integer(1);</span><br><span class="line">int b = a; // 自动拆箱，一个 Integer 对象也可直接赋值给 int 类型数据</span><br></pre></td></tr></table></figure><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><p><strong>1. boolean 类型数据大小</strong></p><p>Oracle Java 文档指出，boolean 类型数据表示一个 bit 位的信息，但是其大小并不是确定的（The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its “size” isn’t something that’s precisely defined.）</p><p>后来有人做了实验，定义很多个 boolean 类型数据和 int 类型数据，输出它们占用的空间，发现 int 类型数据占用内存大概是 boolean 类型数据的 <strong>4</strong> 倍，得到 boolean 类型数据大小为 1 字节的结论。</p><p>Stack Overflow 上面也有相关讨论，指出单个 boolean 类型数据占用 1 bit，而 boolean 数组每个元素占用 1 字节。</p><p>总而言之，<strong>boolean 数据类型大小定义，占用 1 bit 或 1 字节并不能一概而论，要看具体场景。</strong></p><p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" target="_blank" rel="noopener">The Java™ Tutorials</a></p><p><a href="https://blog.csdn.net/jeffhtlee/article/details/7839377" target="_blank" rel="noopener">Java中boolean到底占几个字节</a></p><p><a href="https://stackoverflow.com/questions/1907318/why-is-javas-boolean-primitive-size-not-defined" target="_blank" rel="noopener">Stack Overflow 参考</a></p><p><strong>3. 基本数据类型缓存机制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer f1 = <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">150</span>, f4 = <span class="number">150</span>;</span><br><span class="line">System.out.println(f1 == f2); <span class="comment">// true</span></span><br><span class="line">System.out.println(f3 == f4); <span class="comment">// false</span></span><br><span class="line">System.out.println(f1.equals(f2)); <span class="comment">// true</span></span><br><span class="line">System.out.println(f3.equals(f4)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在自动装箱的时候，JVM 会<strong>缓存</strong> -128 ~ 127 之间的 int 值，所以当该 int i &gt;= -128 &amp;&amp; i &lt;= 127 时，会直接返回已缓存的 Integer 对象，否则新建一个 Integer 对象。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>f1 == f2 返回 true ，是因为 Integer f1 = 100 发生了自动装箱操作。</p><p>f3 == f4 返回 false，是因为 150 不在那个缓存区间，所以返回的是新的对象，所以不相等。</p><p><strong>4. 三目运算符引发的空指针异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Boolean&gt; map =  <span class="keyword">new</span> HashMap&lt;String, Boolean&gt;();</span><br><span class="line">Boolean b = (map!=<span class="keyword">null</span> ? map.get(<span class="string">"test"</span>) : <span class="keyword">false</span>); <span class="comment">// 抛出 NullPointerException</span></span><br><span class="line"></span><br><span class="line">Boolean b = (map!=<span class="keyword">null</span> ? map.get(<span class="string">"test"</span>) : Boolean.FALSE); <span class="comment">// 正确做法，都转换为对象，就不会发生拆箱操作</span></span><br></pre></td></tr></table></figure><p>三目运算符，当第二个参数和第三个参数是基本类型和对象时，会对对象进行<strong>拆箱</strong>操作，那么 map.get(“test”) 转换为 map.get(“test”).booleanValue()，由于 map.get(“test”) 为 null，而 null.booleanValue() 就会抛出空指针异常。</p><p>正确的做法就是将三目运算符第二个参数和第三个参数的<strong>类型一致</strong>即可。</p><p><a href="http://www.hollischuang.com/archives/435" target="_blank" rel="noopener">自动拆箱导致空指针异常</a></p><p><strong>5. void 是否是基本数据类型？</strong></p><blockquote><p>Void 类是一个不可实例化的占位符类，它持有对 Java 关键字 void 的 Class 对象的引用。</p></blockquote><p><strong>值类型或者引用类型的数据不同，表现在内存的分配方式</strong>，由于 void 不能 new 出对象，也就不能在<strong>堆</strong>中分配值，那就是一开始在<strong>栈</strong>中分配好空间了，所以这样也可以说它是基本数据类型。</p><p>不过绝大部分场合说 8 种是没有问题的。</p><p><a href="https://blog.csdn.net/DaJian35/article/details/50964039" target="_blank" rel="noopener">Java中Void是基本类型吗？基本类型是8种还是9种？</a></p><p><a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="noopener">JDK 中文在线</a></p><h3 id="博客参考"><a href="#博客参考" class="headerlink" title="博客参考"></a>博客参考</h3><p><a href="https://www.hollischuang.com/archives/2700" target="_blank" rel="noopener">一文读懂什么是Java中的自动拆装箱</a></p><p><a href="https://www.jianshu.com/p/cc9312104876" target="_blank" rel="noopener">Java的自动拆装箱</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;本文主要介
      
    
    </summary>
    
    
      <category term="Java Core" scheme="http://suiyia.github.io/tags/Java-Core/"/>
    
  </entry>
  
  <entry>
    <title>canal学习一：本地运行 canal</title>
    <link href="http://suiyia.github.io/2019/10/13/canal%E5%AD%A6%E4%B9%A0%E4%B8%80%EF%BC%9A%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C-canal/"/>
    <id>http://suiyia.github.io/2019/10/13/canal学习一：本地运行-canal/</id>
    <published>2019-10-13T07:14:00.000Z</published>
    <updated>2019-10-13T07:15:06.365Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p><strong>a. canal 是什么？</strong></p><ul><li>MySQL 数据库 Binlog 的增量订阅 &amp; 消费组件。简单来说，它可以监测 MySQL 的数据变化情况。</li></ul><p><strong>b. 用途</strong></p><ul><li>数据同步、主从复制、数据库镜像等业务场景。</li></ul><p><strong>主要内容：</strong> 本地运行 canal，对数据库进行数据变更，查看 canal 输出结果。</p><p><strong>运行环境：</strong> Ubuntu 18.04 LTS ；虚拟机，内存分配 4G；Windwos 系统运行步骤类似。</p><h3 id="2-基本环境配置"><a href="#2-基本环境配置" class="headerlink" title="2. 基本环境配置"></a>2. 基本环境配置</h3><ul><li><strong>git</strong>：apt install git</li><li><strong>maven</strong>：apt install maven</li><li><p><strong>MySQL</strong>：<a href="http://wiki.ubuntu.org.cn/MySQL%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">安装地址</a>，目前 canal 开源版本支持支持 <strong>5.7</strong> 及以下的版本</p><ul><li><p>如果已经安装 MySQL，先查看 MySQL 版本，版本太高或太低会有兼容性问题。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select version();</span><br></pre></td></tr></table></figure></li><li><p>更改 MySQL 配置，目录为 /etc/mysql/mysql.conf.d/mysqld.cnf，Windows 系统配置文件在 C:\ProgramData\MySQL\MySQL Server 5.7，文件的开头已经标明「The MySQL database server configuration file」，在 [mysqld] 下面增加如下字段：</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin <span class="comment">#添加这一行就ok</span></span><br><span class="line">binlog-format=ROW <span class="comment">#选择row模式</span></span><br><span class="line">server_id=1 <span class="comment">#配置mysql replaction需要定义，不能和canal的slaveId重复</span></span><br><span class="line"></span><br><span class="line">重启 MySQL，执行：</span><br><span class="line">mysql &gt; SHOW MASTER STATUS;   // 看是否有结果，返回 binlog 名称以及位置</span><br><span class="line">mysql &gt; SHOW VARIABLES LIKE '%binlog_format%'; // 查看配置文件是否生效，应该返回 ROW</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>创建子用户，赋予相关权限，用于读取 MySQL Binlog 日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> canal <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'canal'</span>;  </span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">SHOW</span> <span class="keyword">VIEW</span>, <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span>, <span class="keyword">REPLICATION</span> <span class="keyword">CLIENT</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'canal'</span>@<span class="string">'%'</span>;</span><br><span class="line"><span class="comment">-- GRANT ALL PRIVILEGES ON *.* TO 'canal'@'%' ; 需要具有SHOW VIEW 权限</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>JDK</strong>：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-ubuntu-16-04" target="_blank" rel="noopener">安装配置地址</a>，并设置 JAVA_HOME 路径</li></ul><h3 id="3-canal-本地运行"><a href="#3-canal-本地运行" class="headerlink" title="3. canal 本地运行"></a>3. canal 本地运行</h3><p>a. 下载解压，并修改配置文件</p><ul><li><a href="https://github.com/alibaba/canal/releases" target="_blank" rel="noopener">release 下载页</a> ，下载解压 canal.deployer-xxx.tar.gz</li><li>编辑 canal.deployer-xxx/conf/example/instance.properties，下面是需要注意<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">canal.instance.master.address = 127.0.0.1:3306  # Mysql 地址端口</span><br><span class="line">canal.instance.dbUsername = canal # 用于读取 binlog 日志的用户，测试环境可以用 root 用户代替</span><br><span class="line">canal.instance.dbPassword = canal</span><br><span class="line">canal.instance.defaultDatabaseName = test # 选择对 test 数据库进行监控</span><br><span class="line">canal.instance.filter.regex = .\..  # 正则匹配需要监控的表</span><br></pre></td></tr></table></figure></li></ul><p>b. 运行</p><ul><li>canal.deployer-xxx/bin 目录下，运行 ./startup.sh</li><li>查看日志：vi logs/example/example.log，vi logs/canal/canal.log 查看 canal 是否报错。</li></ul><p>c. 对数据库 test 进行数据变更，查看 canal 输出</p><ul><li><a href="https://github.com/alibaba/canal/releases" target="_blank" rel="noopener">demo 工程下载地址</a>，下载 canal.example-xxx.tar.gz ，bin 目录下直接执行 ./startup.sh</li><li>进入 canal.example-xxx/logs 目录，对数据库进行增删改操作，可以发现有输出，那么 canal 的本地运行算是成功了。</li></ul><h3 id="4-配置文件解读"><a href="#4-配置文件解读" class="headerlink" title="4. 配置文件解读"></a>4. 配置文件解读</h3><p>下载 release 包 ，其中配置可以分为两个部分：</p><ul><li>canal.properties：系统根配置文件，分为两个小部分。common argument 定义全局 canal server 属性，destinations 定义多个 instance 的部分属性</li><li>instance.properties：具体的单个实例的配置</li></ul><p><strong>1. canal.properties 配置如下，主要讲解我觉得需要注意的地方：</strong><br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>################################################</span><br><span class="line"><span class="meta">#</span>######## common argument#############   定义 canal server 属性</span><br><span class="line"><span class="meta">#</span>################################################</span><br><span class="line">canal.id= 1</span><br><span class="line">canal.ip=    # canal server 绑定的本地IP信息，如果不配置，默认选择一个本机IP进行启动服务</span><br><span class="line">canal.port=11111   #canal server 对外提供服务的端口</span><br><span class="line">canal.zkServers=127.0.0.1:2181   # canal server 链接 zookeeper 集群的链接信息，多个用 逗号分隔</span><br><span class="line"><span class="meta">#</span> tcp, kafka, RocketMQ </span><br><span class="line">canal.serverMode = tcp  # 服务方式，默认为 tcp，如果需要将 canal 消息发送到 kafka 就选 kafka</span><br><span class="line">canal.instance.tsdb.dbUsername=canal # 数据库用户名</span><br><span class="line">canal.instance.tsdb.dbPassword=canal # 密码</span><br><span class="line"><span class="meta">#</span>################################################</span><br><span class="line"><span class="meta">#</span>######## destinations############# instance列表定义，列出当前server上有多少个instance</span><br><span class="line"><span class="meta">#</span>################################################</span><br><span class="line">canal.destinations= example  # 当前server上部署的instance列表，定义了canal.destinations后，需要在canal.conf.dir对应的目录下建立同名的文件，多个实例用 逗号分隔 canal.destinations = example1,example2</span><br><span class="line"><span class="meta">#</span> conf root dir</span><br><span class="line">canal.conf.dir = ../conf </span><br><span class="line"><span class="meta">#</span> auto scan instance dir add/remove and start/stop instance</span><br><span class="line">canal.auto.scan = true # instance 文件变化会立马表现出，不用重新启动 canal server</span><br><span class="line">canal.auto.scan.interval = 5</span><br><span class="line"></span><br><span class="line">canal.instance.global.mode = spring </span><br><span class="line">canal.instance.global.lazy = false</span><br><span class="line">canal.instance.global.spring.xml = classpath:spring/file-instance.xml  # canal 实例通过 file-instance.xml 方式加载</span><br></pre></td></tr></table></figure><p></p><p><strong>2. instance.properties 单个实例的具体配置，每个 canal.destinations 内定义的实例都会有这个配置文件</strong><br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">canal.instance.master.address=127.0.0.1:3306 # 监控的数据库地址</span><br><span class="line">canal.instance.dbUsername=canal # 监控的数据库用户名</span><br><span class="line">canal.instance.dbPassword=canal</span><br><span class="line">canal.instance.connectionCharset = UTF-8</span><br><span class="line">canal.instance.defaultDatabaseName =test # 选择监控的数据库</span><br><span class="line">canal.instance.filter.regex=.*\\..* # 白名单，选择监控哪些表</span><br><span class="line">canal.instance.filter.black.regex=  # 黑名单，选择不监控哪些表</span><br></pre></td></tr></table></figure><p></p><h3 id="5-本地运行遇到的问题"><a href="#5-本地运行遇到的问题" class="headerlink" title="5. 本地运行遇到的问题"></a>5. 本地运行遇到的问题</h3><ul><li><p>Windows 平台运行 canal，点击 startup.bat 秒退。</p><p>解决：在 startup.bat 最后添加 pause，查看具体报错原因</p></li><li><p>‘Error: missing ‘server’ JVM at `C:\Program Files (x86)\Java\jre1.8.0_181\bin\server\jvm.dll’</p><p>解决：环境配置问题，将 Java\jre1.8.0_181\bin\client 文件夹内文件移动到 Java\jre1.8.0_181\bin\server 目录下，没有 server 目录就新建一个。<br><a href="https://stackoverflow.com/a/52198523" target="_blank" rel="noopener">参考</a></p></li><li><p>异常 [MultiStageCoprocessor-other-example-0] WARN com.taobao.tddl.dbsync.binlog.LogDecoder - Decoding Query failed from: binlog.000012:2831 java.io.IOException: Read Q_FLAGS2_CODE error: limit excceed: 64</p><p>解决： 兼容性问题，使用 MySQL 5.7 ，该错误会在后续版本更新 <a href="https://github.com/alibaba/canal/wiki/BinlogChange%28MySQL8%29" target="_blank" rel="noopener">https://github.com/alibaba/canal/wiki/BinlogChange%28MySQL8%29</a></p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h
      
    
    </summary>
    
    
      <category term="canal" scheme="http://suiyia.github.io/tags/canal/"/>
    
  </entry>
  
  <entry>
    <title>MQTT 简单介绍与实现</title>
    <link href="http://suiyia.github.io/2019/10/13/MQTT-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://suiyia.github.io/2019/10/13/MQTT-简单介绍与实现/</id>
    <published>2019-10-13T07:10:00.000Z</published>
    <updated>2019-10-13T07:13:03.966Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --><h3 id="1-MQTT-介绍"><a href="#1-MQTT-介绍" class="headerlink" title="1. MQTT 介绍"></a>1. MQTT 介绍</h3><ul><li>它是一种 机器之间通讯 machine-to-machine (M2M)、物联网 Internet of Things （IoT）常用的一种轻量级消息传输协议</li><li>适用于网络带宽较低的场合</li><li>包含发布、订阅模式，通过一个代理服务器（broker），任何一个客户端（client）都可以订阅或者发布某个主题的消息，然后订阅了该主题的客户端则会收到该消息</li></ul><h4 id="1-1-消息主题"><a href="#1-1-消息主题" class="headerlink" title="1.1 消息主题"></a>1.1 消息主题</h4><ul><li>发布消息或者订阅消息都要选定一个消息主题，消息主题可以任意定制，类似文件系统，用 “/” 进行分隔，例如主题为 /a/b/c/d 的消息</li><li>客户端可以使用完全字符匹配消息，也可以使用<strong>通配符</strong>进行消息匹配<ul><li>通配符 + ：替换任意单个层级。比如订阅 /a/b/c/d、/a/+/c/d 、+/+/+/+ 主题的消息即可收到主题为 /a/b/c/d 的消息，而 b/+/c/d 、 +/+/+ 不会匹配</li><li>通配符 # ：匹配任意层级，只能用于<strong>末尾</strong>， #、a/# 可以匹配上面的主题消息</li></ul></li><li>长度为 0 的<strong>主题层级</strong>也是允许的。比如发布主题为 a//topic 的消息，客户端可以用 a/+/topic 进行匹配。/a/topic 的主题用 +/a/topic、#、/# 可以匹配。</li></ul><h4 id="1-2-服务质量（Quality-of-Service，QoS）"><a href="#1-2-服务质量（Quality-of-Service，QoS）" class="headerlink" title="1.2 服务质量（Quality of Service，QoS）"></a>1.2 服务质量（Quality of Service，QoS）</h4><p>MQTT 定义了三种客户端与代理服务器之间消息到达的难度</p><ul><li>0：broker/client 之间消息<strong>传一次</strong>，并不确认传到没有，消息可能丢失</li><li>1：broker/client 之间消息<strong>至少一次</strong>，带确认消息的传输，可能重复收到</li><li>2：broker/client 之间消息<strong>仅有一次</strong>，利用<strong>四次握手</strong>进行确认，网络延迟可能会增加</li></ul><p>当客户端订阅的消息质量与代理服务器发布主题的质量不同时，客户端会选择难度最小的 QoS 接收消息</p><ul><li>发布等级为 2 ，客户端订阅等级为 0， 那么客户端接收到的 QoS = 0</li><li>发布等级为 0 ，订阅等级为 2，那么客户端接收到的 QoS = 0</li></ul><h4 id="1-3-消息保留"><a href="#1-3-消息保留" class="headerlink" title="1.3 消息保留"></a>1.3 消息保留</h4><ul><li>即当 broker <strong>正在</strong>发送消息给 client 时，消息会保存，如果此时有新的 client 订阅了该主题的消息，那么它也会收到消息。这种做法的好处就是当消息主题经常变换的时候，如果有新的 client 订阅该消息，那么它不用等待太长的时间就可以收到消息</li></ul><h4 id="1-4-会话清除"><a href="#1-4-会话清除" class="headerlink" title="1.4 会话清除"></a>1.4 会话清除</h4><ul><li>client 可以设置 clean session 标志位，当 clean session = false 时，client 失去连接时， broker 会一直保留消息直到 client 重新连接。而 clean session = true 时，broker 会清除所有的消息当这个 client 失去连接。</li></ul><h4 id="1-5-消息意愿"><a href="#1-5-消息意愿" class="headerlink" title="1.5 消息意愿"></a>1.5 消息意愿</h4><ul><li>当 client 连接上 broker 时，client 会提示 broker 它有一个意愿消息，这个意愿消息将会在 client 失去连接时，broker 发送出去。消息意愿和普通消息一样都包含主题和内容。</li></ul><hr><h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h3><p>用实例验证上面的概念</p><h4 id="2-1-代理服务器"><a href="#2-1-代理服务器" class="headerlink" title="2.1 代理服务器"></a>2.1 代理服务器</h4><p>实现了 MQTT 的代理服务器有很多种，我们使用 <a href="https://mosquitto.org/download/" target="_blank" rel="noopener">mosquitto</a></p><p><img src="/images\mqtt.png" alt="upload successful"></p><h4 id="2-2-mosquitto-实现过程"><a href="#2-2-mosquitto-实现过程" class="headerlink" title="2.2 mosquitto 实现过程"></a>2.2 mosquitto 实现过程</h4><ul><li>下载安装 mosquitto，进入 mosquitto 安装目录，新开当前目录的命令行 A，执行命令 mosquitto -c mosquitto.conf，表示通过执行这个配置文件实现代理服务，如果命令窗口没有任何输出表示启动成功，配置文件内容介绍可以自己网上了解</li><li>然后在当前目录下，新开命令行 B，执行 mosquitto_sub -t name，表示订阅主题为 name 的消息</li><li>同样在当前目录，新开命令行 C，执行 mosquitto_pub -t name -m 123，表示发布主题为 name ，内容为 123 的消息</li><li>命令行 B 收到 123 消息表示整个过程实现 OK</li></ul><h4 id="2-3-一个-Chorme-应用"><a href="#2-3-一个-Chorme-应用" class="headerlink" title="2.3 一个 Chorme 应用"></a>2.3 一个 Chorme 应用</h4><p>这里介绍一个能够监听本地 MQTT 消息的应用 <strong>MQTTLens</strong>，去 Chorme 网上应用店下载</p><ul><li>安装好后新建连接，配置如下</li></ul><p><img src="/images\mqtt配置.png" alt="upload successful"></p><ul><li>圆角图标是绿色表示连接成功</li><li>接下来你就可以在软件里面，订阅、发布任意 MQTT 消息了，非常方便！</li></ul><h4 id="博文参考"><a href="#博文参考" class="headerlink" title="博文参考"></a>博文参考</h4><p><a href="https://blog.csdn.net/qq_29350001/article/details/76680646" target="_blank" rel="noopener">MQTT再学习 – 搭建MQTT服务器及测试</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 17 2019 13:59:47 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;1-MQTT-介绍&quot;&gt;&lt;a href=&quot;#1-MQTT-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. MQTT 介
      
    
    </summary>
    
    
      <category term="MQTT" scheme="http://suiyia.github.io/tags/MQTT/"/>
    
  </entry>
  
</feed>
