<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸟日常</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suiyia.github.io/"/>
  <updated>2019-10-10T14:09:25.600Z</updated>
  <id>http://suiyia.github.io/</id>
  
  <author>
    <name>Answer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL学习——基础概念了解</title>
    <link href="http://suiyia.github.io/2019/10/10/MySQL%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%BA%86%E8%A7%A3/"/>
    <id>http://suiyia.github.io/2019/10/10/MySQL学习——基础概念了解/</id>
    <published>2019-10-10T13:44:00.000Z</published>
    <updated>2019-10-10T14:09:25.600Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h3 id="MySQL-主从复制原理"><a href="#MySQL-主从复制原理" class="headerlink" title="MySQL 主从复制原理"></a>MySQL 主从复制原理</h3><p><a href="https://zhuanlan.zhihu.com/p/50597960" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50597960</a></p><p>MySQL主从复制涉及到三个线程</p><ul><li>主节点 binary log dump 线程</li></ul><p>当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。</p><ul><li>从节点 I/O线程</li></ul><p>当从节点上执行<code>start slave</code>命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点binlog dump 进程发来的更新之后，保存在本地relay-log中。</p><ul><li>从节点SQL线程</li></ul><p>SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。</p><h3 id="binlog-记录格式"><a href="#binlog-记录格式" class="headerlink" title="binlog 记录格式"></a>binlog 记录格式</h3><ul><li><p>基于SQL语句，只需要记录会修改数据的sql语句到binlog中，减少了binlog日质量，节约I/O，提高性能。缺点是在某些情况下，会导致主从节点中数据不一致（比如sleep(),now()等）。</p></li><li><p>基于行，只记录哪条数据被修改了，修改成什么样。优点是不会出现某些特定情况下的存储过程、或者函数、或者trigger的调用或者触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是修改table的时候会让日志暴增,同时增加bin log同步时间。也不能通过bin log解析获取执行过的sql语句，只能看到发生的data变更。</p></li><li><p>混合模式，一般的复制使用STATEMENT模式保存到binlog，对于STATEMENT模式无法复制的操作则使用ROW模式来保存，MySQL会根据执行的SQL语句选择日志保存方式。</p></li></ul><h3 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型"></a>日志类型</h3><ul><li><p>错误日志，记录出错信息，也记录一些警告信息或者正确的信息</p></li><li><p>查询日志，记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行</p></li><li><p>慢查询日志，设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</p></li><li><p>二进制日志，记录对数据库执行更改的所有操作</p></li><li><p>中继日志，事务日志</p></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>（<a href="https://juejin.im/entry/5b57ec015188251aa8292a69）" target="_blank" rel="noopener">https://juejin.im/entry/5b57ec015188251aa8292a69）</a></p><ul><li><p>整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。</p></li><li><p>实数，包括FLOAT、DOUBLE、DECIMAL。DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p></li><li><p>字符串类型，包括 VARCHAR、CHAR、TEXT、BLOB。VARCHAR 用于存储可变长字符串，它比 CHAR 定长类型更节省空间；当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。</p></li><li><p>枚举类型，把不重复的数据存储为一个预定义的集合。有时可以使用ENUM代替常用的字符串类型。ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。ENUM在内部存储时，其实存的是整数。尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。排序是按照内部存储的整数</p></li><li><p>日期时间类型，尽量使用timestamp，空间效率高于datetime，用整数保存时间戳通常不方便处理。如果需要存储微妙，可以使用bigint存储。</p></li></ul><h3 id="SQL-语句分类"><a href="#SQL-语句分类" class="headerlink" title="SQL 语句分类"></a>SQL 语句分类</h3><ul><li>DDL：数据定义语言（create drop alter）</li><li>DML：数据操作语句（insert update delete）</li><li>DQL：数据查询语句（select ）</li><li>DCL：数据控制语句，进行授权和权限回收（grant revoke）</li><li>TPL：数据事务语句（commit collback savapoint）</li></ul><h3 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h3><p>减少数据冗余、查询需要多表关联</p><ul><li><p>第一范式：属性具有原子性，不可再分解。</p></li><li><p>第二范式：记录具有唯一标识，即实体唯一性。通常需要为表加上一个列， 以存储各个实例的惟一标识。</p></li><li><p>第三范式：任何字段不能由其它字段派生而来，要求字段没有冗余。第三范式具有如下特征：1， 每一列只有一个值。2， 每一行都能区分。3， 每一个表都不包含其他表已经包含的非主关键字信息。</p></li></ul><h3 id="MyISAM表格将在哪里存储，并且还提供其存储格式"><a href="#MyISAM表格将在哪里存储，并且还提供其存储格式" class="headerlink" title="MyISAM表格将在哪里存储，并且还提供其存储格式?"></a>MyISAM表格将在哪里存储，并且还提供其存储格式?</h3><p>每个MyISAM表格以三种格式存储在磁盘上：</p><ul><li><p>“.frm”文件存储表定义</p></li><li><p>数据文件具有“.MYD”(MYData)扩展名</p></li><li><p>索引文件具有“.MYI”(MYIndex)扩展名</p></li></ul><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p><a href="https://juejin.im/post/5c91b5d7e51d456f957ebd10" target="_blank" rel="noopener">一条SQL语句在MySQL中是如何执行的</a></p><p><a href="https://zhuanlan.zhihu.com/p/50597960" target="_blank" rel="noopener">MySQL 主从复制原理</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;MySQL-主从复制原理&quot;&gt;&lt;a href=&quot;#MySQL-主从复制原理&quot; class=&quot;headerlink&quot; title=&quot;MyS
      
    
    </summary>
    
      <category term="MySQL" scheme="http://suiyia.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://suiyia.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习——锁</title>
    <link href="http://suiyia.github.io/2019/10/10/MySQL%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%94%81/"/>
    <id>http://suiyia.github.io/2019/10/10/MySQL学习——锁/</id>
    <published>2019-10-10T13:40:00.000Z</published>
    <updated>2019-10-10T13:40:52.857Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="加锁策略"><a href="#加锁策略" class="headerlink" title="加锁策略"></a>加锁策略</h2><ul><li><p>乐观锁：乐观锁总是假设最好的情况，乐观锁常见实现：</p><ul><li><p>版本号控制，数据行保存 version 字段，修改时会变化。<a href="https://segmentfault.com/a/1190000012650596" target="_blank" rel="noopener">MySQL-InnoDB-MVCC多版本并发控制</a></p></li><li><p>CAS 算法（compare and swap），CAS算法涉及到三个操作数，需要读写的内存值 V，进行比较的值 A，拟写入的新值 B。 当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p></li><li><p>CAS 常见问题</p><ul><li>ABA问题：一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值。在这段时间它的值可能被改为其他值，然后又改回A</li><li>循环时间长开销大：自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</li><li>只能保证一个共享变量的原子操作：CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。</li></ul></li></ul></li><li><p>悲观锁：总是假设最坏的情况，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</p></li></ul><h2 id="锁粒度分类"><a href="#锁粒度分类" class="headerlink" title="锁粒度分类"></a>锁粒度分类</h2><ul><li><p>表锁，粒度最大，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁 。</p></li><li><p>行锁，粒度最小 的一种锁，只针对当前操作的<strong>行的索引进行加锁</strong>。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</p></li></ul><p>InnoDB支持的行级锁：</p><ul><li><p>Record Lock: 对索引项加锁，锁定符合条件的行。</p></li><li><p>Gap Lock: 对索引项之间的“间隙”加锁，不包括记录本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。</p></li><li><p>Next-key Lock： 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。</p></li></ul><p>相关知识点：</p><ol><li>innodb对于行的查询使用next-key lock</li><li>Next-locking keying为了解决Phantom Problem幻读问题</li><li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li><li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li><li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li></ol><h2 id="锁可写分类"><a href="#锁可写分类" class="headerlink" title="锁可写分类"></a>锁可写分类</h2><ul><li><p>共享锁（S），如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不 能加排他锁。获取共享锁的事务只能读数据，不能修改数据。</p></li><li><p>排他锁（X），如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获取排他锁的事务既能读数据，又能修改数据。</p></li><li><p>意向共享锁（IS）： 表示事务准备给数据行记入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁。</p></li><li><p>意向排他锁（IX）： 表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁。</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; title=&quot;锁&quot;&gt;&lt;/a&gt;锁&lt;/h1&gt;&lt;h2 id=&quot;加锁策略
      
    
    </summary>
    
      <category term="MySQL" scheme="http://suiyia.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://suiyia.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习——事务</title>
    <link href="http://suiyia.github.io/2019/10/10/MySQL%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1/"/>
    <id>http://suiyia.github.io/2019/10/10/MySQL学习——事务/</id>
    <published>2019-10-10T13:39:00.000Z</published>
    <updated>2019-10-10T14:13:30.580Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>一系列操作，事务中的操作要么全部成功，要么全部失败。</p><h2 id="事务四大特性（ACID）"><a href="#事务四大特性（ACID）" class="headerlink" title="事务四大特性（ACID）"></a>事务四大特性（ACID）</h2><ul><li><p>原子性：事务中所有操作，要么全部成功；要么撤回到执行事务之前的状态。</p></li><li><p>一致性：事务的执行使得数据库从一种正确状态转换成另一种正确状态。</p></li><li><p>隔离性：事务操作之间彼此独立和透明互不影响。</p></li><li><p>持久性：事务一旦提交，其结果就是永久的。即便发生系统故障，也能恢复。</p></li></ul><h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><ul><li><p>脏读（Dirty Read）：一个事务可以读取其他事务未提交的执行结果</p></li><li><p>丢失修改（Lost to modify）：第一个事务中修改了这个数据后，第二个事务也修改了这个数据。</p></li><li><p>不可重复读（Nonrepeatable Read）：在同一次事务中，同一个查询在 T1 时间内<strong>读取某一行</strong>，在 T2 时间重新读取这一行，这一行发生了 <strong>UPDATE</strong> 或者 <strong>DELETE</strong>。</p></li><li><p>幻读（Phantom Read）：用户读取<strong>某一范围</strong>的数据行时，另外一个事务在范围内<strong>插入（insert）</strong>了新行，用户再次读取时，发现新的幻影行。</p></li></ul><p>不可重复读重点在于 update 和 delete，而幻读的重点在于 insert。</p><p>InnoDB 通过多版本并发控制（MVCC，Multiversion Conccurrency Control）解决不可重复读问题，在此基础上通过间隙锁解决幻读问题。</p><h2 id="事务隔离级别（解决并发事务带来的问题）"><a href="#事务隔离级别（解决并发事务带来的问题）" class="headerlink" title="事务隔离级别（解决并发事务带来的问题）"></a>事务隔离级别（解决并发事务带来的问题）</h2><ul><li><p>读未提交（Read Uncommited）：所以事务能够看到其它未提交事务的结果。</p></li><li><p>读已提交（Read Commited）：一个事务只能看到其它已经提交事务的结果。</p></li><li><p>可重复读（Repeatable Read）：MySQl 默认事务级别，确保同一事务的多个实例在并发读取数据时，会看到相同的数据行。幻读（）</p></li><li><p>串行化（Serializable）：强制事务排序，使之不可能出现冲突。在读取的数据行上面加上共享锁</p></li></ul><h2 id="事务保证数据一致性原理（TODO）"><a href="#事务保证数据一致性原理（TODO）" class="headerlink" title="事务保证数据一致性原理（TODO）"></a>事务保证数据一致性原理（TODO）</h2><ul><li><p>redo log 进入 prepare 状态，记录 binlog，redo log 改为提交状态。</p></li><li><p>事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的lsn(log sequence number)号; 当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;p&gt;一系列操作
      
    
    </summary>
    
      <category term="MySQL" scheme="http://suiyia.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://suiyia.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习——索引</title>
    <link href="http://suiyia.github.io/2019/10/10/MySQL%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/"/>
    <id>http://suiyia.github.io/2019/10/10/MySQL学习——索引/</id>
    <published>2019-10-10T13:38:00.000Z</published>
    <updated>2019-10-10T14:11:32.824Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是一种数据结构,可以帮助我们快速的进行数据的查找。InnoDB 存储引擎的默认索引实现为 B+ 树索引。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><ul><li><p>普通索引（index）：最基本的索引，没有任何约束限制。</p></li><li><p>唯一索引（unique）：和普通索引类似，但是具有唯一性约束，允许有空值，一个表可以有多个唯一索引。</p></li><li><p>主键索引（primary key）：特殊的唯一索引，不允许有空值，保证实体完整性，一个表只能有一个主键。</p></li><li><p>联合索引：将多个列组合在一起创建索引，可以覆盖多个列。（也叫复合索引，组合索引）</p></li><li><p>全文索引：主要用于查找文本中的关键字，并不是直接与索引中的值进行比较。fulltext更像是一个搜索引擎，配合match against操作使用，而不是一般的where语句加like。</p></li></ul><h2 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h2><p>MyISAM 和 InnoDB 都使用 B+Tree 实现。MyISAM 叶子节点存放数据记录的地址，要找到该数据还需要去该地址寻找。InnoDB 叶子节点就是数据本身，数据表的主键作为索引的 key。-</p><p>聚簇索引，MySQL索引是用一种叫做聚簇索引的数据结构实现的，是一种数据存储方式，它实际上是在同一个结构中保存了B+树索引和数据行，InnoDB表是按照聚簇索引组织的（类似于Oracle的索引组织表）。</p><p>聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接指向对应数据块。</p><h2 id="explain-用法字段含义-分析是否有用到索引"><a href="#explain-用法字段含义-分析是否有用到索引" class="headerlink" title="explain 用法字段含义(分析是否有用到索引)"></a>explain 用法字段含义(分析是否有用到索引)</h2><ul><li><p>select_type 表示查询中每个 select 子句的类型</p></li><li><p>type 表示MySQL在表中找到所需行的方式，又称“访问类型”</p></li><li><p>possible_keys 指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</p></li><li><p>key 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL</p></li><li><p>key_len 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</p></li><li><p>ref 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p></li><li><p>Extra 包含不适合在其他列中显示但十分重要的额外信息</p></li></ul><h2 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h2><ul><li><p>% 开头的 like 模糊匹配</p></li><li><p>or 前后语句没有同时使用索引</p></li><li><p>数据类型出现隐式转化（字符串列查询没有使用引号）</p></li><li><p>索引列进行运算</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;p&gt;索引是一种
      
    
    </summary>
    
      <category term="MySQL" scheme="http://suiyia.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://suiyia.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 链表中倒数第k个节点</title>
    <link href="http://suiyia.github.io/2019/09/25/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://suiyia.github.io/2019/09/25/剑指offer题解-链表中倒数第k个节点/</id>
    <published>2019-09-25T14:45:00.000Z</published>
    <updated>2019-09-25T14:44:08.380Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，输出该链表中倒数第k个结点。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>设定两个标志位，low 和 high，high 先走 k-1 步，剩下的 low 和 high 一起走，high 等于 null 时就返回 low 节点</p></li><li><p>考虑链表长度为空，链表长度小于 k 的情况</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">    if (head == null)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode low = head;</span><br><span class="line">    ListNode high = head;</span><br><span class="line">    for (int i = 0; i &lt;= k-1; i++) &#123;</span><br><span class="line">        if (head == null &amp;&amp; i &lt; k)&#123;</span><br><span class="line">        // 链表长度小于 k</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        high = head.next;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (high != null)&#123;</span><br><span class="line">        low = low.next;</span><br><span class="line">        high = high.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 反转链表</title>
    <link href="http://suiyia.github.io/2019/09/25/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://suiyia.github.io/2019/09/25/剑指offer题解-反转链表/</id>
    <published>2019-09-25T14:44:00.000Z</published>
    <updated>2019-09-25T15:36:34.199Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，反转链表后，输出新链表的表头。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li>两个索引位保存链的指向信息，然后同步右移，原地反转</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">      if (head == null)&#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode low = null;</span><br><span class="line">       ListNode high = null;</span><br><span class="line">       while (head != null)&#123;</span><br><span class="line">           high = head.next;</span><br><span class="line">           head.next = low;</span><br><span class="line">           low = head;</span><br><span class="line">           head = high;</span><br><span class="line">       &#125;</span><br><span class="line">       return low;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 调整数组顺序使奇数位于偶数前面</title>
    <link href="http://suiyia.github.io/2019/09/24/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <id>http://suiyia.github.io/2019/09/24/剑指offer题解-调整数组顺序使奇数位于偶数前面/</id>
    <published>2019-09-24T15:40:00.000Z</published>
    <updated>2019-09-24T15:42:10.869Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分</p><p>并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>插入排序</p></li><li><p>从左自右找到第一个偶数，然后在该位置右边找到第一个奇数，进行交换。</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void reOrderArray(int [] array) &#123;</span><br><span class="line">    if (array.length == 0 || array.length == 1)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while (i &lt; array.length)&#123;</span><br><span class="line">    // 找到第一个偶数</span><br><span class="line">        while ((array[i] &amp; 1) == 1)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        j = i + 1;</span><br><span class="line">        while (j &lt; array.length)&#123;</span><br><span class="line">        // 找到第一个奇数</span><br><span class="line">            if ((array[j] &amp; 1) == 0)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 插入排序</span><br><span class="line">        if (j &lt; array.length)&#123;</span><br><span class="line">            int temp = array[j];</span><br><span class="line">            for (int k = j-1; k &gt;= i ; k--) &#123;</span><br><span class="line">                array[k+1] = array[k];</span><br><span class="line">            &#125;</span><br><span class="line">            array[i++] = temp;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 数值的整数次方</title>
    <link href="http://suiyia.github.io/2019/09/24/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <id>http://suiyia.github.io/2019/09/24/剑指offer题解-数值的整数次方/</id>
    <published>2019-09-24T14:22:00.000Z</published>
    <updated>2019-09-24T14:58:09.152Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>主要考察 指数函数 的特征以及程序的健壮性</p></li><li><p>底数不能为负数</p></li><li><p>底数为 0 时，0 的 n 次方始终为 0</p></li><li><p>指数为 0 时，且任意数的 0 次方都是 1</p></li><li><p>指数为负数时，结果是越来越小的</p></li><li><p>常规思路：循环累乘，时间复杂度 0（N）</p></li><li><p>递归思路：当n为偶数，a^n =（a^n/2）×（a^n/2），当 n为奇数，a^n = a^[(n-1)/2] × a^[(n-1)/2] * a</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 循环思路</span><br><span class="line">public double Power(double base, int exponent) &#123;</span><br><span class="line">    if (base == 0 )&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exponent == 0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean flag = false;</span><br><span class="line">    if (exponent &lt; 0)&#123;</span><br><span class="line">        exponent = -1*exponent;</span><br><span class="line">        flag = true;</span><br><span class="line">    &#125;</span><br><span class="line">    double result = 1;</span><br><span class="line">    for (int i = 0; i &lt; exponent; i++) &#123;</span><br><span class="line">        result = result * base;</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag)&#123;</span><br><span class="line">        return 1.0/result;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 递归思路</span><br><span class="line">public double Power1(double base, int expone</span><br><span class="line">    if (base == 0 )&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exponent == 0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    double result = 0.0;</span><br><span class="line">    int n = Math.abs(exponent);</span><br><span class="line">    result = Power1(base,n &gt;&gt; 1);</span><br><span class="line">    result = result * result;</span><br><span class="line">    if ((n &amp; 1) == 1)&#123;</span><br><span class="line">    // 如果指数n为奇数，则要再乘一次底数base</span><br><span class="line">        result = result * base;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exponent &lt; 0)&#123;</span><br><span class="line">    // 如果指数为负数，则应该求result的倒数</span><br><span class="line">        result = 1.0/result;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 二进制中 1 的个数</title>
    <link href="http://suiyia.github.io/2019/09/23/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://suiyia.github.io/2019/09/23/剑指offer题解-二进制中-1-的个数/</id>
    <published>2019-09-23T14:57:00.000Z</published>
    <updated>2019-09-24T14:22:21.274Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>位比较</p></li><li><p>思路1：使用<strong>整数右移</strong>与 1 进行位比较，计算总个数。但是如果是负数，高位右移将会补 1，所以可以使用 &gt;&gt;&gt; 无符号右移或者将负数变为正数再进行右移。</p></li><li><p>使用 <strong>1 左移</strong>的方式进行位比较，一直比较到 Interger.MAX_VALUE = 0x7fffffff</p></li><li><p>思路2：如果一个整数不为 0，那么这个整数至少有一位是 1。</p><p>如果我们把这个整数减 1，那么原来处在整数最右边的 1 就会变为 0，1 右边的 0 变为 1。其余所有位将不会受到影响。</p><p>然后将两者相与，如果结果不为 0，说明原来整数最右边 1 的左边里面肯定包含 1，然后减 1 继续这么循环下去，不为 0 的次数就是 1 出现的次数。</p><p>例：1100 &amp; 1011 = 1000，数字 1100 最右边的 1 左边还有一个 1</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 先变为正整数</span><br><span class="line">public int NumberOf12(int n) &#123;</span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    if (n &lt; 0)&#123;</span><br><span class="line">        n = n &amp; 0x7fffffff;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (n != 0)&#123;</span><br><span class="line">        if ((n &amp; 1) != 0)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n &gt;&gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 整数无符号右移</span><br><span class="line">public int NumberOf13(int n) &#123;</span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (n != 0)&#123;</span><br><span class="line">        if ((n &amp; 1) != 0)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n &gt;&gt;&gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1 左移</span><br><span class="line">public int NumberOf1(int n) &#123;</span><br><span class="line">if (n == 0)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int flag = 1;</span><br><span class="line">    while (flag != 0)&#123;</span><br><span class="line">    if (flag &amp; n == 1)&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = flag &lt;&lt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 思路 2</span><br><span class="line">public int NumberOf11(int n) &#123;</span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (n != 0)&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        n = n &amp; (n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 矩形覆盖</title>
    <link href="http://suiyia.github.io/2019/09/23/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
    <id>http://suiyia.github.io/2019/09/23/剑指offer题解-矩形覆盖/</id>
    <published>2019-09-23T14:49:00.000Z</published>
    <updated>2019-09-23T14:57:02.886Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li>实质是斐波拉契数列</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 递归版本</span><br><span class="line">    public int RectCover(int target) &#123;</span><br><span class="line">        if (n == 1)</span><br><span class="line">            return 1;</span><br><span class="line">        if (n == 2)</span><br><span class="line">            return 2;</span><br><span class="line">        return RectCover(n - 1) + RectCover(n - 2) * 2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 变态跳台阶</title>
    <link href="http://suiyia.github.io/2019/09/23/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://suiyia.github.io/2019/09/23/剑指offer题解-变态跳台阶/</id>
    <published>2019-09-23T13:52:00.000Z</published>
    <updated>2019-09-23T14:49:00.226Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>参考前面的斐波拉契数列</p></li><li><p>第 n 层台阶可能由：第 n-1 跳一阶过来，还可能由第 n-2 跳两阶过来等，所以总情况 f（n）= f（n-2）+ f（n-1）+ … + f(1)</p></li><li><p>递推关系式实现 f（n）= 2 * f（n-1）</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 递归版本</span><br><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line"></span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 2 * Fibonacci(n-1);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 循环</span><br><span class="line">public int Fibonacci23(int n)&#123;</span><br><span class="line">if (n == 0)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">if (n == 1)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int b = 1;</span><br><span class="line">int c = 0;</span><br><span class="line">for (int i = 1;i&lt;n;i++)&#123;</span><br><span class="line">c = 2 * b;</span><br><span class="line">        b = c;</span><br><span class="line">&#125;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 跳台阶</title>
    <link href="http://suiyia.github.io/2019/09/23/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://suiyia.github.io/2019/09/23/剑指offer题解-跳台阶/</id>
    <published>2019-09-23T13:15:00.000Z</published>
    <updated>2019-09-23T13:51:57.234Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>第 n 层台阶可能由：第 n-1 跳一阶过来，还可能由第 n-2 跳两阶过来，所以总情况 f（n）= f（n-2）+ f（n-1）</p></li><li><p>其实就是斐波拉契数列</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 递归版本</span><br><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line"></span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return Fibonacci(n-1) + Fibonacci(n-2);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 循环</span><br><span class="line">public int Fibonacci23(int n)&#123;</span><br><span class="line">if (n == 0)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">if (n == 1 || n == 2)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int a = 0;</span><br><span class="line">int b = 1;</span><br><span class="line">int c = 0;</span><br><span class="line">for (int i = 1;i&lt;n;i++)&#123;</span><br><span class="line">c = a + b;</span><br><span class="line">a = b;</span><br><span class="line">b = c;</span><br><span class="line">&#125;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多项式递推</span><br><span class="line">public int Fibonacci2(int n) &#123;</span><br><span class="line">    if(n==0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else if(n==1||n==2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else if(n==3) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 3*Fibonacci(n-3)+2*Fibonacci(n-4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 斐波拉契数列</title>
    <link href="http://suiyia.github.io/2019/09/23/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://suiyia.github.io/2019/09/23/剑指offer题解-斐波拉契数列/</id>
    <published>2019-09-23T12:39:00.000Z</published>
    <updated>2019-09-23T13:14:37.538Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项（从 0 开始，第 0 项为 0）。<br>n&lt;=39</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>递归，f（n）= f（n-1）+ f（n-2），但是每一次的迭代计算结果没有保存，很容易栈溢出</p></li><li><p>循环方式，每次的结果进行累加</p></li><li><p>多项关系式递推</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 递归版本</span><br><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line"></span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return Fibonacci(n-1) + Fibonacci(n-2);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 循环</span><br><span class="line">public int Fibonacci23(int n)&#123;</span><br><span class="line">if (n == 0)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">if (n == 1 || n == 2)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int a = 0;</span><br><span class="line">int b = 1;</span><br><span class="line">int c = 0;</span><br><span class="line">for (int i = 1;i&lt;n;i++)&#123;</span><br><span class="line">c = a + b;</span><br><span class="line">a = b;</span><br><span class="line">b = c;</span><br><span class="line">&#125;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多项式递推</span><br><span class="line">public int Fibonacci2(int n) &#123;</span><br><span class="line">    if(n==0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else if(n==1||n==2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else if(n==3) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 3*Fibonacci(n-3)+2*Fibonacci(n-4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 旋转数组的最小数字</title>
    <link href="http://suiyia.github.io/2019/09/19/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://suiyia.github.io/2019/09/19/剑指offer题解-旋转数组的最小数字/</id>
    <published>2019-09-19T15:27:00.000Z</published>
    <updated>2019-09-23T12:39:25.513Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>常规思路：从头到尾遍历一遍找到最小值，时间复杂度 O（N）</p></li><li><p>方法二</p><ul><li><p>非递减数组旋转，旋转之后可以看做是两个非递减数组的拼接，当 a[index] &gt; a[index+1] 时，最小值就是 a[index+1]。</p></li><li><p>有序数组的查找，可以选择二分查找</p></li><li><p><strong>规律（数组内元素都不相同）</strong>：若 A[mid] &gt; a[low]，那么最小值一定在 mid 及 high 之间；若 A[mid] &lt; a[low]，那么最小值一定在 low 及 mid 之间</p></li></ul></li><li><p><strong>注意点：如果 A[mid] = a[low]，那么就不能判断最小值在哪一个位置。例如 01111 旋转可以变为 11110 和 10111。只能从头到尾遍历</strong></p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li>方法二实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public int minNumberInRotateArray(int [] array) &#123;</span><br><span class="line"></span><br><span class="line">    if (array.length == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (array.length == 1)&#123;</span><br><span class="line">        return array[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = array.length - 1;</span><br><span class="line"></span><br><span class="line">    while(low &lt; high)&#123;</span><br><span class="line">        int mid = (low + high) / 2;</span><br><span class="line">        if (low == high -1)&#123;</span><br><span class="line">            return array[high];</span><br><span class="line">        &#125;</span><br><span class="line">        if (array[mid] &gt; array[low])&#123;</span><br><span class="line">                // 最小值在右边</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;else if (array[mid] &lt; array[low])&#123;</span><br><span class="line">                // 最小值在左边</span><br><span class="line">                high = mid;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            // 分辨不出最小值位置</span><br><span class="line">  return serach(array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // 从头到尾查找一遍</span><br><span class="line">    public int serach(int[] array)&#123;</span><br><span class="line">    int minValue = Integer.MAX_VALUE;</span><br><span class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        if (array[i] &lt; minValue)&#123;</span><br><span class="line">            minValue = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return minValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>数组为空，或者只有一个长度的情况，考虑数组边界问题</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 两个栈实现队列</title>
    <link href="http://suiyia.github.io/2019/09/19/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://suiyia.github.io/2019/09/19/剑指offer题解-两个栈实现队列/</id>
    <published>2019-09-19T13:13:00.000Z</published>
    <updated>2019-09-19T15:13:51.892Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>方法 1（常规思路，移动次数较多）</p><ul><li><p>stack1 专门用于 push 数据，stack2 专门 pop 数据。</p></li><li><p>调用 pop() 方法时候，stack1 数据全部 push 到 stack2，保存 stack2 最顶上元素。</p></li><li><p>pop 方法结束之前，将 stack2 的数据再推回到 stack1 中。</p></li></ul></li></ul><ul><li><p>方法 2（推荐，移动次数少）</p><ul><li><p>stack1 专门用于 push 数据。</p></li><li><p>pop 方法调用的时候，<strong>若 stack2 为空</strong>就先将 stack1 中的<strong>全部数据</strong>推到 stack2，然后 pop stack2 中的元素；否则直接 pop stack2 中的数据。</p></li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li>方法二</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</span><br><span class="line">   Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   public void push(int node) &#123;</span><br><span class="line">       stack1.push(node);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public int pop() &#123;</span><br><span class="line">       if (stack1.isEmpty() &amp;&amp; stack2.isEmpty())&#123;</span><br><span class="line">           throw new RuntimeException(&quot;Empty exception!&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       if (stack2.isEmpty())&#123;</span><br><span class="line">           while (!stack1.isEmpty())&#123;</span><br><span class="line">               stack2.push(stack1.pop());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return stack2.pop();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>pop 数据考虑边界情况，栈为空</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 重建二叉树</title>
    <link href="http://suiyia.github.io/2019/09/18/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://suiyia.github.io/2019/09/18/剑指Offer题解-重建二叉树/</id>
    <published>2019-09-18T14:32:00.000Z</published>
    <updated>2019-09-19T15:13:51.912Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>方法 1. 使用栈保存遍历链表的结果，然后 push 栈输出到 ArrayList</p></li><li><p>方法 2. 递归方式实现倒序输出</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><strong>递归方式实现</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">       if (listNode != null)&#123;</span><br><span class="line">           printListFromTailToHead(listNode.next);</span><br><span class="line">           arrayList.add(listNode.val);</span><br><span class="line">       &#125;</span><br><span class="line">       return arrayList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   class ListNode &#123;</span><br><span class="line">       int val;</span><br><span class="line">       ListNode next = null;</span><br><span class="line"></span><br><span class="line">           ListNode(int val) &#123;</span><br><span class="line">           this.val = val;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 从尾到头打印链表</title>
    <link href="http://suiyia.github.io/2019/09/17/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://suiyia.github.io/2019/09/17/剑指Offer题解-从尾到头打印链表/</id>
    <published>2019-09-17T15:18:00.000Z</published>
    <updated>2019-09-19T15:13:51.901Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>方法 1. 使用栈保存遍历链表的结果，然后 push 栈输出到 ArrayList</p></li><li><p>方法 2. 递归方式实现倒序输出</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><strong>递归方式实现</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">       if (listNode != null)&#123;</span><br><span class="line">           printListFromTailToHead(listNode.next);</span><br><span class="line">           arrayList.add(listNode.val);</span><br><span class="line">       &#125;</span><br><span class="line">       return arrayList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   class ListNode &#123;</span><br><span class="line">       int val;</span><br><span class="line">       ListNode next = null;</span><br><span class="line"></span><br><span class="line">           ListNode(int val) &#123;</span><br><span class="line">           this.val = val;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 替换空格</title>
    <link href="http://suiyia.github.io/2019/09/17/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC-%E5%89%91%E6%8C%87Offer/"/>
    <id>http://suiyia.github.io/2019/09/17/替换空格-剑指Offer/</id>
    <published>2019-09-17T13:31:00.000Z</published>
    <updated>2019-09-19T15:13:51.870Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>不使用工具类</p></li><li><p>思路：先统计空格出现次数，然后就知道了替换后的字符串长度，使用另外的字符串数组保存替换后的字符串，然后从右往左进行填充</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><p>先统计空格出现的次数，出现一次空格，那么增加的长度就是加 2，N 个空格就是增加了 N*2</p></li><li><p>然后用另外的数组保存替换后的字符</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static String replaceSpace(StringBuffer str) &#123;</span><br><span class="line"></span><br><span class="line">// 统计空格数量</span><br><span class="line">        int spaceCount = 0;</span><br><span class="line">        for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">            if (str.charAt(i) == &apos; &apos;)&#123;</span><br><span class="line">                spaceCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int length = str.length();</span><br><span class="line">        // 用另外的字符数组保存字符</span><br><span class="line">        char[] a = new char[length + spaceCount * 2];</span><br><span class="line">        </span><br><span class="line">        // 字符数组索引，从最后面开始</span><br><span class="line">        int afterIndex = length + spaceCount * 2 - 1;</span><br><span class="line">        </span><br><span class="line">        for (int j = length - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            if (str.charAt(j) != &apos; &apos;)&#123;</span><br><span class="line">            // 如果不是空格，就直接赋值，索引也跟着减</span><br><span class="line">                a[afterIndex] = str.charAt(j);</span><br><span class="line">                afterIndex --;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                a[afterIndex] = &apos;0&apos;;</span><br><span class="line">                a[afterIndex - 1] = &apos;2&apos;;</span><br><span class="line">                a[afterIndex - 2] = &apos;%&apos;;</span><br><span class="line">                afterIndex = afterIndex - 3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return String.valueOf(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>从后往前填充相对简单点</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 二维数组中的查找 </title>
    <link href="http://suiyia.github.io/2019/09/16/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE-%E5%89%91%E6%8C%87Offer/"/>
    <id>http://suiyia.github.io/2019/09/16/二维数组中的查找-剑指Offer/</id>
    <published>2019-09-16T15:11:00.000Z</published>
    <updated>2019-09-19T15:11:08.513Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>常规思路：左上角开始，每行从左到右都轮询一次。</p><ul><li><p>时间复杂度 O（N^2）</p></li><li><p>空间复杂度 O（1）</p></li></ul></li><li><p>从右下角开始，每行从左往右轮询：上面一行相同列的元素比当前元素小，右边同行元素比当前元素大，那么不用全部元素比较。</p><ul><li><p>时间复杂度：O(行高 + 列宽)</p></li><li><p>空间复杂度：O(1)</p></li></ul></li></ul><ul><li>从右上角开始，从右往左。原理同上</li></ul><ul><li>从右下角开始，和常规思路类似</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>M 行 N 列数组，寻找元素 K</p><ul><li>左下角开始寻找</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static boolean Find(int target, int [][] array) &#123;</span><br><span class="line"></span><br><span class="line">    int i = array.length - 1;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while (i &gt;= 0 &amp;&amp; j &lt; array[0].length)&#123;</span><br><span class="line">        if (array[i][j] &gt; target) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;else if(array[i][j] &lt; target)&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li><p>数组边界问题</p></li><li><p>常规思路，遇到有序序列进行查找时，可以使用<strong>二分查找</strong>，时间复杂度将进一步降低，时间复杂度 Mlog(n)</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>日志框架学习及Log4j 2 概念整理</title>
    <link href="http://suiyia.github.io/2019/09/04/Log4j-2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://suiyia.github.io/2019/09/04/Log4j-2-基本概念/</id>
    <published>2019-09-04T06:52:00.000Z</published>
    <updated>2019-10-02T02:27:36.963Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="日志框架分类"><a href="#日志框架分类" class="headerlink" title="日志框架分类"></a>日志框架分类</h1><p>日志框架按照功能可以分为日志<strong>接口</strong>、日志<strong>实现</strong>两部分。</p><p>编写程序时，推荐使用<strong>日志接口</strong>的 API 进行方法调用，然后使用对应的<strong>日志实现框架</strong>打印日志。</p><p>常用日志框架的使用方式为： Log4j2-api（接口） + Log4j2-core（实现）。SLF4J（接口）+ 其它日志框架实现。</p><ul><li><p>日志接口，日志的接口规范，它对用户提供了统一的日志接口，屏蔽了不同日志组件的差异。</p><ul><li><p><a href="https://commons.apache.org/proper/commons-logging/" target="_blank" rel="noopener">Apache Commons Logging Component</a>，2014 年之后文档没有再更新</p></li><li><p><a href="https://www.slf4j.org/" target="_blank" rel="noopener">SLF4J（Simple Logging Facade for Java）</a>，定义了各种日志框架（java.util.logging, logback, log4j 等）的<strong>抽象</strong>，是 Java 日志输出的标准接口。需引入 slf4j-api-xxx.jar</p><ul><li>slf4j-api 不同版本是互相兼容的，不同系统之间的 slf4j-api 版本不同并不会造成冲突；但是其实现类是可能存在冲突的，例如使用 slf4j-api-1.0.jar 和 slf4j-simple-1.0.jar 是没有问题的，但是使用 slf4j-simple-2.0.jar 可能存在问题。在引入相关依赖的时候，要保证 slf4j-api 的版本和其实现日志框架的版本一致！</li></ul></li><li><p><a href="https://logging.apache.org/log4j/2.x/" target="_blank" rel="noopener">Log4J2 api</a>，log4j 2-api 包和 slf4J 类似，定义日志输出接口规范，具体日志输出形式根据依赖的日志实现 jar 包确定</p></li></ul></li><li><p>日志实现，定义具体日志打印内容</p><ul><li><p>JDKLog，java.util.logging.Logger，jdk 自带的日志工具类，它通过 getLogger 获取日志对象、setLevel 定义日志级别、Handler 定义日志输出方式 （输出到文件、控制台、网络流）、Formatter 定义日志输出样式。需引入 slf4j-jdk14-xxx.jar</p></li><li><p><a href="https://logback.qos.ch/" target="_blank" rel="noopener">LOGBack</a>，继承于 Log4J，官网表示它可作为 log4j 的 successor（继承者），比 log4j 更好！它包括 3 个模块：</p><ul><li>logback-core，下面两个模块的基础依赖<ul><li>logback-classic，对 log4j 进行了显著地改进，实现了 SLF4J API，方便随时切换日志框架。</li><li>logback-access，与 Servlet 容器（Tomcat、Jetty）进行集成，提供 HTTP 访问日志功能。</li></ul></li></ul></li><li><p><a href="http://logging.apache.org/log4j/1.2/" target="_blank" rel="noopener">Log4J</a>，2015 年开始已经停止维护</p></li><li><p><a href="https://logging.apache.org/log4j/2.x/" target="_blank" rel="noopener">Log4J2 core</a> Log4J 升级版，2019-08-06 版本更新至 2.12.1，API 相关用法不兼容 1.X 版本</p></li></ul></li></ul><h1 id="Log4j-2-内置概念"><a href="#Log4j-2-内置概念" class="headerlink" title="Log4j 2 内置概念"></a>Log4j 2 内置概念</h1><ul><li>Markers：为某条日志添加标志位，使用 %marker 进行输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">    private static final Marker SQL_MARKER = MarkerManager.getMarker(&quot;SQL&quot;);</span><br><span class="line">    Marker markerA = MarkerManager.getMarker(&quot;Marker A&quot;);</span><br><span class="line">    Marker markerB = MarkerManager.getMarker(&quot;Marker B&quot;);</span><br><span class="line">    logger.debug(markerA,&quot;your name is &#123;&#125; &quot;,&quot;Jack&quot;);</span><br><span class="line">    logger.debug(markerB,&quot;your name is &#123;&#125; &quot;,&quot;Ma&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log4j.xml：</span><br><span class="line">&lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M %marker - %msg%xEx%n&quot;/&gt;</span><br><span class="line"></span><br><span class="line">Console Out：</span><br><span class="line">10:14:02.639 DEBUG FlowTracing 60 test Marker A - your name is Jack </span><br><span class="line">10:14:02.642 DEBUG FlowTracing 61 test Marker B - your name is Ma</span><br></pre></td></tr></table></figure><ul><li><p>Lookups：在配置文件中添加变量、使用变量</p></li><li><p>Appenders：定义日志事件输出方式（日志文件名称、路径、什么级别日志才能输出、文件大小等等），其实就是文件流输出定义。</p><ul><li>AsyncAppender 用另外的线程记录日志，默认使用 ArrayBlockingQueue 队列进行日志记录，当发生异常时，默认会忽略异常，记得手动开启，并使用FailoverAppender 对异常情况进行补充打印输出</li><li>ConsoleAppender，控制台输出</li><li>FailoverAppender，当主 Appender 失败时，它将起作用</li><li>FileAppender，文件输出，当多个程序对同一文件进行输出时，各自程序之间的配置也不受影响</li><li>JDBCAppender，直接写到数据库</li><li>HttpAppender，http 请求发送到另外的服务接收，如果服务返回的不是 2XX，将会抛出异常。</li><li>KafkaAppender，发送到 Kafka</li><li>RollingFileAppender，可以滚动的文件输出，包含触发规则（触发滚动条件：时间、大小）、滚动规则（怎么进行更新：文件数量），默认日志文件个数为 7 个。</li><li><a href="https://logging.apache.org/log4j/2.x/manual/appenders.html" target="_blank" rel="noopener">等等</a></li></ul></li><li><p>Layouts：Appender 使用定义好的 LayOut 对 LogEvent 进行格式化输出，</p><ul><li>CSV Layouts，以 Comma Separated Value (CSV) 形式输出</li><li>JSON Layout，JSON 格式输出</li><li>Pattern Layout，用特殊的字符输出对应的内容，定制化强</li><li>XML Layout</li><li>Location Infomation，当日志中需要日志所在类、方法、代码行数这些信息时，会花费 1.3-5 倍的时间，相比不需要 Location Infomation 的场景。并且在使用异步的 Appender 时，默认的 Location Infomation 默认关闭，如果开启，会比不开启花费 30-100 倍的性能消耗</li></ul></li><li><p>Filters：决定哪些事件可以输出，哪些事件不能输出。过滤结果有 3 个结果，ACCEPT（允许）, DENY（拒绝输出）or NEUTRAL（中立、默认）。</p><ul><li>BurstFilter，当每秒日志输出事件速率大于一定值，将会抛弃掉级别低的日志</li><li>CompositeFilter，直接在 configuration 级别添加多个过滤器</li><li>DynamicThresholdFilter，根据一些属性值去动态修改该条日志的输出级别</li><li>MapFilter，如果 LogEvent 中的 MapMessage 内包含特定属性，就可以选择过滤</li><li>MarkerFilter、NoMarkerFilter，对应定义或者未定义 Marker 的事件进行过滤</li><li>RegexFilter，正则过滤 formatted or unformatted message</li><li>ThreadContextMapFilter ，对 ThreadContextMap 中的内容进行过滤</li><li>ThresholdFilter，对 Level 进行过滤</li><li>TimeFilter，根据某个时间点、时间段进行过滤</li></ul></li></ul><h1 id="3-Log4J-2-Java-API-用法"><a href="#3-Log4J-2-Java-API-用法" class="headerlink" title="3. Log4J 2 Java API 用法"></a>3. Log4J 2 Java API 用法</h1><ul><li><p>Flow Tracing</p><p>日志跟踪</p></li><li><p>Markers（标记）</p><p>对于有特定标识需求的地方，可以使用 Marker 进行标记，并且用 %marker 进行打印输出。</p></li><li><p>ThreadContext</p><p>Mapped Diagnostic Context（MDC）的实现，类似 request，可以存放 key-value 键值对，也可以销毁，使用 %X{key} 输出。</p><p>the MDC is a map which stores the context data of the particular thread where the context is running.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%X&#123;id&#125; 输出 context map 中 key = id 的值</span><br><span class="line">%X 输出 context map 所有值</span><br><span class="line"></span><br><span class="line">public void test()&#123;</span><br><span class="line">    ThreadContext.put(&quot;id&quot;, &quot;321&quot;); // Add the fishtag;</span><br><span class="line">    ThreadContext.put(&quot;name&quot;, &quot;996&quot;); // Add the fishtag;</span><br><span class="line">    logger.debug(&quot;Message 1&quot;);</span><br><span class="line">    logger.debug(&quot;Message 2&quot;);</span><br><span class="line">    ThreadContext.clearAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>log4j-slf4j-impl 是 slf4j 转接到 log4j 2 的日志输出框架。</p><p>slf4j-log4j12 是 slf4j 转接到 log4j 1.x 的日志输出框架 ，而 log4j 1.x 已经在 2015 年 8 月就停止更新了。</p><p>log4j 官方建议升级到 log4j 2</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;日志框架分类&quot;&gt;&lt;a href=&quot;#日志框架分类&quot; class=&quot;headerlink&quot; title=&quot;日志框架分类&quot;&gt;&lt;/a&gt;日志框
      
    
    </summary>
    
    
      <category term="Log4j" scheme="http://suiyia.github.io/tags/Log4j/"/>
    
  </entry>
  
</feed>
