<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸟日常</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suiyia.github.io/"/>
  <updated>2019-10-11T15:01:12.264Z</updated>
  <id>http://suiyia.github.io/</id>
  
  <author>
    <name>Answer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM学习——运行时数据区</title>
    <link href="http://suiyia.github.io/2019/10/11/JVM%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
    <id>http://suiyia.github.io/2019/10/11/JVM学习——运行时内存分区/</id>
    <published>2019-10-11T14:37:00.000Z</published>
    <updated>2019-10-11T15:01:12.264Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 11 2019 23:01:12 GMT+0800 (GMT+08:00) --><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote><p>Java虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，已经创建和销毁时间，有的区域随着虚拟机进程的启动而创建，有些区域则依赖用户线程的启动和结束而创建和销毁。</p></blockquote><p>Java 文件中定义的方法、变量、常量等进入内存后，存放的区域以及对应的变化。</p><p>Java 虚拟机内存空间就是一块普通的内存空间，只是这部分处理 Java 程序。</p><p>Java 虚拟机内存结构按线程数据是否共享分为两部分：</p><ul><li><p>线程共享</p><ul><li>堆</li><li>方法区</li><li>常量池</li></ul></li><li><p>线程私有</p><ul><li>PC 寄存器</li><li>本地方法栈</li><li>Java 虚拟机栈</li></ul></li></ul><h1 id="各个分区的细节"><a href="#各个分区的细节" class="headerlink" title="各个分区的细节"></a>各个分区的细节</h1><p>基于 JDK 1.8</p><h2 id="堆：存放对象的地方。"><a href="#堆：存放对象的地方。" class="headerlink" title="堆：存放对象的地方。"></a>堆：存放对象的地方。</h2><p><img src="/\images\java8heap.png\" alt="upload successful"></p><p>Dog dog = new Dog(); new Dog() 这个对象就在堆上</p><p>堆进一步可分为：年轻代、老年代。年轻代对象大多数存活时间短，很快会被垃圾回收。年轻代存活久的会进入老年代，当然有些对象比较大，会直接进入老年代。</p><p>年轻代内存分区进一步可分为 Eden、survivor0、survivor1 三个部分，内存默认大小比例为 8:1:1。</p><p>垃圾回收的时候， Eden 和其中一个 surivor 内的对象大部分会被清除，而没清除的放入另外一个 surivor 中（垃圾回收算法——复制算法）。</p><p>JDK 1.8 之前，堆中有永久代（Perm GEN）这个概念，JDK 1.8 开始，去掉永久代，取而代之的是元空间（MetaSpace），元空间不属于堆，元空间的大小仅受限于机器的内存大小。</p><p>当 Perm GEN 属于堆的时候，有时候由于堆内存大小不足，报 “java.lang.OutOfMemoryError: PermGen space” 错误，现在这个错误将不复存在；当然对应的 -XX:MaxPermSize 也将不起作用</p><p><a href="http://karunsubramanian.com/websphere/one-important-change-in-memory-management-in-java-8/" target="_blank" rel="noopener">One important change in Memory Management in Java 8</a></p><p><a href="https://dzone.com/articles/java-8-permgen-metaspace" target="_blank" rel="noopener">Java 8: From PermGen to Metaspace</a></p><p><a href="https://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="noopener">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>存放类的结构信息：运行时常量池、方法、构造方法</p><p>方法区是一个接口概念，是 Java 虚拟机定义的一个规范；而永久代、元空间则被认为是方法区这个规范的实现，并且永久代 HotSpot 虚拟机才有的概念，其它虚拟机没有。</p><p>JDK 1.7 时，永久代包含类的元信息、静态变量、常量池（Constant Pool Table）；</p><p>JDK 1.8 开始元空间（元空间不属于堆，在机器的本地内存中）存储类的元信息。静态变量、常量池并入堆中。</p><p>常量池：用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p><a href="https://www.zhihu.com/question/39990490/answer/369690291" target="_blank" rel="noopener">jdk8之后永久代去哪了？ - Mr Zeng的回答 - 知乎</a></p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p><a href="https://www.jianshu.com/p/cf78e68e3a99" target="_blank" rel="noopener">JVM常量池浅析</a></p><ul><li>Class 文件常量池</li></ul><p>class 文件中有定义，包括字面量和符号引用</p><pre><code>- 字面量 指数据的值- 符号引用 包含类和接口的全限定名，字段的名称和描述符，方法的名称和描述符</code></pre><ul><li><p>运行时常量池</p></li><li><p>全局字符串常量池</p></li><li><p>基本类型包装类对象常量池</p></li></ul><h2 id="PC（Program-Counter）-程序计数器"><a href="#PC（Program-Counter）-程序计数器" class="headerlink" title="PC（Program Counter） 程序计数器"></a>PC（Program Counter） 程序计数器</h2><p>指的是保存线程当前正在执行的方法。唯一一个无 OOM 的区域</p><p>如果这个方法不是 native 方法，那么 PC 寄存器就保存 Java 虚拟机正在执行的字节码指令地址。如果是 native 方法，那么 PC 寄存器保存的值是 undefined。</p><p>任意时刻，一条 Java 虚拟机线程只会执行一个方法的代码，而这个被线程执行的方法称为该线程的当前方法，其地址被存在 PC 寄存器中。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>「当 Java 虚拟机使用其他语言（例如 C 语言）来实现指令集解释器时，也会使用到本地方法栈。如果 Java 虚拟机不支持 natvie 方法，并且自己也不依赖传统栈的话，可以无需支持本地方法栈。」</p><h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>一个线程就包含一个虚拟机栈，与线程共存亡。</p><p>虚拟机栈有大小，如果栈的深度大于 JVM 所允许的范围，会抛出 StackOverflowError；如果申请不到额外空间，会抛出 OutOfMemoryError，这两种错误如果要捕获，需使用 Throwable 进行捕获。</p><p>线程执行一个方法时，虚拟机栈就会创建一个栈帧，栈帧内包含局部变量表，操作数栈。方法执行完退出，该栈帧就会清除。</p><p>栈帧内容：</p><ul><li><p>局部变量表：基本数据类型、对象引用</p></li><li><p>操作数栈</p></li><li><p>方法出口</p></li></ul><h3 id="博客参考"><a href="#博客参考" class="headerlink" title="博客参考"></a>博客参考</h3><p><a href="https://www.cnblogs.com/chanshuyi/p/jvm_serial_06_jvm_memory_model.html" target="_blank" rel="noopener">JVM系列第6讲：Java 虚拟机内存结构</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 11 2019 23:01:12 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="JVM" scheme="http://suiyia.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://suiyia.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习——基础概念了解</title>
    <link href="http://suiyia.github.io/2019/10/10/MySQL%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%BA%86%E8%A7%A3/"/>
    <id>http://suiyia.github.io/2019/10/10/MySQL学习——基础概念了解/</id>
    <published>2019-10-10T13:44:00.000Z</published>
    <updated>2019-10-11T14:19:28.444Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 11 2019 22:19:51 GMT+0800 (GMT+08:00) --><h3 id="MySQL-主从复制原理"><a href="#MySQL-主从复制原理" class="headerlink" title="MySQL 主从复制原理"></a>MySQL 主从复制原理</h3><p><a href="https://zhuanlan.zhihu.com/p/50597960" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50597960</a></p><p>MySQL主从复制涉及到三个线程</p><ul><li>主节点 binary log dump 线程</li></ul><p>当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。</p><ul><li>从节点 I/O线程</li></ul><p>当从节点上执行<code>start slave</code>命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点binlog dump 进程发来的更新之后，保存在本地relay-log中。</p><ul><li>从节点SQL线程</li></ul><p>SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。</p><h3 id="binlog-记录格式"><a href="#binlog-记录格式" class="headerlink" title="binlog 记录格式"></a>binlog 记录格式</h3><ul><li><p>基于SQL语句，只需要记录会修改数据的sql语句到binlog中，减少了binlog日质量，节约I/O，提高性能。缺点是在某些情况下，会导致主从节点中数据不一致（比如sleep(),now()等）。</p></li><li><p>基于行，只记录哪条数据被修改了，修改成什么样。优点是不会出现某些特定情况下的存储过程、或者函数、或者trigger的调用或者触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是修改table的时候会让日志暴增,同时增加bin log同步时间。也不能通过bin log解析获取执行过的sql语句，只能看到发生的data变更。</p></li><li><p>混合模式，一般的复制使用STATEMENT模式保存到binlog，对于STATEMENT模式无法复制的操作则使用ROW模式来保存，MySQL会根据执行的SQL语句选择日志保存方式。</p></li></ul><h3 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型"></a>日志类型</h3><ul><li><p>错误日志，记录出错信息，也记录一些警告信息或者正确的信息</p></li><li><p>查询日志，记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行</p></li><li><p>慢查询日志，设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</p></li><li><p>二进制日志，记录对数据库执行更改的所有操作</p></li><li><p>中继日志，事务日志</p></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>（<a href="https://juejin.im/entry/5b57ec015188251aa8292a69）" target="_blank" rel="noopener">https://juejin.im/entry/5b57ec015188251aa8292a69）</a></p><ul><li><p>整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。</p></li><li><p>实数，包括FLOAT、DOUBLE、DECIMAL。DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p></li><li><p>字符串类型，包括 VARCHAR、CHAR、TEXT、BLOB。VARCHAR 用于存储可变长字符串，它比 CHAR 定长类型更节省空间；当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。</p></li><li><p>枚举类型，把不重复的数据存储为一个预定义的集合。有时可以使用ENUM代替常用的字符串类型。ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。ENUM在内部存储时，其实存的是整数。尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。排序是按照内部存储的整数</p></li><li><p>日期时间类型，尽量使用timestamp，空间效率高于datetime，用整数保存时间戳通常不方便处理。如果需要存储微妙，可以使用bigint存储。</p></li></ul><h3 id="CHAR和VARCHAR的区别？"><a href="#CHAR和VARCHAR的区别？" class="headerlink" title="CHAR和VARCHAR的区别？"></a>CHAR和VARCHAR的区别？</h3><ul><li><p>CHAR和VARCHAR类型在存储和检索方面有所不同</p></li><li><p>CHAR列长度固定为创建表时声明的长度，长度值范围是1到255</p></li><li><p>当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。</p></li></ul><h3 id="MYSQL中varchar-10-和int-10-的区别-TODO"><a href="#MYSQL中varchar-10-和int-10-的区别-TODO" class="headerlink" title="MYSQL中varchar(10)和int(10)的区别 TODO"></a>MYSQL中varchar(10)和int(10)的区别 TODO</h3><h3 id="SQL-语句分类"><a href="#SQL-语句分类" class="headerlink" title="SQL 语句分类"></a>SQL 语句分类</h3><ul><li>DDL：数据定义语言（create drop alter）</li><li>DML：数据操作语句（insert update delete）</li><li>DQL：数据查询语句（select ）</li><li>DCL：数据控制语句，进行授权和权限回收（grant revoke）</li><li>TPL：数据事务语句（commit collback savapoint）</li></ul><h3 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h3><p>减少数据冗余、查询需要多表关联</p><ul><li><p>第一范式：属性具有原子性，不可再分解。</p></li><li><p>第二范式：记录具有唯一标识，即实体唯一性。通常需要为表加上一个列， 以存储各个实例的惟一标识。</p></li><li><p>第三范式：任何字段不能由其它字段派生而来，要求字段没有冗余。第三范式具有如下特征：1， 每一列只有一个值。2， 每一行都能区分。3， 每一个表都不包含其他表已经包含的非主关键字信息。</p></li></ul><h3 id="MyISAM表格将在哪里存储，并且还提供其存储格式"><a href="#MyISAM表格将在哪里存储，并且还提供其存储格式" class="headerlink" title="MyISAM表格将在哪里存储，并且还提供其存储格式?"></a>MyISAM表格将在哪里存储，并且还提供其存储格式?</h3><p>每个MyISAM表格以三种格式存储在磁盘上：</p><ul><li><p>“.frm”文件存储表定义</p></li><li><p>数据文件具有“.MYD”(MYData)扩展名</p></li><li><p>索引文件具有“.MYI”(MYIndex)扩展名</p></li></ul><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p><a href="https://juejin.im/post/5c91b5d7e51d456f957ebd10" target="_blank" rel="noopener">一条SQL语句在MySQL中是如何执行的</a></p><p><a href="https://zhuanlan.zhihu.com/p/50597960" target="_blank" rel="noopener">MySQL 主从复制原理</a></p><p><a href="https://www.cnblogs.com/panwenbin-logs/p/8366940.html" target="_blank" rel="noopener">MySQL经典面试题</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 11 2019 22:19:51 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;MySQL-主从复制原理&quot;&gt;&lt;a href=&quot;#MySQL-主从复制原理&quot; class=&quot;headerlink&quot; title=&quot;MyS
      
    
    </summary>
    
      <category term="MySQL" scheme="http://suiyia.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://suiyia.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习——锁</title>
    <link href="http://suiyia.github.io/2019/10/10/MySQL%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%94%81/"/>
    <id>http://suiyia.github.io/2019/10/10/MySQL学习——锁/</id>
    <published>2019-10-10T13:40:00.000Z</published>
    <updated>2019-10-11T13:09:53.224Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 11 2019 22:19:51 GMT+0800 (GMT+08:00) --><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="加锁策略"><a href="#加锁策略" class="headerlink" title="加锁策略"></a>加锁策略</h2><ul><li><p>乐观锁：乐观锁总是假设最好的情况，乐观锁常见实现：</p><ul><li><p>版本号控制，数据行保存 version 字段，修改时会变化。<a href="https://segmentfault.com/a/1190000012650596" target="_blank" rel="noopener">MySQL-InnoDB-MVCC多版本并发控制</a></p></li><li><p>CAS 算法（compare and swap），CAS算法涉及到三个操作数，需要读写的内存值 V，进行比较的值 A，拟写入的新值 B。 当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p></li><li><p>CAS 常见问题</p><ul><li>ABA问题：一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值。在这段时间它的值可能被改为其他值，然后又改回A</li><li>循环时间长开销大：自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</li><li>只能保证一个共享变量的原子操作：CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。</li></ul></li></ul></li><li><p>悲观锁：总是假设最坏的情况，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</p></li></ul><h2 id="锁粒度分类"><a href="#锁粒度分类" class="headerlink" title="锁粒度分类"></a>锁粒度分类</h2><ul><li><p>表锁，粒度最大，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁 。</p></li><li><p>行锁，粒度最小 的一种锁，只针对当前操作的<strong>行的索引进行加锁</strong>。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</p><p>InnoDB支持的行级锁：</p><ul><li><p>Record Lock: 对索引项加锁，锁定符合条件的行。</p></li><li><p>Gap Lock: 对索引项之间的“间隙”加锁，不包括记录本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。</p></li><li><p>Next-key Lock： 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。</p></li></ul></li><li><p>页锁，开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p></li></ul><p>相关知识点：</p><ol><li>innodb对于行的查询使用next-key lock</li><li>Next-locking keying为了解决Phantom Problem幻读问题</li><li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li><li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li><li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li></ol><h2 id="锁可写分类"><a href="#锁可写分类" class="headerlink" title="锁可写分类"></a>锁可写分类</h2><ul><li><p>共享锁（S），如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不 能加排他锁。获取共享锁的事务只能读数据，不能修改数据。</p></li><li><p>排他锁（X），如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获取排他锁的事务既能读数据，又能修改数据。</p></li><li><p>意向共享锁（IS）： 表示事务准备给数据行记入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁。</p></li><li><p>意向排他锁（IX）： 表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁。</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 11 2019 22:19:51 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; title=&quot;锁&quot;&gt;&lt;/a&gt;锁&lt;/h1&gt;&lt;h2 id=&quot;加锁策略
      
    
    </summary>
    
      <category term="MySQL" scheme="http://suiyia.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://suiyia.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习——事务</title>
    <link href="http://suiyia.github.io/2019/10/10/MySQL%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1/"/>
    <id>http://suiyia.github.io/2019/10/10/MySQL学习——事务/</id>
    <published>2019-10-10T13:39:00.000Z</published>
    <updated>2019-10-11T14:18:40.674Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 11 2019 22:19:51 GMT+0800 (GMT+08:00) --><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>一系列操作，事务中的操作要么全部成功，要么全部失败。</p><h2 id="事务四大特性（ACID）"><a href="#事务四大特性（ACID）" class="headerlink" title="事务四大特性（ACID）"></a>事务四大特性（ACID）</h2><ul><li><p>原子性：事务中所有操作，要么全部成功；要么撤回到执行事务之前的状态。</p></li><li><p>一致性：事务的执行使得数据库从一种正确状态转换成另一种正确状态。</p></li><li><p>隔离性：事务操作之间彼此独立和透明互不影响。</p></li><li><p>持久性：事务一旦提交，其结果就是永久的。即便发生系统故障，也能恢复。</p></li></ul><h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><ul><li><p>脏读（Dirty Read）：一个事务可以读取其他事务未提交的执行结果</p></li><li><p>丢失修改（Lost to modify）：第一个事务中修改了这个数据后，第二个事务也修改了这个数据。</p></li><li><p>不可重复读（Nonrepeatable Read）：在同一次事务中，同一个查询在 T1 时间内<strong>读取某一行</strong>，在 T2 时间重新读取这一行，这一行发生了 <strong>UPDATE</strong> 或者 <strong>DELETE</strong>。</p></li><li><p>幻读（Phantom Read）：用户读取<strong>某一范围</strong>的数据行时，另外一个事务在范围内 <strong>插入 insert</strong> 了新行，用户再次读取时，发现新的幻影行。</p></li></ul><p>不可重复读重点在于 update 和 delete，而幻读的重点在于 insert。</p><p>InnoDB 通过多版本并发控制（MVCC，Multiversion Conccurrency Control）解决不可重复读问题，在此基础上通过间隙锁解决幻读问题。</p><h2 id="事务隔离级别（解决并发事务带来的问题）"><a href="#事务隔离级别（解决并发事务带来的问题）" class="headerlink" title="事务隔离级别（解决并发事务带来的问题）"></a>事务隔离级别（解决并发事务带来的问题）</h2><ul><li><p>读未提交（Read Uncommited）：所以事务能够看到其它未提交事务的结果。</p></li><li><p>读已提交（Read Commited）：一个事务只能看到其它已经提交事务的结果。</p></li><li><p>可重复读（Repeatable Read）：MySQl 默认事务级别，确保同一事务的多个实例在并发读取数据时，会看到相同的数据行。幻读（）</p></li><li><p>串行化（Serializable）：强制事务排序，使之不可能出现冲突。在读取的数据行上面加上共享锁</p></li></ul><h2 id="事务保证数据一致性原理（TODO）"><a href="#事务保证数据一致性原理（TODO）" class="headerlink" title="事务保证数据一致性原理（TODO）"></a>事务保证数据一致性原理（TODO）</h2><ul><li><p>redo log 进入 prepare 状态</p></li><li><p>记录 binlog</p></li><li><p>最后 redo log 改为提交状态。</p></li><li><p>事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的lsn(log sequence number)号; 当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”</p></li></ul><h2 id="事务怎么通过日志实现的"><a href="#事务怎么通过日志实现的" class="headerlink" title="事务怎么通过日志实现的"></a>事务怎么通过日志实现的</h2><ul><li><p>redo log 重做日志，用来恢复数据，用于保障已提交事务的持久化特性。</p><ul><li><p>内存中的重做日志缓冲</p></li><li><p>重做日志文件</p></li></ul></li><li><p>undo log 回滚日志，用于记录数据被修改前的信息，用于保障事务的原子性。</p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/48327345" target="_blank" rel="noopener">一文了解InnoDB事务实现原理</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 11 2019 22:19:51 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;p&gt;一系列操作
      
    
    </summary>
    
      <category term="MySQL" scheme="http://suiyia.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://suiyia.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习——索引</title>
    <link href="http://suiyia.github.io/2019/10/10/MySQL%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/"/>
    <id>http://suiyia.github.io/2019/10/10/MySQL学习——索引/</id>
    <published>2019-10-10T13:38:00.000Z</published>
    <updated>2019-10-11T14:00:34.161Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 11 2019 23:01:07 GMT+0800 (GMT+08:00) --><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是一种数据结构,可以帮助我们快速的进行数据的查找。InnoDB 存储引擎的默认索引实现为 B+ 树索引。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><ul><li><p>普通索引（index）：最基本的索引，没有任何约束限制。</p></li><li><p>唯一索引（unique）：和普通索引类似，但是具有唯一性约束，允许有空值，一个表可以有多个唯一索引。</p></li><li><p>主键索引（primary key）：特殊的唯一索引，不允许有空值，保证实体完整性，一个表只能有一个主键。</p></li><li><p>联合索引：将多个列组合在一起创建索引，可以覆盖多个列。（也叫复合索引，组合索引）</p></li><li><p>全文索引：主要用于查找文本中的关键字，并不是直接与索引中的值进行比较。fulltext 更像是一个搜索引擎，配合 match against 操作使用，而不是一般的 where 语句加 like。</p></li></ul><h2 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h2><p>MyISAM 和 InnoDB 都使用 B+Tree 实现。MyISAM 叶子节点存放数据记录的地址，要找到该数据还需要去该地址寻找。InnoDB 叶子节点就是数据本身，数据表的主键作为索引的 key。</p><p>聚簇索引，MySQL索引是用一种叫做聚簇索引的数据结构实现的，是一种数据存储方式，它实际上是在同一个结构中保存了 B+ 树索引和数据行，InnoDB 表是按照聚簇索引组织的（类似于Oracle的索引组织表）。</p><p>聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接指向对应数据块。</p><h2 id="explain-用法字段含义-分析是否有用到索引"><a href="#explain-用法字段含义-分析是否有用到索引" class="headerlink" title="explain 用法字段含义(分析是否有用到索引)"></a>explain 用法字段含义(分析是否有用到索引)</h2><p><a href="https://www.sunjs.com/article/detail/99169a7375834c158409036934f10fab.html" target="_blank" rel="noopener">https://www.sunjs.com/article/detail/99169a7375834c158409036934f10fab.html</a></p><ul><li><p>id 表示一个查询中各个子查询的执行顺序，id相同执行顺序由上至下。 id不同，id值越大优先级越高，越先被执行。id为 null 时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</p></li><li><p>select_type 表示查询中每个 select 子句的类型：</p><ul><li><p>SIMPLE 不包含任何子查询或union等查询</p></li><li><p>PRIMARY 包含子查询最外层查询就显示为 PRIMARY</p></li><li><p>SUBQUERY 在select或 where字句中包含的查询</p></li><li><p>DERIVED from字句中包含的查询</p></li><li><p>UNION 出现在union后的查询语句中</p></li><li><p>UNION RESULT 从UNION中获取结果集</p></li></ul></li><li><p>table 查询的数据表，当从衍生表中查数据时会显示 x ，表示对应的执行计划id</p></li><li><p>partitions 表分区、表创建的时候可以指定通过那个列进行表分区。</p></li><li><p>type 表示MySQL在表中找到所需行的方式，又称「访问类型」</p><ul><li><p>ALL 扫描全表数据</p></li><li><p>index 遍历索引</p></li><li><p>range 索引范围查找</p></li><li><p>index_subquery 在子查询中使用 ref</p></li><li><p>unique_subquery 在子查询中使用 eq_ref</p></li><li><p>ref_or_null 对Null进行索引的优化的 ref</p></li><li><p>fulltext 使用全文索引</p></li><li><p>ref 使用非唯一索引查找数据</p></li><li><p>eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</p></li></ul></li><li><p>possible_keys 可能使用的索引，但不一定被查询使用</p></li><li><p>key 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL; 查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</p></li><li><p>key_len 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</p></li><li><p>ref 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p></li><li><p>rows 返回估算的结果集数目，并不是一个准确的值。</p></li><li><p>filtered</p></li><li><p>Extra 包含不适合在其他列中显示但十分重要的额外信息</p><ul><li><p>Using index 使用覆盖索引</p></li><li><p>Using where 使用了用where子句来过滤结果集</p></li><li><p>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</p></li><li><p>Using temporary 使用了临时表</p></li></ul></li></ul><h2 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h2><ul><li><p>% 开头的 like 模糊匹配</p></li><li><p>or 前后语句没有同时使用索引</p></li><li><p>数据类型出现隐式转化（字符串列查询没有使用引号）</p></li><li><p>索引列进行运算</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 11 2019 23:01:07 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;p&gt;索引是一种
      
    
    </summary>
    
      <category term="MySQL" scheme="http://suiyia.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://suiyia.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 链表中倒数第k个节点</title>
    <link href="http://suiyia.github.io/2019/09/25/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://suiyia.github.io/2019/09/25/剑指offer题解-链表中倒数第k个节点/</id>
    <published>2019-09-25T14:45:00.000Z</published>
    <updated>2019-09-25T14:44:08.380Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，输出该链表中倒数第k个结点。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>设定两个标志位，low 和 high，high 先走 k-1 步，剩下的 low 和 high 一起走，high 等于 null 时就返回 low 节点</p></li><li><p>考虑链表长度为空，链表长度小于 k 的情况</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">    if (head == null)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode low = head;</span><br><span class="line">    ListNode high = head;</span><br><span class="line">    for (int i = 0; i &lt;= k-1; i++) &#123;</span><br><span class="line">        if (head == null &amp;&amp; i &lt; k)&#123;</span><br><span class="line">        // 链表长度小于 k</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        high = head.next;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (high != null)&#123;</span><br><span class="line">        low = low.next;</span><br><span class="line">        high = high.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 反转链表</title>
    <link href="http://suiyia.github.io/2019/09/25/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://suiyia.github.io/2019/09/25/剑指offer题解-反转链表/</id>
    <published>2019-09-25T14:44:00.000Z</published>
    <updated>2019-09-25T15:36:34.199Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，反转链表后，输出新链表的表头。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li>两个索引位保存链的指向信息，然后同步右移，原地反转</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">      if (head == null)&#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode low = null;</span><br><span class="line">       ListNode high = null;</span><br><span class="line">       while (head != null)&#123;</span><br><span class="line">           high = head.next;</span><br><span class="line">           head.next = low;</span><br><span class="line">           low = head;</span><br><span class="line">           head = high;</span><br><span class="line">       &#125;</span><br><span class="line">       return low;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 调整数组顺序使奇数位于偶数前面</title>
    <link href="http://suiyia.github.io/2019/09/24/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <id>http://suiyia.github.io/2019/09/24/剑指offer题解-调整数组顺序使奇数位于偶数前面/</id>
    <published>2019-09-24T15:40:00.000Z</published>
    <updated>2019-09-24T15:42:10.869Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分</p><p>并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>插入排序</p></li><li><p>从左自右找到第一个偶数，然后在该位置右边找到第一个奇数，进行交换。</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void reOrderArray(int [] array) &#123;</span><br><span class="line">    if (array.length == 0 || array.length == 1)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while (i &lt; array.length)&#123;</span><br><span class="line">    // 找到第一个偶数</span><br><span class="line">        while ((array[i] &amp; 1) == 1)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        j = i + 1;</span><br><span class="line">        while (j &lt; array.length)&#123;</span><br><span class="line">        // 找到第一个奇数</span><br><span class="line">            if ((array[j] &amp; 1) == 0)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 插入排序</span><br><span class="line">        if (j &lt; array.length)&#123;</span><br><span class="line">            int temp = array[j];</span><br><span class="line">            for (int k = j-1; k &gt;= i ; k--) &#123;</span><br><span class="line">                array[k+1] = array[k];</span><br><span class="line">            &#125;</span><br><span class="line">            array[i++] = temp;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 数值的整数次方</title>
    <link href="http://suiyia.github.io/2019/09/24/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <id>http://suiyia.github.io/2019/09/24/剑指offer题解-数值的整数次方/</id>
    <published>2019-09-24T14:22:00.000Z</published>
    <updated>2019-09-24T14:58:09.152Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>主要考察 指数函数 的特征以及程序的健壮性</p></li><li><p>底数不能为负数</p></li><li><p>底数为 0 时，0 的 n 次方始终为 0</p></li><li><p>指数为 0 时，且任意数的 0 次方都是 1</p></li><li><p>指数为负数时，结果是越来越小的</p></li><li><p>常规思路：循环累乘，时间复杂度 0（N）</p></li><li><p>递归思路：当n为偶数，a^n =（a^n/2）×（a^n/2），当 n为奇数，a^n = a^[(n-1)/2] × a^[(n-1)/2] * a</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 循环思路</span><br><span class="line">public double Power(double base, int exponent) &#123;</span><br><span class="line">    if (base == 0 )&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exponent == 0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean flag = false;</span><br><span class="line">    if (exponent &lt; 0)&#123;</span><br><span class="line">        exponent = -1*exponent;</span><br><span class="line">        flag = true;</span><br><span class="line">    &#125;</span><br><span class="line">    double result = 1;</span><br><span class="line">    for (int i = 0; i &lt; exponent; i++) &#123;</span><br><span class="line">        result = result * base;</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag)&#123;</span><br><span class="line">        return 1.0/result;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 递归思路</span><br><span class="line">public double Power1(double base, int expone</span><br><span class="line">    if (base == 0 )&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exponent == 0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    double result = 0.0;</span><br><span class="line">    int n = Math.abs(exponent);</span><br><span class="line">    result = Power1(base,n &gt;&gt; 1);</span><br><span class="line">    result = result * result;</span><br><span class="line">    if ((n &amp; 1) == 1)&#123;</span><br><span class="line">    // 如果指数n为奇数，则要再乘一次底数base</span><br><span class="line">        result = result * base;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exponent &lt; 0)&#123;</span><br><span class="line">    // 如果指数为负数，则应该求result的倒数</span><br><span class="line">        result = 1.0/result;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 二进制中 1 的个数</title>
    <link href="http://suiyia.github.io/2019/09/23/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://suiyia.github.io/2019/09/23/剑指offer题解-二进制中-1-的个数/</id>
    <published>2019-09-23T14:57:00.000Z</published>
    <updated>2019-09-24T14:22:21.274Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>位比较</p></li><li><p>思路1：使用<strong>整数右移</strong>与 1 进行位比较，计算总个数。但是如果是负数，高位右移将会补 1，所以可以使用 &gt;&gt;&gt; 无符号右移或者将负数变为正数再进行右移。</p></li><li><p>使用 <strong>1 左移</strong>的方式进行位比较，一直比较到 Interger.MAX_VALUE = 0x7fffffff</p></li><li><p>思路2：如果一个整数不为 0，那么这个整数至少有一位是 1。</p><p>如果我们把这个整数减 1，那么原来处在整数最右边的 1 就会变为 0，1 右边的 0 变为 1。其余所有位将不会受到影响。</p><p>然后将两者相与，如果结果不为 0，说明原来整数最右边 1 的左边里面肯定包含 1，然后减 1 继续这么循环下去，不为 0 的次数就是 1 出现的次数。</p><p>例：1100 &amp; 1011 = 1000，数字 1100 最右边的 1 左边还有一个 1</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 先变为正整数</span><br><span class="line">public int NumberOf12(int n) &#123;</span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    if (n &lt; 0)&#123;</span><br><span class="line">        n = n &amp; 0x7fffffff;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (n != 0)&#123;</span><br><span class="line">        if ((n &amp; 1) != 0)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n &gt;&gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 整数无符号右移</span><br><span class="line">public int NumberOf13(int n) &#123;</span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (n != 0)&#123;</span><br><span class="line">        if ((n &amp; 1) != 0)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n &gt;&gt;&gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1 左移</span><br><span class="line">public int NumberOf1(int n) &#123;</span><br><span class="line">if (n == 0)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int flag = 1;</span><br><span class="line">    while (flag != 0)&#123;</span><br><span class="line">    if (flag &amp; n == 1)&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = flag &lt;&lt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 思路 2</span><br><span class="line">public int NumberOf11(int n) &#123;</span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (n != 0)&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        n = n &amp; (n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 矩形覆盖</title>
    <link href="http://suiyia.github.io/2019/09/23/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
    <id>http://suiyia.github.io/2019/09/23/剑指offer题解-矩形覆盖/</id>
    <published>2019-09-23T14:49:00.000Z</published>
    <updated>2019-09-23T14:57:02.886Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li>实质是斐波拉契数列</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 递归版本</span><br><span class="line">    public int RectCover(int target) &#123;</span><br><span class="line">        if (n == 1)</span><br><span class="line">            return 1;</span><br><span class="line">        if (n == 2)</span><br><span class="line">            return 2;</span><br><span class="line">        return RectCover(n - 1) + RectCover(n - 2) * 2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 变态跳台阶</title>
    <link href="http://suiyia.github.io/2019/09/23/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://suiyia.github.io/2019/09/23/剑指offer题解-变态跳台阶/</id>
    <published>2019-09-23T13:52:00.000Z</published>
    <updated>2019-09-23T14:49:00.226Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>参考前面的斐波拉契数列</p></li><li><p>第 n 层台阶可能由：第 n-1 跳一阶过来，还可能由第 n-2 跳两阶过来等，所以总情况 f（n）= f（n-2）+ f（n-1）+ … + f(1)</p></li><li><p>递推关系式实现 f（n）= 2 * f（n-1）</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 递归版本</span><br><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line"></span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 2 * Fibonacci(n-1);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 循环</span><br><span class="line">public int Fibonacci23(int n)&#123;</span><br><span class="line">if (n == 0)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">if (n == 1)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int b = 1;</span><br><span class="line">int c = 0;</span><br><span class="line">for (int i = 1;i&lt;n;i++)&#123;</span><br><span class="line">c = 2 * b;</span><br><span class="line">        b = c;</span><br><span class="line">&#125;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 跳台阶</title>
    <link href="http://suiyia.github.io/2019/09/23/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://suiyia.github.io/2019/09/23/剑指offer题解-跳台阶/</id>
    <published>2019-09-23T13:15:00.000Z</published>
    <updated>2019-09-23T13:51:57.234Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>第 n 层台阶可能由：第 n-1 跳一阶过来，还可能由第 n-2 跳两阶过来，所以总情况 f（n）= f（n-2）+ f（n-1）</p></li><li><p>其实就是斐波拉契数列</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 递归版本</span><br><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line"></span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return Fibonacci(n-1) + Fibonacci(n-2);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 循环</span><br><span class="line">public int Fibonacci23(int n)&#123;</span><br><span class="line">if (n == 0)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">if (n == 1 || n == 2)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int a = 0;</span><br><span class="line">int b = 1;</span><br><span class="line">int c = 0;</span><br><span class="line">for (int i = 1;i&lt;n;i++)&#123;</span><br><span class="line">c = a + b;</span><br><span class="line">a = b;</span><br><span class="line">b = c;</span><br><span class="line">&#125;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多项式递推</span><br><span class="line">public int Fibonacci2(int n) &#123;</span><br><span class="line">    if(n==0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else if(n==1||n==2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else if(n==3) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 3*Fibonacci(n-3)+2*Fibonacci(n-4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 斐波拉契数列</title>
    <link href="http://suiyia.github.io/2019/09/23/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://suiyia.github.io/2019/09/23/剑指offer题解-斐波拉契数列/</id>
    <published>2019-09-23T12:39:00.000Z</published>
    <updated>2019-09-23T13:14:37.538Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项（从 0 开始，第 0 项为 0）。<br>n&lt;=39</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>递归，f（n）= f（n-1）+ f（n-2），但是每一次的迭代计算结果没有保存，很容易栈溢出</p></li><li><p>循环方式，每次的结果进行累加</p></li><li><p>多项关系式递推</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 递归版本</span><br><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line"></span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return Fibonacci(n-1) + Fibonacci(n-2);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 循环</span><br><span class="line">public int Fibonacci23(int n)&#123;</span><br><span class="line">if (n == 0)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">if (n == 1 || n == 2)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int a = 0;</span><br><span class="line">int b = 1;</span><br><span class="line">int c = 0;</span><br><span class="line">for (int i = 1;i&lt;n;i++)&#123;</span><br><span class="line">c = a + b;</span><br><span class="line">a = b;</span><br><span class="line">b = c;</span><br><span class="line">&#125;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多项式递推</span><br><span class="line">public int Fibonacci2(int n) &#123;</span><br><span class="line">    if(n==0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else if(n==1||n==2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else if(n==3) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 3*Fibonacci(n-3)+2*Fibonacci(n-4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 旋转数组的最小数字</title>
    <link href="http://suiyia.github.io/2019/09/19/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://suiyia.github.io/2019/09/19/剑指offer题解-旋转数组的最小数字/</id>
    <published>2019-09-19T15:27:00.000Z</published>
    <updated>2019-09-23T12:39:25.513Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>常规思路：从头到尾遍历一遍找到最小值，时间复杂度 O（N）</p></li><li><p>方法二</p><ul><li><p>非递减数组旋转，旋转之后可以看做是两个非递减数组的拼接，当 a[index] &gt; a[index+1] 时，最小值就是 a[index+1]。</p></li><li><p>有序数组的查找，可以选择二分查找</p></li><li><p><strong>规律（数组内元素都不相同）</strong>：若 A[mid] &gt; a[low]，那么最小值一定在 mid 及 high 之间；若 A[mid] &lt; a[low]，那么最小值一定在 low 及 mid 之间</p></li></ul></li><li><p><strong>注意点：如果 A[mid] = a[low]，那么就不能判断最小值在哪一个位置。例如 01111 旋转可以变为 11110 和 10111。只能从头到尾遍历</strong></p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li>方法二实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public int minNumberInRotateArray(int [] array) &#123;</span><br><span class="line"></span><br><span class="line">    if (array.length == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (array.length == 1)&#123;</span><br><span class="line">        return array[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = array.length - 1;</span><br><span class="line"></span><br><span class="line">    while(low &lt; high)&#123;</span><br><span class="line">        int mid = (low + high) / 2;</span><br><span class="line">        if (low == high -1)&#123;</span><br><span class="line">            return array[high];</span><br><span class="line">        &#125;</span><br><span class="line">        if (array[mid] &gt; array[low])&#123;</span><br><span class="line">                // 最小值在右边</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;else if (array[mid] &lt; array[low])&#123;</span><br><span class="line">                // 最小值在左边</span><br><span class="line">                high = mid;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            // 分辨不出最小值位置</span><br><span class="line">  return serach(array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // 从头到尾查找一遍</span><br><span class="line">    public int serach(int[] array)&#123;</span><br><span class="line">    int minValue = Integer.MAX_VALUE;</span><br><span class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        if (array[i] &lt; minValue)&#123;</span><br><span class="line">            minValue = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return minValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>数组为空，或者只有一个长度的情况，考虑数组边界问题</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 两个栈实现队列</title>
    <link href="http://suiyia.github.io/2019/09/19/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://suiyia.github.io/2019/09/19/剑指offer题解-两个栈实现队列/</id>
    <published>2019-09-19T13:13:00.000Z</published>
    <updated>2019-09-19T15:13:51.892Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>方法 1（常规思路，移动次数较多）</p><ul><li><p>stack1 专门用于 push 数据，stack2 专门 pop 数据。</p></li><li><p>调用 pop() 方法时候，stack1 数据全部 push 到 stack2，保存 stack2 最顶上元素。</p></li><li><p>pop 方法结束之前，将 stack2 的数据再推回到 stack1 中。</p></li></ul></li></ul><ul><li><p>方法 2（推荐，移动次数少）</p><ul><li><p>stack1 专门用于 push 数据。</p></li><li><p>pop 方法调用的时候，<strong>若 stack2 为空</strong>就先将 stack1 中的<strong>全部数据</strong>推到 stack2，然后 pop stack2 中的元素；否则直接 pop stack2 中的数据。</p></li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li>方法二</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</span><br><span class="line">   Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   public void push(int node) &#123;</span><br><span class="line">       stack1.push(node);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public int pop() &#123;</span><br><span class="line">       if (stack1.isEmpty() &amp;&amp; stack2.isEmpty())&#123;</span><br><span class="line">           throw new RuntimeException(&quot;Empty exception!&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       if (stack2.isEmpty())&#123;</span><br><span class="line">           while (!stack1.isEmpty())&#123;</span><br><span class="line">               stack2.push(stack1.pop());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return stack2.pop();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>pop 数据考虑边界情况，栈为空</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 重建二叉树</title>
    <link href="http://suiyia.github.io/2019/09/18/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://suiyia.github.io/2019/09/18/剑指Offer题解-重建二叉树/</id>
    <published>2019-09-18T14:32:00.000Z</published>
    <updated>2019-09-19T15:13:51.912Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>方法 1. 使用栈保存遍历链表的结果，然后 push 栈输出到 ArrayList</p></li><li><p>方法 2. 递归方式实现倒序输出</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><strong>递归方式实现</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">       if (listNode != null)&#123;</span><br><span class="line">           printListFromTailToHead(listNode.next);</span><br><span class="line">           arrayList.add(listNode.val);</span><br><span class="line">       &#125;</span><br><span class="line">       return arrayList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   class ListNode &#123;</span><br><span class="line">       int val;</span><br><span class="line">       ListNode next = null;</span><br><span class="line"></span><br><span class="line">           ListNode(int val) &#123;</span><br><span class="line">           this.val = val;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 从尾到头打印链表</title>
    <link href="http://suiyia.github.io/2019/09/17/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://suiyia.github.io/2019/09/17/剑指Offer题解-从尾到头打印链表/</id>
    <published>2019-09-17T15:18:00.000Z</published>
    <updated>2019-09-19T15:13:51.901Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>方法 1. 使用栈保存遍历链表的结果，然后 push 栈输出到 ArrayList</p></li><li><p>方法 2. 递归方式实现倒序输出</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><strong>递归方式实现</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">       if (listNode != null)&#123;</span><br><span class="line">           printListFromTailToHead(listNode.next);</span><br><span class="line">           arrayList.add(listNode.val);</span><br><span class="line">       &#125;</span><br><span class="line">       return arrayList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   class ListNode &#123;</span><br><span class="line">       int val;</span><br><span class="line">       ListNode next = null;</span><br><span class="line"></span><br><span class="line">           ListNode(int val) &#123;</span><br><span class="line">           this.val = val;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 替换空格</title>
    <link href="http://suiyia.github.io/2019/09/17/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC-%E5%89%91%E6%8C%87Offer/"/>
    <id>http://suiyia.github.io/2019/09/17/替换空格-剑指Offer/</id>
    <published>2019-09-17T13:31:00.000Z</published>
    <updated>2019-09-19T15:13:51.870Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>不使用工具类</p></li><li><p>思路：先统计空格出现次数，然后就知道了替换后的字符串长度，使用另外的字符串数组保存替换后的字符串，然后从右往左进行填充</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><p>先统计空格出现的次数，出现一次空格，那么增加的长度就是加 2，N 个空格就是增加了 N*2</p></li><li><p>然后用另外的数组保存替换后的字符</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static String replaceSpace(StringBuffer str) &#123;</span><br><span class="line"></span><br><span class="line">// 统计空格数量</span><br><span class="line">        int spaceCount = 0;</span><br><span class="line">        for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">            if (str.charAt(i) == &apos; &apos;)&#123;</span><br><span class="line">                spaceCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int length = str.length();</span><br><span class="line">        // 用另外的字符数组保存字符</span><br><span class="line">        char[] a = new char[length + spaceCount * 2];</span><br><span class="line">        </span><br><span class="line">        // 字符数组索引，从最后面开始</span><br><span class="line">        int afterIndex = length + spaceCount * 2 - 1;</span><br><span class="line">        </span><br><span class="line">        for (int j = length - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            if (str.charAt(j) != &apos; &apos;)&#123;</span><br><span class="line">            // 如果不是空格，就直接赋值，索引也跟着减</span><br><span class="line">                a[afterIndex] = str.charAt(j);</span><br><span class="line">                afterIndex --;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                a[afterIndex] = &apos;0&apos;;</span><br><span class="line">                a[afterIndex - 1] = &apos;2&apos;;</span><br><span class="line">                a[afterIndex - 2] = &apos;%&apos;;</span><br><span class="line">                afterIndex = afterIndex - 3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return String.valueOf(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>从后往前填充相对简单点</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 二维数组中的查找 </title>
    <link href="http://suiyia.github.io/2019/09/16/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE-%E5%89%91%E6%8C%87Offer/"/>
    <id>http://suiyia.github.io/2019/09/16/二维数组中的查找-剑指Offer/</id>
    <published>2019-09-16T15:11:00.000Z</published>
    <updated>2019-09-19T15:11:08.513Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>常规思路：左上角开始，每行从左到右都轮询一次。</p><ul><li><p>时间复杂度 O（N^2）</p></li><li><p>空间复杂度 O（1）</p></li></ul></li><li><p>从右下角开始，每行从左往右轮询：上面一行相同列的元素比当前元素小，右边同行元素比当前元素大，那么不用全部元素比较。</p><ul><li><p>时间复杂度：O(行高 + 列宽)</p></li><li><p>空间复杂度：O(1)</p></li></ul></li></ul><ul><li>从右上角开始，从右往左。原理同上</li></ul><ul><li>从右下角开始，和常规思路类似</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>M 行 N 列数组，寻找元素 K</p><ul><li>左下角开始寻找</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static boolean Find(int target, int [][] array) &#123;</span><br><span class="line"></span><br><span class="line">    int i = array.length - 1;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while (i &gt;= 0 &amp;&amp; j &lt; array[0].length)&#123;</span><br><span class="line">        if (array[i][j] &gt; target) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;else if(array[i][j] &lt; target)&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li><p>数组边界问题</p></li><li><p>常规思路，遇到有序序列进行查找时，可以使用<strong>二分查找</strong>，时间复杂度将进一步降低，时间复杂度 Mlog(n)</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 10 2019 22:34:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
