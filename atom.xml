<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸟日常</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suiyia.github.io/"/>
  <updated>2019-09-18T14:31:04.921Z</updated>
  <id>http://suiyia.github.io/</id>
  
  <author>
    <name>Answer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer题解 | 从尾到头打印链表</title>
    <link href="http://suiyia.github.io/2019/09/17/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://suiyia.github.io/2019/09/17/剑指Offer题解-从尾到头打印链表/</id>
    <published>2019-09-17T15:18:00.000Z</published>
    <updated>2019-09-18T14:31:04.921Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>方法 1. 使用栈保存遍历链表的结果，然后 push 栈输出到 ArrayList</p></li><li><p>方法 2. 递归方式实现倒序输出</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><strong>递归方式实现</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">       if (listNode != null)&#123;</span><br><span class="line">           printListFromTailToHead(listNode.next);</span><br><span class="line">           arrayList.add(listNode.val);</span><br><span class="line">       &#125;</span><br><span class="line">       return arrayList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   class ListNode &#123;</span><br><span class="line">       int val;</span><br><span class="line">       ListNode next = null;</span><br><span class="line"></span><br><span class="line">           ListNode(int val) &#123;</span><br><span class="line">           this.val = val;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指Offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer题解 | 替换空格</title>
    <link href="http://suiyia.github.io/2019/09/17/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC-%E5%89%91%E6%8C%87Offer/"/>
    <id>http://suiyia.github.io/2019/09/17/替换空格-剑指Offer/</id>
    <published>2019-09-17T13:31:00.000Z</published>
    <updated>2019-09-17T15:29:07.988Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>不使用工具类</p></li><li><p>思路：先统计空格出现次数，然后就知道了替换后的字符串长度，使用另外的字符串数组保存替换后的字符串，然后从右往左进行填充</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><p>先统计空格出现的次数，出现一次空格，那么增加的长度就是加 2，N 个空格就是增加了 N*2</p></li><li><p>然后用另外的数组保存替换后的字符</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static String replaceSpace(StringBuffer str) &#123;</span><br><span class="line"></span><br><span class="line">// 统计空格数量</span><br><span class="line">        int spaceCount = 0;</span><br><span class="line">        for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">            if (str.charAt(i) == &apos; &apos;)&#123;</span><br><span class="line">                spaceCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int length = str.length();</span><br><span class="line">        // 用另外的字符数组保存字符</span><br><span class="line">        char[] a = new char[length + spaceCount * 2];</span><br><span class="line">        </span><br><span class="line">        // 字符数组索引，从最后面开始</span><br><span class="line">        int afterIndex = length + spaceCount * 2 - 1;</span><br><span class="line">        </span><br><span class="line">        for (int j = length - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            if (str.charAt(j) != &apos; &apos;)&#123;</span><br><span class="line">            // 如果不是空格，就直接赋值，索引也跟着减</span><br><span class="line">                a[afterIndex] = str.charAt(j);</span><br><span class="line">                afterIndex --;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                a[afterIndex] = &apos;0&apos;;</span><br><span class="line">                a[afterIndex - 1] = &apos;2&apos;;</span><br><span class="line">                a[afterIndex - 2] = &apos;%&apos;;</span><br><span class="line">                afterIndex = afterIndex - 3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return String.valueOf(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>从后往前填充相对简单点</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指Offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer题解 | 二维数组中的查找 </title>
    <link href="http://suiyia.github.io/2019/09/16/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE-%E5%89%91%E6%8C%87Offer/"/>
    <id>http://suiyia.github.io/2019/09/16/二维数组中的查找-剑指Offer/</id>
    <published>2019-09-16T15:11:00.000Z</published>
    <updated>2019-09-17T15:27:59.056Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>常规思路：左上角开始，每行从左到右都轮询一次。</p><ul><li><p>时间复杂度 O（N^2）</p></li><li><p>空间复杂度 O（1）</p></li></ul></li><li><p>从右下角开始，每行从左往右轮询：上面一行相同列的元素比当前元素小，右边同行元素比当前元素大，那么不用全部元素比较。</p><ul><li><p>时间复杂度：O(行高 + 列宽)</p></li><li><p>空间复杂度：O(1)</p></li></ul></li></ul><ul><li>从右上角开始，从右往左。原理同上</li></ul><ul><li>从右下角开始，和常规思路类似</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>M 行 N 列数组，寻找元素 K</p><ul><li>左下角开始寻找</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static boolean Find(int target, int [][] array) &#123;</span><br><span class="line"></span><br><span class="line">    int i = array.length - 1;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while (i &gt;= 0 &amp;&amp; j &lt; array[0].length)&#123;</span><br><span class="line">        if (array[i][j] &gt; target) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;else if(array[i][j] &lt; target)&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li><p>数组边界问题</p></li><li><p>常规思路，遇到有序序列进行查找时，可以使用<strong>二分查找</strong>，时间复杂度将进一步降低，时间复杂度 Mlog(n)</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指Offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Log4j 2 基本概念</title>
    <link href="http://suiyia.github.io/2019/09/04/Log4j-2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://suiyia.github.io/2019/09/04/Log4j-2-基本概念/</id>
    <published>2019-09-04T06:52:00.000Z</published>
    <updated>2019-09-04T07:00:04.528Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --><h1 id="日志框架分类"><a href="#日志框架分类" class="headerlink" title="日志框架分类"></a>日志框架分类</h1><p>日志框架按照功能可以分为日志接口、日志实现两部分。</p><p>编写程序时，推荐使用<strong>日志接口</strong>的 API 进行方法调用，然后使用对应的<strong>日志实现框架</strong>打印日志。</p><ul><li><p>日志接口，日志的接口规范，它对用户提供了统一的日志接口，屏蔽了不同日志组件的差异。</p><ul><li><p><a href="https://commons.apache.org/proper/commons-logging/" target="_blank" rel="noopener">Apache Commons Logging Component</a>，2014 年之后文档没有再更新</p></li><li><p><a href="https://www.slf4j.org/" target="_blank" rel="noopener">SLF4J（Simple Logging Facade for Java）</a></p></li></ul></li><li><p>日志实现，定义具体日志打印内容</p><ul><li><p>JDKLog，java.util.logging.Logger</p></li><li><p><a href="http://logging.apache.org/log4j/1.2/" target="_blank" rel="noopener">Log4J</a>，2015 年开始已经停止维护</p></li><li><p><a href="https://logback.qos.ch/" target="_blank" rel="noopener">LOGBack</a>，继承于 Log4J</p></li><li><p><a href="https://logging.apache.org/log4j/2.x/" target="_blank" rel="noopener">Log4J2</a> Log4J 升级版，2019-08-06 版本更新至 2.12.1，API 相关用法不兼容 1.X 版本</p></li></ul></li></ul><h1 id="Log4j-2-内置概念"><a href="#Log4j-2-内置概念" class="headerlink" title="Log4j 2 内置概念"></a>Log4j 2 内置概念</h1><ul><li>Markers：为某条日志添加标志位，使用 %marker 进行输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">    private static final Marker SQL_MARKER = MarkerManager.getMarker(&quot;SQL&quot;);</span><br><span class="line">    Marker markerA = MarkerManager.getMarker(&quot;Marker A&quot;);</span><br><span class="line">    Marker markerB = MarkerManager.getMarker(&quot;Marker B&quot;);</span><br><span class="line">    logger.debug(markerA,&quot;your name is &#123;&#125; &quot;,&quot;Jack&quot;);</span><br><span class="line">    logger.debug(markerB,&quot;your name is &#123;&#125; &quot;,&quot;Ma&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log4j.xml：</span><br><span class="line">&lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M %marker - %msg%xEx%n&quot;/&gt;</span><br><span class="line"></span><br><span class="line">Console Out：</span><br><span class="line">10:14:02.639 DEBUG FlowTracing 60 test Marker A - your name is Jack </span><br><span class="line">10:14:02.642 DEBUG FlowTracing 61 test Marker B - your name is Ma</span><br></pre></td></tr></table></figure><ul><li><p>Lookups：在配置文件中添加变量、使用变量</p></li><li><p>Appenders：定义日志事件输出方式（日志文件名称、路径、什么级别日志才能输出、文件大小等等），其实就是文件流输出定义。</p><ul><li>AsyncAppender 用另外的线程记录日志，默认使用 ArrayBlockingQueue 队列进行日志记录，当发生异常时，默认会忽略异常，记得手动开启，并使用FailoverAppender 对异常情况进行补充打印输出</li><li>ConsoleAppender，控制台输出</li><li>FailoverAppender，当主 Appender 失败时，它将起作用</li><li>FileAppender，文件输出，当多个程序对同一文件进行输出时，各自程序之间的配置也不受影响</li><li>JDBCAppender，直接写到数据库</li><li>HttpAppender，http 请求发送到另外的服务接收，如果服务返回的不是 2XX，将会抛出异常。</li><li>KafkaAppender，发送到 Kafka</li><li>RollingFileAppender，可以滚动的文件输出，包含触发规则（触发滚动条件：时间、大小）、滚动规则（怎么进行更新：文件数量），默认日志文件个数为 7 个。</li><li><a href="https://logging.apache.org/log4j/2.x/manual/appenders.html" target="_blank" rel="noopener">等等</a></li></ul></li><li><p>Layouts：Appender 使用定义好的 LayOut 对 LogEvent 进行格式化输出，</p><ul><li>CSV Layouts，以 Comma Separated Value (CSV) 形式输出</li><li>JSON Layout，JSON 格式输出</li><li>Pattern Layout，用特殊的字符输出对应的内容，定制化强</li><li>XML Layout</li><li>Location Infomation，当日志中需要日志所在类、方法、代码行数这些信息时，会花费 1.3-5 倍的时间，相比不需要 Location Infomation 的场景。并且在使用异步的 Appender 时，默认的 Location Infomation 默认关闭，如果开启，会比不开启花费 30-100 倍的性能消耗</li></ul></li><li><p>Filters：决定哪些事件可以输出，哪些事件不能输出。过滤结果有 3 个结果，ACCEPT（允许）, DENY（拒绝输出）or NEUTRAL（中立、默认）。</p><ul><li>BurstFilter，当每秒日志输出事件速率大于一定值，将会抛弃掉级别低的日志</li><li>CompositeFilter，直接在 configuration 级别添加多个过滤器</li><li>DynamicThresholdFilter，根据一些属性值去动态修改该条日志的输出级别</li><li>MapFilter，如果 LogEvent 中的 MapMessage 内包含特定属性，就可以选择过滤</li><li>MarkerFilter、NoMarkerFilter，对应定义或者未定义 Marker 的事件进行过滤</li><li>RegexFilter，正则过滤 formatted or unformatted message</li><li>ThreadContextMapFilter ，对 ThreadContextMap 中的内容进行过滤</li><li>ThresholdFilter，对 Level 进行过滤</li><li>TimeFilter，根据某个时间点、时间段进行过滤</li></ul></li></ul><h1 id="3-Java-API-用法"><a href="#3-Java-API-用法" class="headerlink" title="3. Java API 用法"></a>3. Java API 用法</h1><ul><li><p>Flow Tracing</p><p>日志跟踪</p></li><li><p>Markers（标记）</p><p>对于有特定标识需求的地方，可以使用 Marker 进行标记，并且用 %marker 进行打印输出。</p></li><li><p>ThreadContext</p><p>Mapped Diagnostic Context（MDC）的实现，类似 request，可以存放 key-value 键值对，也可以销毁，使用 %X{key} 输出。</p><p>the MDC is a map which stores the context data of the particular thread where the context is running.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%X&#123;id&#125; 输出 context map 中 key = id 的值</span><br><span class="line">%X 输出 context map 所有值</span><br><span class="line"></span><br><span class="line">public void test()&#123;</span><br><span class="line">    ThreadContext.put(&quot;id&quot;, &quot;321&quot;); // Add the fishtag;</span><br><span class="line">    ThreadContext.put(&quot;name&quot;, &quot;996&quot;); // Add the fishtag;</span><br><span class="line">    logger.debug(&quot;Message 1&quot;);</span><br><span class="line">    logger.debug(&quot;Message 2&quot;);</span><br><span class="line">    ThreadContext.clearAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>log4j-slf4j-impl 是 slf4j 转接到 log4j 2 的日志输出框架。</p><p>slf4j-log4j12 是 slf4j 转接到 log4j 1.x 的日志输出框架 ，而 log4j 1.x 已经在 2015 年 8 月就停止更新了。</p><p>log4j 官方建议升级到 log4j 2</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;日志框架分类&quot;&gt;&lt;a href=&quot;#日志框架分类&quot; class=&quot;headerlink&quot; title=&quot;日志框架分类&quot;&gt;&lt;/a&gt;日志框
      
    
    </summary>
    
      <category term="日志" scheme="http://suiyia.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="Log4j" scheme="http://suiyia.github.io/tags/Log4j/"/>
    
  </entry>
  
  <entry>
    <title>浮点数整数转换精度丢失问题</title>
    <link href="http://suiyia.github.io/2019/08/10/%E6%B5%AE%E7%82%B9%E6%95%B0%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
    <id>http://suiyia.github.io/2019/08/10/浮点数整数转换精度丢失问题/</id>
    <published>2019-08-10T09:44:00.000Z</published>
    <updated>2019-09-19T10:36:57.304Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 19 2019 18:36:57 GMT+0800 (GMT+08:00) --><h1 id="浮点数转换精度丢失"><a href="#浮点数转换精度丢失" class="headerlink" title="浮点数转换精度丢失"></a>浮点数转换精度丢失</h1><p>在线支付对接，支付商（微信、支付宝、银联等）的接口中，定义的金额单位不一样，有时候需要对<strong>分、元</strong>进行相互转换，转换的过程中容易出现问题。</p><p>下面的例子，系统中接收的参数是元，请求接口单位是分，在转换过程中出现精度丢失，少扣了用户 1 分钱。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println((int) (0.29*100));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出： 28</span><br></pre></td></tr></table></figure><p></p><ul><li>错误原因</li></ul><p>0.29*100 = 28.999999999999996…</p><p>浮点数强制转换成整数类型会舍弃非整数部分</p><ul><li>解决方法</li></ul><p>(int) Math.round(0.29*100) -&gt; 29</p><h1 id="浮点数大小比较错误"><a href="#浮点数大小比较错误" class="headerlink" title="浮点数大小比较错误"></a>浮点数大小比较错误</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 例子 1</span><br><span class="line">System.out.println(0.1d == 0.1f);  // false</span><br><span class="line">// 例子 2</span><br><span class="line">System.out.println(10.222222225f == 10.222222229f); // true</span><br><span class="line">System.out.println(10.222222225f &gt; 10.222222229f); // false</span><br><span class="line">System.out.println(10.222222225f &lt; 10.222222229f); // false</span><br><span class="line">// 例子 3</span><br><span class="line">Double a = Double.valueOf(&quot;0.0&quot;);</span><br><span class="line">Double b = Double.valueOf(&quot;-0.0&quot;);</span><br><span class="line">System.out.println(a.equals(b));  // false</span><br></pre></td></tr></table></figure><p>浮点数由于精度问题，并不能用 ==，&gt;，&lt; 来进行大小比较，最好的方式就是<strong>定义一个精度，用差的绝对值比较，在精度范围内就认为是相等的</strong></p><p><a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.6.2" target="_blank" rel="noopener">官方文档参考</a></p><p><a href="https://blog.csdn.net/wcxiaoych/article/details/42806313" target="_blank" rel="noopener">Java中的浮点数比较 == equals 和 compare</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 19 2019 18:36:57 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;浮点数转换精度丢失&quot;&gt;&lt;a href=&quot;#浮点数转换精度丢失&quot; class=&quot;headerlink&quot; title=&quot;浮点数转换精度丢失
      
    
    </summary>
    
    
      <category term="浮点数" scheme="http://suiyia.github.io/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Springboot 项目运用 Redis 缓存数据</title>
    <link href="http://suiyia.github.io/2019/08/10/Springboot-%E9%A1%B9%E7%9B%AE%E8%BF%90%E7%94%A8-Redis-%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE/"/>
    <id>http://suiyia.github.io/2019/08/10/Springboot-项目运用-Redis-缓存数据/</id>
    <published>2019-08-10T09:40:00.000Z</published>
    <updated>2019-08-10T09:51:13.059Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Springboot 项目与 Redis 结合获取数据</p><h1 id="pom-依赖"><a href="#pom-依赖" class="headerlink" title="pom 依赖"></a>pom 依赖</h1><p>主要是 mybatis、redis 的相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">  &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.18.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;8.0.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /web</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      # 数据库访问配置, 使用druid数据源</span><br><span class="line">      type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">      url: jdbc:mysql://127.0.0.1:3306/test?useunicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">      username: root</span><br><span class="line">      password: 123456</span><br><span class="line">      # 连接池配置</span><br><span class="line">      initial-size: 5</span><br><span class="line">      min-idle: 5</span><br><span class="line">      max-active: 20</span><br><span class="line">      # 连接等待超时时间</span><br><span class="line">      max-wait: 30000</span><br><span class="line">      # 配置检测可以关闭的空闲连接间隔时间</span><br><span class="line">      time-between-eviction-runs-millis: 60000</span><br><span class="line">      # 配置连接在池中的最小生存时间</span><br><span class="line">      min-evictable-idle-time-millis: 300000</span><br><span class="line">      validation-query: select &apos;1&apos; from dual</span><br><span class="line">      test-while-idle: true</span><br><span class="line">      test-on-borrow: false</span><br><span class="line">      test-on-return: false</span><br><span class="line">      # 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">      pool-prepared-statements: true</span><br><span class="line">      max-open-prepared-statements: 20</span><br><span class="line">      max-pool-prepared-statement-per-connection-size: 20</span><br><span class="line">      # 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, &apos;wall&apos;用于防火墙</span><br><span class="line">      filters: stat,wall</span><br><span class="line">      # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔</span><br><span class="line">      aop-patterns: com.springboot.servie.*</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    # Redis数据库索引（默认为0）</span><br><span class="line">    database: 0</span><br><span class="line">    # Redis服务器地址</span><br><span class="line">    host: localhost</span><br><span class="line">    # Redis服务器连接端口</span><br><span class="line">    port: 6379</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    com.example.demo.dao: debug</span><br></pre></td></tr></table></figure><h1 id="Redis-配置类"><a href="#Redis-配置类" class="headerlink" title="Redis 配置类"></a>Redis 配置类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig extends CachingConfigurerSupport &#123;</span><br><span class="line"></span><br><span class="line">    // 自定义缓存key生成策略</span><br><span class="line">    @Override</span><br><span class="line">    @Bean</span><br><span class="line">    public KeyGenerator keyGenerator() &#123;</span><br><span class="line">        return new KeyGenerator() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object generate(Object target, java.lang.reflect.Method method, Object... params) &#123;</span><br><span class="line">                StringBuffer sb = new StringBuffer();</span><br><span class="line">                sb.append(target.getClass().getName());</span><br><span class="line">                sb.append(method.getName());</span><br><span class="line">                for (Object obj : params) &#123;</span><br><span class="line">                    sb.append(obj.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                return sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 缓存管理器</span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) &#123;</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.create(connectionFactory);</span><br><span class="line">        return cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        StringRedisTemplate template = new StringRedisTemplate(factory);</span><br><span class="line">        setSerializer(template);// 设置序列化工具</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setSerializer(StringRedisTemplate template) &#123;</span><br><span class="line">        @SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="dao-层以及实现"><a href="#dao-层以及实现" class="headerlink" title="dao 层以及实现"></a>dao 层以及实现</h1><p>使用 MyBatis 注解方式实现数据访问<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface StudentManager &#123;</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update student set sname=#&#123;sname&#125;,ssex=#&#123;ssex&#125; where sno=#&#123;sno&#125;&quot;)</span><br><span class="line">    int update(Student student);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from student where sno=#&#123;sno&#125;&quot;)</span><br><span class="line">    void deleteStudentBySno(String sno);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from student where sno=#&#123;sno&#125;&quot;)</span><br><span class="line">    @Results(id = &quot;student&quot;, value = &#123; @Result(property = &quot;sno&quot;, column = &quot;sno&quot;, javaType = String.class),</span><br><span class="line">        @Result(property = &quot;sname&quot;, column = &quot;sname&quot;, javaType = String.class),</span><br><span class="line">        @Result(property = &quot;ssex&quot;, column = &quot;ssex&quot;, javaType = String.class) &#125;)</span><br><span class="line">    Student queryStudentBySno(String sno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="service-层及实现"><a href="#service-层及实现" class="headerlink" title="service 层及实现"></a>service 层及实现</h1><p>queryStudentBySno 方法使用了注解 @Cacheable(key=”#p0”)，即将 id 作为 redis 中的 key 值</p><ul><li>@CacheConfig(cacheNames = “student”) 一个类中可能会有多个缓存操作，而这些缓存操作可能是重复的</li><li>@Cacheable 是用来声明方法是可缓存的</li><li>@CachePut 主要用于数据新增和修改操作上</li><li>@CacheEvict 通常用在删除方法上，用来从缓存中移除相应数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@CacheConfig(cacheNames = &quot;student&quot;)</span><br><span class="line">public interface StudentService &#123;</span><br><span class="line"></span><br><span class="line">    @CachePut(key = &quot;#p0.sno&quot;)</span><br><span class="line">    Student update(Student student);</span><br><span class="line"></span><br><span class="line">    @CacheEvict(key = &quot;#p0&quot;, allEntries = true)</span><br><span class="line">    void deleteStudentBySno(String sno);</span><br><span class="line"></span><br><span class="line">    @Cacheable(key = &quot;#p0&quot;)</span><br><span class="line">    Student queryStudentBySno(String sno);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class StudentServiceImpl implements StudentService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentManager studentManager;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Student update(Student student) &#123;</span><br><span class="line">        this.studentManager.update(student);</span><br><span class="line">        return this.studentManager.queryStudentBySno(student.getSno());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void deleteStudentBySno(String sno) &#123;</span><br><span class="line">        this.studentManager.deleteStudentBySno(sno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Student queryStudentBySno(String sno) &#123;</span><br><span class="line">        return this.studentManager.queryStudentBySno(sno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Test-用例"><a href="#Test-用例" class="headerlink" title="Test 用例"></a>Test 用例</h1><p>第一次从数据库中读取，第二次直接从缓存读取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class DemoApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentService studentService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() &#123;</span><br><span class="line">        System.out.println(studentService.queryStudentBySno(&quot;001&quot;).toString());</span><br><span class="line">        System.out.println(studentService.queryStudentBySno(&quot;001&quot;).toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2019-08-10 17:27:32.739 DEBUG 7140 --- [           main] c.e.d.d.S.queryStudentBySno              : ==&gt;  Preparing: select * from student where sno=? </span><br><span class="line">2019-08-10 17:27:33.053 DEBUG 7140 --- [           main] c.e.d.d.S.queryStudentBySno              : ==&gt; Parameters: 001(String)</span><br><span class="line">2019-08-10 17:27:33.108 DEBUG 7140 --- [           main] c.e.d.d.S.queryStudentBySno              : &lt;==      Total: 1</span><br><span class="line">Student(sno=001, sname=KangKang, ssex=M )</span><br><span class="line">Student(sno=001, sname=KangKang, ssex=M )</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Sprin
      
    
    </summary>
    
      <category term="Spring学习" scheme="http://suiyia.github.io/categories/Spring%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Redis" scheme="http://suiyia.github.io/tags/Redis/"/>
    
      <category term="Springboot" scheme="http://suiyia.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>Springboot 使用 MyBatis 实现增删改查</title>
    <link href="http://suiyia.github.io/2019/08/10/Springboot-%E4%BD%BF%E7%94%A8-MyBatis-%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>http://suiyia.github.io/2019/08/10/Springboot-使用-MyBatis-实现增删改查/</id>
    <published>2019-08-10T09:39:00.000Z</published>
    <updated>2019-08-10T09:51:13.110Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>Springboot 项目结合 Mybatis 实现 CRUD 增删改查</p><h2 id="基本-Mysql-脚本"><a href="#基本-Mysql-脚本" class="headerlink" title="基本 Mysql 脚本"></a>基本 Mysql 脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line"> sno VARCHAR(10) NOT NULL ,</span><br><span class="line">    sname VARCHAR(10) NOT NULL ,</span><br><span class="line">    ssex VARCHAR(2) NOT NULL </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO STUDENT VALUES (&apos;001&apos;, &apos;KangKang&apos;, &apos;M &apos;);</span><br><span class="line">INSERT INTO STUDENT VALUES (&apos;002&apos;, &apos;Mike&apos;, &apos;M &apos;);</span><br><span class="line">INSERT INTO STUDEN VALUES (&apos;003&apos;, &apos;Jane&apos;, &apos;F &apos;);</span><br></pre></td></tr></table></figure><h2 id="pom-基本包依赖"><a href="#pom-基本包依赖" class="headerlink" title="pom 基本包依赖"></a>pom 基本包依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;8.0.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="配置文件-application-yml"><a href="#配置文件-application-yml" class="headerlink" title="配置文件 application.yml"></a>配置文件 application.yml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /web</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      # 数据库访问配置, 使用druid数据源</span><br><span class="line">      type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">      url: jdbc:mysql://127.0.0.1:3306/test?useunicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">      username: root</span><br><span class="line">      password: 123456</span><br><span class="line">      # 连接池配置</span><br><span class="line">      initial-size: 5</span><br><span class="line">      min-idle: 5</span><br><span class="line">      max-active: 20</span><br><span class="line">      # 连接等待超时时间</span><br><span class="line">      max-wait: 30000</span><br><span class="line">      # 配置检测可以关闭的空闲连接间隔时间</span><br><span class="line">      time-between-eviction-runs-millis: 60000</span><br><span class="line">      # 配置连接在池中的最小生存时间</span><br><span class="line">      min-evictable-idle-time-millis: 300000</span><br><span class="line">      validation-query: select &apos;1&apos; from dual</span><br><span class="line">      test-while-idle: true</span><br><span class="line">      test-on-borrow: false</span><br><span class="line">      test-on-return: false</span><br><span class="line">      # 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">      pool-prepared-statements: true</span><br><span class="line">      max-open-prepared-statements: 20</span><br><span class="line">      max-pool-prepared-statement-per-connection-size: 20</span><br><span class="line">      # 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, &apos;wall&apos;用于防火墙</span><br><span class="line">      filters: stat,wall</span><br><span class="line">      # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔</span><br><span class="line">      aop-patterns: com.springboot.servie.*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      # WebStatFilter配置</span><br><span class="line">      web-stat-filter:</span><br><span class="line">        enabled: true</span><br><span class="line">        # 添加过滤规则</span><br><span class="line">        url-pattern: /*</span><br><span class="line">        # 忽略过滤的格式</span><br><span class="line">        exclusions: &apos;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&apos;</span><br><span class="line"></span><br><span class="line">      # StatViewServlet配置</span><br><span class="line">      stat-view-servlet:</span><br><span class="line">        enabled: true</span><br><span class="line">        # 访问路径为/druid时，跳转到StatViewServlet</span><br><span class="line">        url-pattern: /druid/*</span><br><span class="line">        # 是否能够重置数据</span><br><span class="line">        reset-enable: false</span><br><span class="line">        # 需要账号密码才能访问控制台</span><br><span class="line">        login-username: druid</span><br><span class="line">        login-password: druid123</span><br><span class="line">        # IP白名单</span><br><span class="line">        # allow: 127.0.0.1</span><br><span class="line">        #　IP黑名单（共同存在时，deny优先于allow）</span><br><span class="line">        # deny: 192.168.1.218</span><br><span class="line"></span><br><span class="line">      # 配置StatFilter</span><br><span class="line">      filter:</span><br><span class="line">        stat:</span><br><span class="line">          log-slow-sql: true</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br><span class="line">  configuration-properties: BEFORE</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li><p>接口+注解形式实现数据库读取写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface StudentManagerWithInject &#123;</span><br><span class="line"></span><br><span class="line">    @Insert(&quot;insert into student(sno,sname,ssex)values(#&#123;sno&#125;,#&#123;name&#125;,#&#123;ssex&#125;)&quot;)</span><br><span class="line">    int add(Student student);</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update student set sname=#&#123;name&#125;,ssex=#&#123;sex&#125; where sno=#&#123;sno&#125;&quot;)</span><br><span class="line">    int update(Student student);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from student where sno=#&#123;sno&#125;&quot;)</span><br><span class="line">    int deleteBySno(String sno);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from student where sno=#&#123;sno&#125;&quot;)</span><br><span class="line">    @Results(id = &quot;student&quot;,value= &#123;</span><br><span class="line">        @Result(property = &quot;sno&quot;, column = &quot;sno&quot;, javaType = String.class),</span><br><span class="line">        @Result(property = &quot;name&quot;, column = &quot;sname&quot;, javaType = String.class),</span><br><span class="line">        @Result(property = &quot;sex&quot;, column = &quot;ssex&quot;, javaType = String.class)</span><br><span class="line">    &#125;)</span><br><span class="line">    Student queryStudentBySno(String sno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自动装配实现业务逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TestController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentManagerWithInject studentManagerWithInject;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentMapperWithXML studentMapperWithXML;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/querystudent&quot;,method = RequestMethod.GET)</span><br><span class="line">    public Student queryStudentBySno(</span><br><span class="line">        @RequestParam String sno)&#123;</span><br><span class="line">        return studentManagerWithInject.queryStudentBySno(sno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/querystudentwithxml&quot;,method = RequestMethod.GET)</span><br><span class="line">    public Student queryStudentWithXMLBySno(</span><br><span class="line">        @RequestParam String sno)&#123;</span><br><span class="line">        return studentMapperWithXML.queryStudentBySno(sno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用接口，得到结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/web/querystudent?sno=001</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">&#123;</span><br><span class="line">  &quot;sno&quot;: &quot;001&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;KangKang&quot;,</span><br><span class="line">  &quot;sex&quot;: &quot;M &quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><p>一般项目会增加一个 service 服务层，一个服务可能对应多个数据库操作，这里节省时间就没有加，工作中还是根据项目规范来。</p></li><li><p><a href="https://github.com/wuyouzhuguli/SpringAll" target="_blank" rel="noopener">学习参考</a></p></li><li><p><a href="https://github.com/suiyia/JavaReposity/tree/master/springboot4all" target="_blank" rel="noopener">源码第一章节</a></p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;内容&lt;/h2&gt;&lt;p&gt;Sprin
      
    
    </summary>
    
      <category term="Spring学习" scheme="http://suiyia.github.io/categories/Spring%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Springboot" scheme="http://suiyia.github.io/tags/Springboot/"/>
    
      <category term="MyBatis" scheme="http://suiyia.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Springboot 与 AOP 实现</title>
    <link href="http://suiyia.github.io/2019/08/10/Springboot-%E4%B8%8E-AOP-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://suiyia.github.io/2019/08/10/Springboot-与-AOP-实现/</id>
    <published>2019-08-10T09:39:00.000Z</published>
    <updated>2019-08-10T09:51:13.073Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Springboot 项目 AOP 实现，记录方法的执行过程</p><h1 id="pom-依赖"><a href="#pom-依赖" class="headerlink" title="pom 依赖"></a>pom 依赖</h1><p>druid、JdbcTemplate、aop</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;8.0.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">  &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.18.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;RELEASE&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><p>Mysql 脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SYS_LOG (</span><br><span class="line">   ID INT(20) NOT NULL COMMENT &apos;用户名&apos; PRIMARY KEY AUTO_INCREMENT ,</span><br><span class="line">   USERNAME VARCHAR(50) NULL COMMENT &apos;用户名&apos;,</span><br><span class="line">   OPERATION VARCHAR(50) NULL COMMENT &apos;用户操作&apos;,</span><br><span class="line">   TIME INT(11) NULL COMMENT &apos;响应时间&apos;,</span><br><span class="line">   METHOD VARCHAR(1024) NULL COMMENT &apos;请求方法&apos;,</span><br><span class="line">   PARAMS VARCHAR(1024) NULL COMMENT &apos;请求参数&apos;,</span><br><span class="line">   IP VARCHAR(64) NULL COMMENT &apos;IP地址&apos;,</span><br><span class="line">   CREATE_TIME DATE NULL COMMENT &apos;创建时间&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>实体类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import lombok.ToString;</span><br><span class="line"></span><br><span class="line">@Setter</span><br><span class="line">@Getter</span><br><span class="line">@ToString</span><br><span class="line">public class SysLog implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String operation;</span><br><span class="line">    private Integer time;</span><br><span class="line">    private String method;</span><br><span class="line">    private String params;</span><br><span class="line">    private String ip;</span><br><span class="line">    private Date createTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个方法级别的 @Log 注解，需要监控的方法加上该注解就行</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Log &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义 dao 方法，保存日志到数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SysLogDao &#123;</span><br><span class="line">    void saveSysLog(SysLog sysLog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SysLogDaoImpl implements SysLogDao &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void saveSysLog(SysLog sysLog) &#123;</span><br><span class="line">        StringBuffer sql = new StringBuffer(&quot;insert into sys_log &quot;);</span><br><span class="line">        sql.append(&quot;(username,operation,time,method,params,ip,create_time) &quot;);</span><br><span class="line">        sql.append(&quot;values(:username,:operation,:time,:method,&quot;);</span><br><span class="line">        sql.append(&quot;:params,:ip,:createTime)&quot;);</span><br><span class="line"></span><br><span class="line">        NamedParameterJdbcTemplate npjt = new NamedParameterJdbcTemplate(this.jdbcTemplate.getDataSource());</span><br><span class="line">        npjt.update(sql.toString(), new BeanPropertySqlParameterSource(sysLog));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>切面切点定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LogAspect &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SysLogDao sysLogDao;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;@annotation(com.example.demo.annotion.Log)&quot;)</span><br><span class="line">    public void pointcut()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;pointcut()&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint proceedingJoinPoint)&#123;</span><br><span class="line">        Object result = null;</span><br><span class="line">        long beginTime = System.currentTimeMillis();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 执行方法</span><br><span class="line">            result = proceedingJoinPoint.proceed();</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        // 执行时长(毫秒)</span><br><span class="line">        long time = System.currentTimeMillis() - beginTime;</span><br><span class="line">        // 保存日志</span><br><span class="line">        saveLog(proceedingJoinPoint, time);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void saveLog(ProceedingJoinPoint joinPoint, long time) &#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        SysLog sysLog = new SysLog();</span><br><span class="line">        Log logAnnotation = method.getAnnotation(Log.class);</span><br><span class="line">        if (logAnnotation != null) &#123;</span><br><span class="line">            // 注解上的描述</span><br><span class="line">            sysLog.setOperation(logAnnotation.value());</span><br><span class="line">        &#125;</span><br><span class="line">        // 请求的方法名</span><br><span class="line">        String className = joinPoint.getTarget().getClass().getName();</span><br><span class="line">        String methodName = signature.getName();</span><br><span class="line">        sysLog.setMethod(className + &quot;.&quot; + methodName + &quot;()&quot;);</span><br><span class="line">        // 请求的方法参数值</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        // 请求的方法参数名称</span><br><span class="line">        LocalVariableTableParameterNameDiscoverer u = new LocalVariableTableParameterNameDiscoverer();</span><br><span class="line">        String[] paramNames = u.getParameterNames(method);</span><br><span class="line">        if (args != null &amp;&amp; paramNames != null) &#123;</span><br><span class="line">            String params = &quot;&quot;;</span><br><span class="line">            for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                params += &quot;  &quot; + paramNames[i] + &quot;: &quot; + args[i];</span><br><span class="line">            &#125;</span><br><span class="line">            sysLog.setParams(params);</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取request</span><br><span class="line">        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        // 设置IP地址</span><br><span class="line">        sysLog.setIp(IPUtils.getIpAddr(request));</span><br><span class="line">        // 模拟一个用户名</span><br><span class="line">        sysLog.setUsername(&quot;mrbird&quot;);</span><br><span class="line">        sysLog.setTime((int) time);</span><br><span class="line">        sysLog.setCreateTime(new Date());</span><br><span class="line">        // 保存系统日志</span><br><span class="line">        sysLogDao.saveSysLog(sysLog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class IPUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取IP地址</span><br><span class="line">     *</span><br><span class="line">     * 使用Nginx等反向代理软件， 则不能通过request.getRemoteAddr()获取IP地址 如果使用了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP地址，X-Forwarded-For中第一个非unknown的有效IP字符串，则为真实IP地址</span><br><span class="line">     */</span><br><span class="line">    public static String getIpAddr(HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">        String ip = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;0:0:0:0:0:0:0:1&quot;.equals(ip) ? &quot;127.0.0.1&quot; : ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Controller 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TestController &#123;</span><br><span class="line"></span><br><span class="line">    @Log(&quot;执行方法一&quot;)</span><br><span class="line">    @GetMapping(&quot;/one&quot;)</span><br><span class="line">    public void methodOne(String name) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Log(&quot;执行方法二&quot;)</span><br><span class="line">    @GetMapping(&quot;/two&quot;)</span><br><span class="line">    public void methodTwo() throws InterruptedException &#123;</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Log(&quot;执行方法三&quot;)</span><br><span class="line">    @GetMapping(&quot;/three&quot;)</span><br><span class="line">    public void methodThree(String name, String age) &#123; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/web/one?name=KangKang</span><br><span class="line"></span><br><span class="line">http://localhost:8080/web/two</span><br><span class="line"></span><br><span class="line">http://localhost:8080/web/three?name=Mike&amp;age=25</span><br><span class="line"></span><br><span class="line">&gt; select * from sys_log order by id;</span><br><span class="line">IDUSERNAMEOPERATIONTIMEMETHODPARAMSIPCREATE_TIME</span><br><span class="line">1mrbird执行方法一3com.example.demo.web.TestController.methodOne()  name: KangKang127.0.0.12019-08-10</span><br><span class="line">2mrbird执行方法二2002com.example.demo.web.TestController.methodTwo()127.0.0.12019-08-10</span><br><span class="line">3mrbird执行方法三0com.example.demo.web.TestController.methodThree()  name: Mike  age: 25127.0.0.12019-08-10</span><br><span class="line">4mrbird执行方法三0com.example.demo.web.TestController.methodThree()  name: Mike  age: 25127.0.0.12019-08-10</span><br><span class="line">5mrbird执行方法二2001com.example.demo.web.TestController.methodTwo()127.0.0.12019-08-10</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>切面对项目响应时间的影响待测试，现在用的项目基本没有应用到切面，等有实际落地需求在改进学习下</li><li><a href="https://github.com/suiyia/JavaReposity/tree/master/springboot4all" target="_blank" rel="noopener">源码</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Sprin
      
    
    </summary>
    
      <category term="Spring学习" scheme="http://suiyia.github.io/categories/Spring%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Springboot" scheme="http://suiyia.github.io/tags/Springboot/"/>
    
      <category term="AOP" scheme="http://suiyia.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>HashMap、HashTable、ConcurrentHashMap 区别</title>
    <link href="http://suiyia.github.io/2019/04/07/HashMap%E3%80%81HashTable%E3%80%81ConcurrentHashMap-%E5%8C%BA%E5%88%AB/"/>
    <id>http://suiyia.github.io/2019/04/07/HashMap、HashTable、ConcurrentHashMap-区别/</id>
    <published>2019-04-07T06:24:00.000Z</published>
    <updated>2019-04-07T13:38:48.975Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --><blockquote><p>简单总结 HashMap、Hashtable、ConcurrentHashMap 之间的区别，基于 JDK 1.8.0_191</p></blockquote><p>先说结论，暂时有以下几个需要注意的不同点：</p><ol><li>继承、实现接口不同</li><li>初始大小、扩容倍数不同</li><li>线程安全</li><li>NULL KEY，NULL VALUE 支持不同</li><li>计算 Hash 值的方式不同</li></ol><h3 id="1-继承、实现接口不同"><a href="#1-继承、实现接口不同" class="headerlink" title="1. 继承、实现接口不同"></a>1. 继承、实现接口不同</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125;</span><br><span class="line">    </span><br><span class="line">public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;    </span><br><span class="line"></span><br><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable &#123;</span><br></pre></td></tr></table></figure><ul><li>HashMap、ConcurrentHashMap 都继承于 AbstractMap 抽象类，但 Hashtable 继承于 Dictionary 抽象类。</li><li>AbstractMap 实现了 Map 接口，而 Dictionary 没有。这使得 AbstractMap 具有更多的功能，而 Dictionary 逐渐被弃用。</li></ul><h3 id="2-初始大小、扩容倍数不同"><a href="#2-初始大小、扩容倍数不同" class="headerlink" title="2. 初始大小、扩容倍数不同"></a>2. 初始大小、扩容倍数不同</h3><p>HashMap<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">扩容部分代码：</span><br><span class="line">newThr = oldThr &lt;&lt; 1; // double threshold</span><br></pre></td></tr></table></figure><p></p><p>Hashtable<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Hashtable() &#123;</span><br><span class="line">    this(11, 0.75f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">扩容部分代码：</span><br><span class="line">int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</span><br></pre></td></tr></table></figure><p></p><p>ConcurrentHashMap<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The default initial table capacity.  Must be a power of 2</span><br><span class="line"> * (i.e., at least 1) and at most MAXIMUM_CAPACITY.</span><br><span class="line"> */</span><br><span class="line">private static final int DEFAULT_CAPACITY = 16;</span><br></pre></td></tr></table></figure><p></p><ul><li>初始大小：HashMap、ConcurrentHashMap 都是 16，Hashtable 是 11</li><li>扩容倍数：HashMap、ConcurrentHashMap 2 倍、Hashtable (2n + 1) 倍。</li></ul><h3 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3. 线程安全"></a>3. 线程安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable:</span><br><span class="line">public synchronized V put(K key, V value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">HashMap:</span><br><span class="line">public V put(K key, V value) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>Hashtable 添加元素方法加上了 synchronized 关键字，HashMap 没有，说明 HashMap 不适用于多线程环境。</li><li>ConcurrentHashMap 添加元素时，只对需要变更的地方加锁。</li></ul><h3 id="4-NULL-KEY，NULL-VALUE-支持不同"><a href="#4-NULL-KEY，NULL-VALUE-支持不同" class="headerlink" title="4. NULL KEY，NULL VALUE 支持不同"></a>4. NULL KEY，NULL VALUE 支持不同</h3><p>通过观察它们的 put 方法，得到以下结论：</p><ul><li>Hashtable、ConcurrentHashMap 的 key、value 都不能为 null。</li><li>HashMap value 可以为 null，而 key 为 null 时，该元素会放在 HashMap 第一位。</li></ul><h3 id="5-key-的索引计算方法不同"><a href="#5-key-的索引计算方法不同" class="headerlink" title="5. key 的索引计算方法不同"></a>5. key 的索引计算方法不同</h3><p>计算元素存放位置，会经过两步转化。Object -&gt; int -&gt; index，先将 key 使用 hash 方法转换为一个整数数字，然后对整型数字进行转化，得到这个对象在 map 中的索引。</p><p>Hashtable<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int hash = key.hashCode();</span><br><span class="line">int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br></pre></td></tr></table></figure><p></p><p>HashMap<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>Hashtable 直接使用对象的 hashCode，然后再使用除留余数法来获得最终的位置。</li><li>HashMap 在对象的 hashCode 之上，将 hashCode 的高16位和低16位进行异或，得到最终的位置。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>后面学习将对 HashMap，ConcurrentHashMap 源码进行分析总结。</p><p><a href="https://blog.csdn.net/varyall/article/details/81277296" target="_blank" rel="noopener">ConcurrentHashMap的扩容机制（jdk1.8）</a></p><p><a href="http://www.10tiao.com/html/710/201903/2650123468/2.html" target="_blank" rel="noopener">HashMap 和Hashtable的区别</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --&gt;&lt;blockquote&gt;&lt;p&gt;简单总结 HashMap、Hashtable、ConcurrentHashMap 之间的区别，基于 JDK 1.8.0_
      
    
    </summary>
    
      <category term="Java基础" scheme="http://suiyia.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="集合" scheme="http://suiyia.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>ArraryList、LinkList和Vector的区别</title>
    <link href="http://suiyia.github.io/2019/03/24/ArraryList%E3%80%81LinkList%E5%92%8CVector%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://suiyia.github.io/2019/03/24/ArraryList、LinkList和Vector的区别/</id>
    <published>2019-03-24T05:53:00.000Z</published>
    <updated>2019-04-07T13:32:54.477Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --><blockquote><p>本文基于 JDK 1.8.0_191</p></blockquote><h3 id="1-源码对比"><a href="#1-源码对比" class="headerlink" title="1. 源码对比"></a>1. 源码对比</h3><ul><li>实现接口类对比</li><li>扩容机制对比</li><li>线程安全</li></ul><h4 id="1-1-实现接口类对比"><a href="#1-1-实现接口类对比" class="headerlink" title="1.1 实现接口类对比"></a>1.1 实现接口类对比</h4><p><img src="https://raw.githubusercontent.com/suiyia/images/master/20190324112747.jpeg?token=ALIF2JNoBZxx5ZeHPivS9QGmNve5iPdbks5clvlwwA%3D%3D" alt=""><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">        </span><br><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable    </span><br><span class="line">    </span><br><span class="line">public class Vector&lt;E&gt;</span><br><span class="line">    extends AbstractList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p></p><ul><li><p>它们都实现 List 接口，说明具备列表的增加、删除、遍历元素等特性。</p></li><li><p>ArrayList、Vector 额外实现 RandomAccess 接口，说明他们能在常量时间复杂度内快速随机访问元素。</p></li><li><p>LinkedList 额外实现 Queue 接口，具备队列的入队、出队等特性。</p></li></ul><h4 id="1-2-扩容机制对比"><a href="#1-2-扩容机制对比" class="headerlink" title="1.2 扩容机制对比"></a>1.2 扩容机制对比</h4><p>ArrayList<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_CAPACITY = 10;  // 定义初始大小</span><br><span class="line"></span><br><span class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;  // 定义列表存储元素数量最大值 </span><br><span class="line"></span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;   // 现有元素数量 </span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);  // 增加后元素的数量 = 1 + 0.5 </span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)    // 增加后的元素数量 &lt; 现有的空间，不扩容</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);  // 增加后的元素数量 &gt; 大于最大值，尝试分配 Integer.MAX_VALUE 个元素，可能会抛出 OutOfMemoryError  </span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Vector<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Vector() &#123;</span><br><span class="line">    this(10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected int capacityIncrement;  // 扩容数量值，Vector 初始化不指定时默认为 0</span><br><span class="line"></span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); // 当扩容数量值小于 0，那么扩容比例为原来的两倍；否则扩容的数量为这个值。</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>LinkList<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient int size = 0;</span><br></pre></td></tr></table></figure><p></p><ul><li>初始大小：ArrayList、Vector 默认为 10，LinkList 不指定默认为 0</li><li>扩容比例：ArrayList 以 1.5 倍进行扩容；Vector 不指定扩容比例时默认为 2 倍进行扩容</li></ul><h4 id="1-3-线程安全性"><a href="#1-3-线程安全性" class="headerlink" title="1.3 线程安全性"></a>1.3 线程安全性</h4><p>ArrayList<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected transient int modCount = 0;</span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Vector<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected transient int modCount = 0;</span><br><span class="line"></span><br><span class="line">public synchronized void addElement(E obj) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + 1);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Vector add() 方法上增加了 synchronized 关键字，使得 Vector 支持多线程环境下的元素增加删除修改操作。</p><h3 id="2-增删改性能对比"><a href="#2-增删改性能对比" class="headerlink" title="2. 增删改性能对比"></a>2. 增删改性能对比</h3><p>根据数据结构中知识:</p><p>顺序表查找元素时间复杂度为 O(1)，适用于随机查找元素的场景。</p><p>链表增减元素时间复杂度为 O(1)，适用于增减元素比较多的场景。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList arrayList = new ArrayList();</span><br><span class="line">    LinkedList linkedList = new LinkedList();</span><br><span class="line">    Vector vector = new Vector();</span><br><span class="line">    long t1, t2;</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        arrayList.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;ArrayList add:&quot; + (t2 - t1));</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        linkedList.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;linkedList add:&quot; + (t2 - t1));</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        vector.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;vector add:&quot; + (t2 - t1));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">ArrayList add:6810212</span><br><span class="line">linkedList add:3463194</span><br><span class="line">vector add:4442985</span><br></pre></td></tr></table></figure><p>添加元素，ArrayList 花费时间比 LinkList 时间长。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList arrayList = new ArrayList();</span><br><span class="line">    LinkedList linkedList = new LinkedList();</span><br><span class="line">    Vector vector = new Vector();</span><br><span class="line">    long t1, t2;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">        arrayList.add(i);</span><br><span class="line">        linkedList.add(i);</span><br><span class="line">        vector.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        arrayList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;ArrayList get:&quot; + (t2 - t1));</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        linkedList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;linkedList get:&quot; + (t2 - t1));</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        vector.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;vector get:&quot; + (t2 - t1));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">ArrayList get:72482</span><br><span class="line">linkedList get:107975370</span><br><span class="line">vector get:242634</span><br></pre></td></tr></table></figure><p></p><p>查找元素上，ArrayList 最快</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>将 ArrayList、LinkList 和 Vetor 进行了简单对比，总体来说：</p><ul><li>在查找元素比较频繁的场合，推荐使用 ArrayList；在修改元素比较频繁的场合，推荐使用 LinkList。</li><li>Vetor 与 ArrayList 类似，区别在于扩容比例、线程安全方面。</li><li>性能对比测试结果可能存在添加元素 ArrayList 花费时间比 LinkList 多的情况， 这个原因</li></ul><p>参考：</p><p><a href="https://www.hollischuang.com/archives/1349" target="_blank" rel="noopener">ArrayList vs LinkedList vs Vector 区别</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --&gt;&lt;blockquote&gt;&lt;p&gt;本文基于 JDK 1.8.0_191&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;1-源码对比&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="Java基础" scheme="http://suiyia.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="集合" scheme="http://suiyia.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java字符串拼接效率对比</title>
    <link href="http://suiyia.github.io/2019/03/17/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94/"/>
    <id>http://suiyia.github.io/2019/03/17/Java-字符串拼接效率对比/</id>
    <published>2019-03-17T07:30:00.000Z</published>
    <updated>2019-04-07T13:32:54.526Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --><p><img src="https://note.youdao.com/yws/public/resource/27422d1c5ab3fa95a4e668c46ec74791/E06E2A8F7F51469DAFA40E6A9D43EA2B?ynotemdtimestamp=1552808544738" alt="image"><br>用 Google photo 搜索关键词「String」，出现了上图，有兴趣的朋友可以试试，感觉发现了新大陆…</p><p>Java 中有 3 种字符串的拼接方式，了解这三种拼接方式的实现，将有益于提高自己的代码质量。</p><p>本文主要讲解 String 对象的三种拼接方式，以及它们之间的效率对比。</p><h3 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 方式 1</span><br><span class="line">String s = &quot;Hello&quot;;</span><br><span class="line">s += &quot;Hello&quot;;</span><br><span class="line"></span><br><span class="line">// 方式 2</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder(&quot;Hello&quot;);</span><br><span class="line">stringBuilder.append(&quot;Hello&quot;);</span><br><span class="line"></span><br><span class="line">// 方式 3</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer(&quot;Hello&quot;);</span><br><span class="line">stringBuffer.append(&quot;Hello&quot;);</span><br></pre></td></tr></table></figure><p>自己写个主函数，将上面 3 个方法循环执行 10000 次；</p><p><strong>执行时间</strong> t1 &gt; t3 &gt; t2，也就是说 StringBuilder.append() 拼接最快，String += 最慢。</p><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><ul><li>StringBuilder.append() 拼接</li></ul><p>StringBuilder.java<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class StringBuilder</span><br><span class="line">    extends AbstractStringBuilder</span><br><span class="line">    implements java.io.Serializable, CharSequence</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);  // 调用父类 append 方法</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>AbstractStringBuilder.java<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public AbstractStringBuilder append(String str) &#123;</span><br><span class="line">    if (str == null)</span><br><span class="line">        return appendNull();</span><br><span class="line">    int len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(0, len, value, count);  // 调用 String 的 getChars 方法</span><br><span class="line">    count += len;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>String.java<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123;</span><br><span class="line">    if (srcBegin &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    if (srcEnd &gt; value.length) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    if (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);  // 本地方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>从上面 3 段代码可知，StringBuilder.append 方法调用的是父类 AbstractStringBuilder.append，父类 append 方法调用了 String 的本地方法 System.arraycopy 实现</strong></p><ul><li>StringBuffer.append() 拼接</li></ul><p>StringBuilder.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class StringBuffer</span><br><span class="line">    extends AbstractStringBuilder</span><br><span class="line">    implements java.io.Serializable, CharSequence</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public synchronized StringBuffer append(String str) &#123;</span><br><span class="line">    toStringCache = null;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>StringBuffer.append 方法与 StringBuilder.append 方法类似，不同的是，append 方法加上了 synchronized 锁，说明该方法适用于多线程环境，但是加锁的过程需要耗时，所以执行时间比 StringBuilder.append 慢。</strong></p><ul><li>String += 拼接</li></ul><p>对下面代码进行编译，生成的 class 文件使用命令 javap -c Main.class，可以反编译得到图片中的字节码。</p><p>可以看到 += 实际调用的是 StringBuilder.append() 方法，所以速度会比 StringBuilder 慢。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s = &quot;Hello&quot;;</span><br><span class="line">    s = s + &quot; World&quot;;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://note.youdao.com/yws/public/resource/27422d1c5ab3fa95a4e668c46ec74791/06E6477B2E6F4209B3DA88D5BF43E5F8?ynotemdtimestamp=1552808544738" alt="image"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以在需要拼接字符串的场合，尽量适用 StringBuilder.append() 方法，多线程环境下则推荐 StringBuffer.append() 方法，而 String += 拼接方式任何场合都不建议使用。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/27422d1c5ab3fa95a4
      
    
    </summary>
    
      <category term="Java基础" scheme="http://suiyia.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="String" scheme="http://suiyia.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Java中的值传递</title>
    <link href="http://suiyia.github.io/2019/02/18/Java-%E4%B8%AD%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <id>http://suiyia.github.io/2019/02/18/Java-中的值传递/</id>
    <published>2019-02-18T15:12:00.000Z</published>
    <updated>2019-04-07T13:32:54.490Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --><h3 id="几个重要概念"><a href="#几个重要概念" class="headerlink" title="几个重要概念"></a>几个重要概念</h3><ul><li><p><strong>实参、形参</strong></p><ul><li><p>形式参数：定义函数名和函数体时候使用的参数，目的用来<strong>接收</strong>调用该函数时<strong>传入的参数</strong></p></li><li><p>实际参数：在调用有参函数时，主调函数与被调函数之间有数据传递关系。实际参数是<strong>调用有参方法的时候真正传递的内容</strong>。</p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public void tes(String name)&#123; // 形式参数 name</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Test test = new Test();</span><br><span class="line">    test.tes(&quot;caijicoder&quot;); // 实际参数 caijicoder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><strong>值类型、引用类型：</strong></li></ul><p>值类型就是<strong>基本数据类型</strong>，8 种基本类型<strong>除外</strong>的数据类型都是引用类型。</p><p>两种类型分别表示两种内存分配方式。一个<strong>值类型</strong>数据直接在<strong>栈</strong>上分配，存储所包含的值，其值就代表数据本身。一个<strong>引用类型</strong>指向的数据在<strong>堆</strong>上分配，引用类型的值是这个堆上数据的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num = 10;</span><br><span class="line">String str = &quot;hello&quot;;</span><br></pre></td></tr></table></figure><p>num 是基本类型（值类型），值就直接保存在变量中。<br>str 是引用类型，变量中保存的只是实际对象的地址（0x10），而不是 Hello 这个字符串。</p><hr><ul><li><p><strong>值传递、引用传递：</strong></p><ul><li><p>值传递（pass by value）：指在调用函数时，将实参复制一份传递到函数中，形参接收到的内容其实是实参的一个拷贝，函数对形参的修改并不会影响到实参</p></li><li><p>引用传递（pass by reference）：指在调用函数时，将实参的地址直接传递到函数中，在函数中对参数的修改将会影响到实参</p></li></ul></li></ul><p>值传递和引用传递属于函数调用时参数的<strong>求值策略</strong>（Evaluation Strategy），这是对调用函数时，求值和传值的方式的描述，并不指传递的内容的类型。</p><p>也就是说，<strong>传递内容的类型是值类型还是引用类型（地址），与值传递、引用传递无关，并不能说传入的参数类型是值类型就是值传递</strong>。</p><hr><p><strong>接下来重点！！！</strong></p><p><strong>对于值传递，无论是值类型还是引用类型，都会在调用栈上创建一个副本：</strong></p><ul><li><p><strong>对于值类型而言，这个副本就是整个原始值的复制，对这个副本的操作，不影响原始值的内容。</strong></p></li><li><p><strong>对于引用类型而言，其副本也只是这个引用的复制，指向的仍然是同一个对象。所以对副本的操作，会影响原始值。</strong></p></li></ul><p><img src="https://note.youdao.com/yws/public/resource/5b893506b6477fb678c8a98ca5888a85/4C4F78841E6241959282C73A0BD3CD08?ynotemdtimestamp=1550503530839" alt="upload successful"></p><p><a href="https://www.zhihu.com/question/20628016/answer/28970414" target="_blank" rel="noopener">为什么 Java 只有值传递，但 C# 既有值传递，又有引用传递，这种语言设计有哪些好处？ - Hugo Gu的回答 - 知乎</a></p><h3 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h3><p>定义 Person 类<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private int X = 123;</span><br><span class="line"></span><br><span class="line">    public void updateVlue(int value)&#123;  // 传入基本数据类型</span><br><span class="line">        value = value + 1;</span><br><span class="line">        System.out.println(&quot;变量value: &quot;+value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void updateObject(Person person)&#123; // 传入引用类型</span><br><span class="line">        Person E = person;</span><br><span class="line">        E.setAge(21);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void swapObject(Person A,Person B)&#123;  // 传入引用类型</span><br><span class="line">        Person C = A;</span><br><span class="line">        A = B;</span><br><span class="line">        B = C;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 例子 1</span><br><span class="line">        Main main = new Main();</span><br><span class="line">        int X = 1;</span><br><span class="line">        main.updateVlue(X);</span><br><span class="line">        System.out.println(&quot;X 的值：&quot;+X); // X = 1</span><br><span class="line">        </span><br><span class="line">        // 例子 2</span><br><span class="line">        Person A = new Person(&quot;张三&quot;,20);</span><br><span class="line">        main.updateObject(A);</span><br><span class="line">        System.out.println(&quot;A: &quot;+A.toString());  // A: Person&#123;name=&apos;张三&apos;, age=21&#125;</span><br><span class="line">        </span><br><span class="line">        // 例子 3</span><br><span class="line">        Person C = new Person(&quot;C&quot;,10);</span><br><span class="line">        Person D = new Person(&quot;D&quot;,15);</span><br><span class="line">        main.swapObject(C,D);</span><br><span class="line">        System.out.println(&quot;C: &quot;+ C.toString());  // C: Person&#123;name=&apos;C&apos;, age=10&#125;</span><br><span class="line">        System.out.println(&quot;D: &quot;+ D.toString());  // D: Person&#123;name=&apos;D&apos;, age=15&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子1：函数传入基本数据类型（值类型参数），由于 value 是 X 的一个副本，对 value 进行操作，并没有改变原来实参的值。</p><p>例子2：函数传入引用类型参数，改变了原来的值。由于<strong>值传递</strong>的缘故，传入引用类型的参数时，其值是这个地址的拷贝，指向的仍然是同一个对象，所以发生了改变。这是值传递带来的效果，与传入的对象是值类型或者引用类型没有关系！</p><p>例子3：函数传入引用类型，如果 Java 是引用传递， 那么 swapObject(Person A,Person B) 中的形参 A，B 接收的就是 C 和 D 的地址，对 A，B 进行交换应该能成功的，事实上 C 和 D 并没有交换，这从<strong>反面证明了 Java 不是引用传递。</strong></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.zhihu.com/question/31203609/answer/576030121" target="_blank" rel="noopener">Java 到底是值传递还是引用传递？ - Hollis的回答 - 知乎</a></p><p><a href="https://juejin.im/post/5bce68226fb9a05ce46a0476" target="_blank" rel="noopener">这一次，彻底解决Java的值传递和引用传递</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;几个重要概念&quot;&gt;&lt;a href=&quot;#几个重要概念&quot; class=&quot;headerlink&quot; title=&quot;几个重要概念&quot;&gt;&lt;/a&gt;几个重
      
    
    </summary>
    
      <category term="Java基础" scheme="http://suiyia.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis 简单介绍与 Jedis 常用操作</title>
    <link href="http://suiyia.github.io/2019/02/18/Redis%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8EJedis%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://suiyia.github.io/2019/02/18/Redis简单介绍与Jedis常用操作/</id>
    <published>2019-02-18T13:02:00.000Z</published>
    <updated>2019-08-10T09:51:13.097Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</p></blockquote><p>主要对 <a href="http://www.redis.cn/" target="_blank" rel="noopener">Redis 中文网</a> 文档内容进行总结，并使用 Jedis 实现一些基本操作。</p><h3 id="使用-Jedis-实现-Redis-基本操作"><a href="#使用-Jedis-实现-Redis-基本操作" class="headerlink" title="使用 Jedis 实现 Redis 基本操作"></a>使用 Jedis 实现 Redis 基本操作</h3><p><a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">Jedis</a> 是一个小而精的 Redis 客户端，用 Java 实现</p><ul><li><p>strings 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String result = jedis.set(<span class="string">"name"</span>,<span class="string">"chx"</span>); <span class="comment">// 添加 String ，result = "OK"</span></span><br><span class="line">result = jedis.mset(<span class="string">"name"</span>, <span class="string">"chenhaoxiang"</span>, <span class="string">"age"</span>, <span class="string">"20"</span>, <span class="string">"email"</span>, <span class="string">"chxpostbox@outlook.com"</span>); <span class="comment">// 同时设置多个键值对 result = "OK"</span></span><br><span class="line">Boolean exists = jedis.exists(<span class="string">"name"</span>); <span class="comment">// 是否存在 key=user 的记录</span></span><br><span class="line">result = jedis.get(<span class="string">"name"</span>); <span class="comment">// 获取数据，result = "chx"</span></span><br><span class="line">Long appendres = jedis.append(<span class="string">"name"</span>, <span class="string">" is my name;"</span>); <span class="comment">// 拼接，appendres = 15，拼接后字符串长度</span></span><br><span class="line">Long delres = jedis.del(<span class="string">"name"</span>);  <span class="comment">//删除某个键值对， delres = 1</span></span><br><span class="line"><span class="comment">//键对应 value 的自增操作，具备原子性，如果键包含错误类型的值或包含无法表示为整数的字符串，则会返回错误。此操作限于64位有符号整数。ERR value is not an integer or out of range</span></span><br><span class="line"><span class="comment">//如果键不存在，则在执行操作之前将其设置为0。如果 age 不存在，操作后 age = 1；</span></span><br><span class="line">Long incrres = jedis.incr(<span class="string">"age"</span>);  <span class="comment">// 用于将键的整数值递增1。 incrres = 21，递增后的值。</span></span><br></pre></td></tr></table></figure></li><li><p>lists 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Long res1 = jedis.lpush(<span class="string">"list"</span>,<span class="string">"1"</span>); <span class="comment">// 头部插入一个元素，res1 = 1</span></span><br><span class="line">res1 = jedis.lpush(<span class="string">"list"</span>,<span class="string">"2"</span>); <span class="comment">// res1 = 2</span></span><br><span class="line">res1 = jedis.lpush(<span class="string">"list"</span>,<span class="string">"3"</span>); <span class="comment">// res1 = 3 返回该 List 的长度</span></span><br><span class="line">jedis.rpush(<span class="string">"list"</span>,<span class="string">"5"</span>); <span class="comment">// 尾部插入元素</span></span><br><span class="line">Long llen = jedis.llen(<span class="string">"list"</span>); <span class="comment">// List 长度，llen = 4</span></span><br><span class="line">List&lt;String&gt; list3 = jedis.lrange(<span class="string">"list"</span>,<span class="number">0</span>,-<span class="number">1</span>); <span class="comment">// list3 = [3,2,1,5] 按范围取出,第一个是key，第二个是起始位置，第三个是结束位置</span></span><br></pre></td></tr></table></figure></li><li><p>sets 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">res1 = jedis.sadd(<span class="string">"set"</span>,<span class="string">"1"</span>);</span><br><span class="line">res1 = jedis.sadd(<span class="string">"set"</span>,<span class="string">"2"</span>);</span><br><span class="line">res1 = jedis.sadd(<span class="string">"set"</span>,<span class="string">"3"</span>); <span class="comment">// 添加</span></span><br><span class="line">Long srem = jedis.srem(<span class="string">"set"</span>,<span class="string">"2"</span>); <span class="comment">// 移除某个元素</span></span><br><span class="line">Set&lt;String&gt; set1 = jedis.smembers(<span class="string">"set"</span>); <span class="comment">// 获取 key=set 的 Set</span></span><br><span class="line">Boolean sismember = jedis.sismember(<span class="string">"set"</span>,<span class="string">"1"</span>); <span class="comment">// key=set 的 Set 中是否存在元素 "1"</span></span><br><span class="line">String srandmember = jedis.srandmember(<span class="string">"set"</span>); <span class="comment">// 随机返回一个 set 元素</span></span><br><span class="line">List&lt;String&gt; list4 = jedis.srandmember(<span class="string">"set"</span>,<span class="number">2</span>); <span class="comment">// 随机返回指定个数个元素</span></span><br><span class="line">Long scar = jedis.scard(<span class="string">"set"</span>); <span class="comment">// set 的元素个数</span></span><br></pre></td></tr></table></figure></li><li><p>sorted sets 操作( TODO 用到再更新)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jedis.zadd(<span class="string">"zset"</span>,<span class="number">1</span>,<span class="string">"1"</span>);</span><br><span class="line">jedis.zadd(<span class="string">"zset"</span>,<span class="number">2.0</span>,<span class="string">"2"</span>);</span><br><span class="line">jedis.zadd(<span class="string">"zset"</span>,<span class="number">3</span>,<span class="string">"3"</span>);</span><br></pre></td></tr></table></figure></li><li><p>Hashes 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"chx"</span>);</span><br><span class="line">map.put(<span class="string">"age"</span>, <span class="string">"100"</span>);</span><br><span class="line">map.put(<span class="string">"email"</span>, <span class="string">"***@outlook.com"</span>);</span><br><span class="line">result = jedis.hmset(<span class="string">"user"</span>, map); <span class="comment">// 添加 Map，result = "OK"</span></span><br><span class="line">String res = jedis.hget(<span class="string">"user"</span>,<span class="string">"age"</span>); <span class="comment">// 获取 Map 指定 key 的 value，只能获取单个 key，res = 100</span></span><br><span class="line">List&lt;String&gt; list = jedis.hmget(<span class="string">"user"</span>, <span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"email"</span>); <span class="comment">// 获取 Map 指定 key 的 value，同时指定多个 key，list = [chx, 100, ***@outlook.com];</span></span><br><span class="line">Long hdel = jedis.hdel(<span class="string">"user"</span>, <span class="string">"age"</span>); <span class="comment">//删除 map 中的某个键值，hdel = 1</span></span><br><span class="line">Long hlen = jedis.hlen(<span class="string">"user"</span>); <span class="comment">// 获取 map 中的键值对个数，hlen = 2</span></span><br><span class="line">Set&lt;String&gt; set = jedis.hkeys(<span class="string">"user"</span>); <span class="comment">// 返回 map 中的所有 key</span></span><br><span class="line">Iterator&lt;String&gt; iterator = jedis.hkeys(<span class="string">"user"</span>).iterator(); <span class="comment">// 迭代遍历</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    String key = iterator.next();</span><br><span class="line">    String value = jedis.hmget(<span class="string">"user"</span>,key).get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; list2 = jedis.hvals(<span class="string">"user"</span>); <span class="comment">// 返回 map 中的所有 value</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Redis-其它名词"><a href="#Redis-其它名词" class="headerlink" title="Redis 其它名词"></a>Redis 其它名词</h3><ul><li><strong>expire 过期</strong></li></ul><p>Redis 允许为每一个 key 设置不同的过期时间，当它们到期时将自动从服务器上删除。</p><p>主动删除：client 主动访问，发现过期，立即删除</p><p>被动删除：Redis <strong>定时随机</strong>选择一些 key 进行检测，删除过期的 key，如果删除比例高于 25%，则继续选择一些 key 进行删除</p><ul><li><strong>管道(Pipelining)</strong></li></ul><p>Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。<br>发送一个命令之后只有等待服务器返回之后才会执行后续命令。</p><p>管道则可以一次发送多条命令而不必立即等待服务器返回，收到命令之后，服务器会以队列形式回复命令，管道操作比较耗内存，要注意命令的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pipeline pipeline = jedis.pipelined();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    pipeline.set(<span class="string">"1"</span>,<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">pipeline.sync();</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/freebird_lb/article/details/7778919" target="_blank" rel="noopener">Redis学习笔记7–Redis管道（pipeline）</a></p><p><a href="https://blog.csdn.net/u011489043/article/details/78769428" target="_blank" rel="noopener">分布式缓存Redis之Pipeline（管道）</a></p><ul><li><strong>事务</strong></li></ul><p>将一组 Redis 命令放到事务中执行，MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String watch = jedis.watch(<span class="string">"123"</span>);</span><br><span class="line">Transaction multi = jedis.multi();</span><br><span class="line">multi.set(<span class="string">"123"</span>,<span class="string">"123"</span>);</span><br><span class="line">List&lt;Object&gt; list1 = multi.exec();</span><br><span class="line">multi.discard();</span><br><span class="line">jedis.unwatch();</span><br></pre></td></tr></table></figure><p>multi 用于开启一个事务，exec 执行事务，watch 用于监测事务中 key 的变化，如果 key 被其它客户端改过了，那么整个事务会被取消，discard 用于取消事务</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个总结主要是了解下 Jedis 常用操作。具体细节学习需要文档、项目结合学习。</p><p>博客参考：<br><a href="https://blog.csdn.net/qq_26525215/article/details/60466222" target="_blank" rel="noopener">【Redis】Java中使用Jedis操作Redis(Maven导入包)、创建Redis连接池</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="Redis" scheme="http://suiyia.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://suiyia.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java 常用加密算法实现</title>
    <link href="http://suiyia.github.io/2019/01/27/Java-%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://suiyia.github.io/2019/01/27/Java-常用加密算法实现/</id>
    <published>2019-01-27T09:23:00.000Z</published>
    <updated>2019-08-10T02:01:15.013Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --><p>[toc]</p><blockquote><p>常用加密算法 Java 实现</p></blockquote><h3 id="算法种类"><a href="#算法种类" class="headerlink" title="算法种类"></a>算法种类</h3><ul><li>单向加密</li><li>对称加密</li><li>非对称加密</li></ul><h3 id="1-单向加密"><a href="#1-单向加密" class="headerlink" title="1. 单向加密"></a>1. 单向加密</h3><p><strong>Base64</strong>，Base64 编码是从二进制到字符的过程，用 64 个字符来表示任意的二进制数据，常用于在 HTTP 加密，图片编码传输等。</p><ul><li>Java 8 内置实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cn.singleway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base64Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 编码</span></span><br><span class="line">            String encode = Base64.getEncoder().encodeToString(<span class="string">"testBase64"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println(encode);</span><br><span class="line">            <span class="comment">// 解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] decode = Base64.getDecoder().decode(<span class="string">"dGVzdEJhc2U2NA=="</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(decode, <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>JDK 1.8 之下，引入第三方 jar 包</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cn.singleway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base64Demo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String encodeBase64String = Base64.encodeBase64String(<span class="string">"test"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println(encodeBase64String);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] decodeString = Base64.decodeBase64(encodeBase64String);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(decodeString,<span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.11&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>MD5</strong>，Message Digest algorithm 5，信息摘要算法，一般用于确保信息的传输完整一致性，校验传输的数据是否被修改，一旦原始信息被修改，生成的 MD5 值将会变得很不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cn.singleway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MessageDigest messageDigest = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] after = messageDigest.digest(s.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; after.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="number">0xff</span> &amp; after[i]) &lt; <span class="number">0x10</span>) &#123;</span><br><span class="line">                    stringBuilder.append(<span class="string">"0"</span> + Integer.toHexString((<span class="number">0xFF</span> &amp; after[i])));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stringBuilder.append(Integer.toHexString(<span class="number">0xFF</span> &amp; after[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(stringBuilder.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 生成一个MD5加密计算摘要</span></span><br><span class="line">            MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            <span class="comment">// 计算md5函数</span></span><br><span class="line">            md.update(s.getBytes());</span><br><span class="line">            <span class="comment">// digest()最后确定返回md5 hash值，返回值为8为字符串。因为md5 hash值是16位的hex值，实际上就是8位的字符</span></span><br><span class="line">            <span class="comment">// BigInteger函数则将8位的字符串转换成16位hex值，用字符串来表示；得到字符串形式的hash值</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, md.digest()).toString(<span class="number">16</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"this is MD5 test demo"</span>;</span><br><span class="line">        test1(s);</span><br><span class="line">        test2(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SHA 家族，是一个密码散列函数家族，是 FIPS 所认证的安全散列算法，和 MD5 类似，都是对文本进行散列，产生一定长度的散列值<br>SHA1 与 SHA2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>HMAC<br>Hash Message Authentication Code，散列消息鉴别码，HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="2-对称加密"><a href="#2-对称加密" class="headerlink" title="2. 对称加密"></a>2. 对称加密</h3><p><strong>对称加密的意思就是信息收发都有相同的一把钥匙，消息的加密解密都用这进行</strong></p><ul><li><p>DES，Data Encryption Standard，数据加密标准，速度较快，适用于加密大量数据的场合。DES算法提供CBC, OFB, CFB, ECB四种模式，MAC是基于ECB实现的。</p></li><li><p>AES</p></li><li>Advanced Encryption Standard，高级加密标准，是下一代的加密算法标准，速度快，安全级别高；</li></ul><hr><h3 id="3-非对称加密"><a href="#3-非对称加密" class="headerlink" title="3. 非对称加密"></a>3. 非对称加密</h3><p><strong>非对称加密算法是一种密钥的保密方法。 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。</strong></p><ul><li>RSA，名称来源于发明这个算法的三个人的姓氏组成，算法大致内容就是对极大整数进行因式分解。这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长 RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。</li></ul><p><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></p><ul><li><p>DSA，Digital Signature Algorithm，数字签名算法，是一种标准的 DSS（数字签名标准）；</p></li><li><p>ECC，Elliptic Curves Cryptography，椭圆曲线密码编码学。一种建立公开密钥加密的算法，基于椭圆曲线数学。ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。ECC的另一个优势是可以定义群之间的双线性映射，基于Weil对或是Tate对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。不过一个缺点是加密和解密操作的实现比其他机制花费的时间长。</p></li></ul><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><h2 id="MD5-和-SHA-家族"><a href="#MD5-和-SHA-家族" class="headerlink" title="MD5 和 SHA 家族"></a>MD5 和 SHA 家族</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    String content = <span class="string">"you are my son"</span>; <span class="comment">// 原文</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] a;</span><br><span class="line">        MessageDigest messageDigest = MessageDigest.getInstance(<span class="string">"SHA-1"</span>);</span><br><span class="line">        a = messageDigest.digest(content.getBytes());</span><br><span class="line">        System.out.println(byte2hex(a)); <span class="comment">// 333a9634d8809b5a9e8d280d82553b8fd8d4a911</span></span><br><span class="line"></span><br><span class="line">        messageDigest = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);</span><br><span class="line">        a = messageDigest.digest(content.getBytes());</span><br><span class="line">        System.out.println(byte2hex(a)); <span class="comment">// cdb2c97079d9a1943eea98de4201f5c4f49ecda5af2b364e1c7a5d1ae89688eb</span></span><br><span class="line"></span><br><span class="line">        messageDigest = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        a = messageDigest.digest(content.getBytes());</span><br><span class="line">        System.out.println(byte2hex(a)); <span class="comment">// 6fe6b9a8f8bd29f4f4f1368a0619a7ae</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三方 MD5 算法。需要添加 jar 包 org.apache.commons.codec.digest.DigestUtils</span></span><br><span class="line">        String encodeStr=DigestUtils.md5Hex(content);</span><br><span class="line">        System.out.println(encodeStr); <span class="comment">// 6fe6b9a8f8bd29f4f4f1368a0619a7ae</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">byte2hex</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="comment">//二进制转字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String hs = <span class="string">""</span>;</span><br><span class="line">    String stmp = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; b.length; n++) &#123;</span><br><span class="line">        stmp = (java.lang.Integer.toHexString(b[n] &amp; <span class="number">0XFF</span>));</span><br><span class="line">        <span class="keyword">if</span> (stmp.length() == <span class="number">1</span>) &#123;</span><br><span class="line">            hs = hs + <span class="string">"0"</span> + stmp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hs = hs + stmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>现在的加密算法大部分情况下是为了验证数据的一致性，例如传递一些参数组的时候，简单的会使用 BASE64 或 MD5 进行加密生成一个签名。复杂点就是 BASE64 编码之后再用 对称密钥再加密一次，达到比较不容易被人篡改的目的</p></li><li><p>对于一些支付场景，一般使用 非对称加密算法 实现，这样的场景需要的安全性更高。</p></li><li><p>其它博客参考</p><ul><li><a href="https://blog.csdn.net/qq_18870023/article/details/52596808" target="_blank" rel="noopener">java加解密之RSA使用</a></li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;[toc]&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;常用加密算法 Java 实现&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;算法种类&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Java 核心" scheme="http://suiyia.github.io/categories/Java-%E6%A0%B8%E5%BF%83/"/>
    
    
      <category term="加密算法" scheme="http://suiyia.github.io/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>展望 2019 ！</title>
    <link href="http://suiyia.github.io/2019/01/02/%E5%B1%95%E6%9C%9B-2019/"/>
    <id>http://suiyia.github.io/2019/01/02/展望-2019/</id>
    <published>2019-01-02T14:28:00.000Z</published>
    <updated>2019-04-07T13:32:54.458Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --><p><a href="https://mp.weixin.qq.com/s/fZ0MWLYRQOfMBpVDHwq21g" target="_blank" rel="noopener">回首 2018</a>，毕业、入职，名校光环不再，浪潮褪去，原来我一直在裸泳。</p><p>作为已经工作半年的「职场新人」，仍有许多的不足和需要学习的地方。激情是年轻人应该拥有的东西，没有梦想，和咸鱼一样，我不甘心！</p><p>制定好目标，坚持的执行下去，总会有好的结果。</p><ol><li><p>坚持看书，每天花一个小时看书。自己思考、总结，把书中的想法总结出来，提升了思维也锻炼了写作能力。</p></li><li><p>坚持写博客，从公司项目中了解框架，既熟悉了业务，也运用得了框架，这应该是头两年需要技术积累的东西。</p></li><li><p>坚持锻炼，体重控制在 130 斤应该是最完美的体重，向这个目标进军，现在 140 斤。</p></li></ol><p>自己需要注意的地方：</p><ol><li><p>聆听的方式。别人与自己说话，学会聆听，学会体会别人话中表现的含义，不轻易打断别人，有时候还需要委婉地表达自己的想法。</p></li><li><p>注意社交，一个人闷着屋里，并不会造出什么轮子，随时了解外面发生的事，多个周围的同事交流，结交更多的朋友，体会不同人的想法、见解，开拓自己的视野。</p></li></ol><p>唯一愿望：</p><p>找一个可以一起吃饭、一起看电影、一起出去玩的女朋友。</p><p>结语：</p><p>人生就像一场马拉松，起步快的人，往往能提前看到美丽的风景，坚持久的人，必将得到丰厚的硕果，加油 2019 ！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 19 2019 18:11:29 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fZ0MWLYRQOfMBpVDHwq21g&quot; target=&quot;_bla
      
    
    </summary>
    
    
  </entry>
  
</feed>
