<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸟日常</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suiyia.github.io/"/>
  <updated>2019-04-07T13:38:48.975Z</updated>
  <id>http://suiyia.github.io/</id>
  
  <author>
    <name>suiyia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap、HashTable、ConcurrentHashMap 区别</title>
    <link href="http://suiyia.github.io/2019/04/07/HashMap%E3%80%81HashTable%E3%80%81ConcurrentHashMap-%E5%8C%BA%E5%88%AB/"/>
    <id>http://suiyia.github.io/2019/04/07/HashMap、HashTable、ConcurrentHashMap-区别/</id>
    <published>2019-04-07T06:24:00.000Z</published>
    <updated>2019-04-07T13:38:48.975Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单总结 HashMap、Hashtable、ConcurrentHashMap 之间的区别，基于 JDK 1.8.0_191</p></blockquote><p>先说结论，暂时有以下几个需要注意的不同点：</p><ol><li>继承、实现接口不同</li><li>初始大小、扩容倍数不同</li><li>线程安全</li><li>NULL KEY，NULL VALUE 支持不同</li><li>计算 Hash 值的方式不同</li></ol><h3 id="1-继承、实现接口不同"><a href="#1-继承、实现接口不同" class="headerlink" title="1. 继承、实现接口不同"></a>1. 继承、实现接口不同</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125;</span><br><span class="line">    </span><br><span class="line">public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;    </span><br><span class="line"></span><br><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable &#123;</span><br></pre></td></tr></table></figure><ul><li>HashMap、ConcurrentHashMap 都继承于 AbstractMap 抽象类，但 Hashtable 继承于 Dictionary 抽象类。</li><li>AbstractMap 实现了 Map 接口，而 Dictionary 没有。这使得 AbstractMap 具有更多的功能，而 Dictionary 逐渐被弃用。</li></ul><h3 id="2-初始大小、扩容倍数不同"><a href="#2-初始大小、扩容倍数不同" class="headerlink" title="2. 初始大小、扩容倍数不同"></a>2. 初始大小、扩容倍数不同</h3><p>HashMap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">扩容部分代码：</span><br><span class="line">newThr = oldThr &lt;&lt; 1; // double threshold</span><br></pre></td></tr></table></figure></p><p>Hashtable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Hashtable() &#123;</span><br><span class="line">    this(11, 0.75f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">扩容部分代码：</span><br><span class="line">int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</span><br></pre></td></tr></table></figure></p><p>ConcurrentHashMap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The default initial table capacity.  Must be a power of 2</span><br><span class="line"> * (i.e., at least 1) and at most MAXIMUM_CAPACITY.</span><br><span class="line"> */</span><br><span class="line">private static final int DEFAULT_CAPACITY = 16;</span><br></pre></td></tr></table></figure></p><ul><li>初始大小：HashMap、ConcurrentHashMap 都是 16，Hashtable 是 11</li><li>扩容倍数：HashMap、ConcurrentHashMap 2 倍、Hashtable (2n + 1) 倍。</li></ul><h3 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3. 线程安全"></a>3. 线程安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable:</span><br><span class="line">public synchronized V put(K key, V value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">HashMap:</span><br><span class="line">public V put(K key, V value) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>Hashtable 添加元素方法加上了 synchronized 关键字，HashMap 没有，说明 HashMap 不适用于多线程环境。</li><li>ConcurrentHashMap 添加元素时，只对需要变更的地方加锁。</li></ul><h3 id="4-NULL-KEY，NULL-VALUE-支持不同"><a href="#4-NULL-KEY，NULL-VALUE-支持不同" class="headerlink" title="4. NULL KEY，NULL VALUE 支持不同"></a>4. NULL KEY，NULL VALUE 支持不同</h3><p>通过观察它们的 put 方法，得到以下结论： </p><ul><li>Hashtable、ConcurrentHashMap 的 key、value 都不能为 null。</li><li>HashMap value 可以为 null，而 key 为 null 时，该元素会放在 HashMap 第一位。</li></ul><h3 id="5-key-的索引计算方法不同"><a href="#5-key-的索引计算方法不同" class="headerlink" title="5. key 的索引计算方法不同"></a>5. key 的索引计算方法不同</h3><p>计算元素存放位置，会经过两步转化。Object -&gt; int -&gt; index，先将 key 使用 hash 方法转换为一个整数数字，然后对整型数字进行转化，得到这个对象在 map 中的索引。</p><p>Hashtable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int hash = key.hashCode();</span><br><span class="line">int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br></pre></td></tr></table></figure></p><p>HashMap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>Hashtable 直接使用对象的 hashCode，然后再使用除留余数法来获得最终的位置。</li><li>HashMap 在对象的 hashCode 之上，将 hashCode 的高16位和低16位进行异或，得到最终的位置。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>后面学习将对 HashMap，ConcurrentHashMap 源码进行分析总结。</p><p><a href="https://blog.csdn.net/varyall/article/details/81277296" target="_blank" rel="noopener">ConcurrentHashMap的扩容机制（jdk1.8）</a></p><p><a href="http://www.10tiao.com/html/710/201903/2650123468/2.html" target="_blank" rel="noopener">HashMap 和Hashtable的区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;简单总结 HashMap、Hashtable、ConcurrentHashMap 之间的区别，基于 JDK 1.8.0_191&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先说结论，暂时有以下几个需要注意的不同点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承、实
      
    
    </summary>
    
      <category term="Java基础" scheme="http://suiyia.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="集合" scheme="http://suiyia.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>ArraryList、LinkList和Vector的区别</title>
    <link href="http://suiyia.github.io/2019/03/24/ArraryList%E3%80%81LinkList%E5%92%8CVector%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://suiyia.github.io/2019/03/24/ArraryList、LinkList和Vector的区别/</id>
    <published>2019-03-24T05:53:00.000Z</published>
    <updated>2019-04-07T13:32:54.477Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于 JDK 1.8.0_191</p></blockquote><h3 id="1-源码对比"><a href="#1-源码对比" class="headerlink" title="1. 源码对比"></a>1. 源码对比</h3><ul><li>实现接口类对比</li><li>扩容机制对比</li><li>线程安全</li></ul><h4 id="1-1-实现接口类对比"><a href="#1-1-实现接口类对比" class="headerlink" title="1.1 实现接口类对比"></a>1.1 实现接口类对比</h4><p><img src="https://raw.githubusercontent.com/suiyia/images/master/20190324112747.jpeg?token=ALIF2JNoBZxx5ZeHPivS9QGmNve5iPdbks5clvlwwA%3D%3D" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">        </span><br><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable    </span><br><span class="line">    </span><br><span class="line">public class Vector&lt;E&gt;</span><br><span class="line">    extends AbstractList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure></p><ul><li><p>它们都实现 List 接口，说明具备列表的增加、删除、遍历元素等特性。</p></li><li><p>ArrayList、Vector 额外实现 RandomAccess 接口，说明他们能在常量时间复杂度内快速随机访问元素。</p></li><li><p>LinkedList 额外实现 Queue 接口，具备队列的入队、出队等特性。</p></li></ul><h4 id="1-2-扩容机制对比"><a href="#1-2-扩容机制对比" class="headerlink" title="1.2 扩容机制对比"></a>1.2 扩容机制对比</h4><p>ArrayList<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_CAPACITY = 10;  // 定义初始大小</span><br><span class="line"></span><br><span class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;  // 定义列表存储元素数量最大值 </span><br><span class="line"></span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;   // 现有元素数量 </span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);  // 增加后元素的数量 = 1 + 0.5 </span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)    // 增加后的元素数量 &lt; 现有的空间，不扩容</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);  // 增加后的元素数量 &gt; 大于最大值，尝试分配 Integer.MAX_VALUE 个元素，可能会抛出 OutOfMemoryError  </span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Vector<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Vector() &#123;</span><br><span class="line">    this(10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected int capacityIncrement;  // 扩容数量值，Vector 初始化不指定时默认为 0</span><br><span class="line"></span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); // 当扩容数量值小于 0，那么扩容比例为原来的两倍；否则扩容的数量为这个值。</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>LinkList<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient int size = 0;</span><br></pre></td></tr></table></figure></p><ul><li>初始大小：ArrayList、Vector 默认为 10，LinkList 不指定默认为 0</li><li>扩容比例：ArrayList 以 1.5 倍进行扩容；Vector 不指定扩容比例时默认为 2 倍进行扩容</li></ul><h4 id="1-3-线程安全性"><a href="#1-3-线程安全性" class="headerlink" title="1.3 线程安全性"></a>1.3 线程安全性</h4><p>ArrayList<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected transient int modCount = 0;</span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Vector<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected transient int modCount = 0;</span><br><span class="line"></span><br><span class="line">public synchronized void addElement(E obj) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + 1);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Vector add() 方法上增加了 synchronized 关键字，使得 Vector 支持多线程环境下的元素增加删除修改操作。</p><h3 id="2-增删改性能对比"><a href="#2-增删改性能对比" class="headerlink" title="2. 增删改性能对比"></a>2. 增删改性能对比</h3><p>根据数据结构中知识:</p><p>顺序表查找元素时间复杂度为 O(1)，适用于随机查找元素的场景。</p><p>链表增减元素时间复杂度为 O(1)，适用于增减元素比较多的场景。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList arrayList = new ArrayList();</span><br><span class="line">    LinkedList linkedList = new LinkedList();</span><br><span class="line">    Vector vector = new Vector();</span><br><span class="line">    long t1, t2;</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        arrayList.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;ArrayList add:&quot; + (t2 - t1));</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        linkedList.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;linkedList add:&quot; + (t2 - t1));</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        vector.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;vector add:&quot; + (t2 - t1));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">ArrayList add:6810212</span><br><span class="line">linkedList add:3463194</span><br><span class="line">vector add:4442985</span><br></pre></td></tr></table></figure><p>添加元素，ArrayList 花费时间比 LinkList 时间长。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList arrayList = new ArrayList();</span><br><span class="line">    LinkedList linkedList = new LinkedList();</span><br><span class="line">    Vector vector = new Vector();</span><br><span class="line">    long t1, t2;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">        arrayList.add(i);</span><br><span class="line">        linkedList.add(i);</span><br><span class="line">        vector.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        arrayList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;ArrayList get:&quot; + (t2 - t1));</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        linkedList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;linkedList get:&quot; + (t2 - t1));</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        vector.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;vector get:&quot; + (t2 - t1));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">ArrayList get:72482</span><br><span class="line">linkedList get:107975370</span><br><span class="line">vector get:242634</span><br></pre></td></tr></table></figure></p><p>查找元素上，ArrayList 最快</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>将 ArrayList、LinkList 和 Vetor 进行了简单对比，总体来说：</p><ul><li>在查找元素比较频繁的场合，推荐使用 ArrayList；在修改元素比较频繁的场合，推荐使用 LinkList。</li><li>Vetor 与 ArrayList 类似，区别在于扩容比例、线程安全方面。</li><li>性能对比测试结果可能存在添加元素 ArrayList 花费时间比 LinkList 多的情况， 这个原因</li></ul><p>参考：</p><p><a href="https://www.hollischuang.com/archives/1349" target="_blank" rel="noopener">ArrayList vs LinkedList vs Vector 区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文基于 JDK 1.8.0_191&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-源码对比&quot;&gt;&lt;a href=&quot;#1-源码对比&quot; class=&quot;headerlink&quot; title=&quot;1. 源码对比&quot;&gt;&lt;/a&gt;1. 源码对比&lt;/h3&gt;&lt;u
      
    
    </summary>
    
      <category term="Java基础" scheme="http://suiyia.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="集合" scheme="http://suiyia.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java字符串拼接效率对比</title>
    <link href="http://suiyia.github.io/2019/03/17/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94/"/>
    <id>http://suiyia.github.io/2019/03/17/Java-字符串拼接效率对比/</id>
    <published>2019-03-17T07:30:00.000Z</published>
    <updated>2019-04-07T13:32:54.526Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://note.youdao.com/yws/public/resource/27422d1c5ab3fa95a4e668c46ec74791/E06E2A8F7F51469DAFA40E6A9D43EA2B?ynotemdtimestamp=1552808544738" alt="image"><br>用 Google photo 搜索关键词「String」，出现了上图，有兴趣的朋友可以试试，感觉发现了新大陆…</p><p>Java 中有 3 种字符串的拼接方式，了解这三种拼接方式的实现，将有益于提高自己的代码质量。</p><p>本文主要讲解 String 对象的三种拼接方式，以及它们之间的效率对比。</p><h3 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 方式 1</span><br><span class="line">String s = &quot;Hello&quot;;</span><br><span class="line">s += &quot;Hello&quot;;</span><br><span class="line"></span><br><span class="line">// 方式 2</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder(&quot;Hello&quot;);</span><br><span class="line">stringBuilder.append(&quot;Hello&quot;);</span><br><span class="line"></span><br><span class="line">// 方式 3</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer(&quot;Hello&quot;);</span><br><span class="line">stringBuffer.append(&quot;Hello&quot;);</span><br></pre></td></tr></table></figure><p>自己写个主函数，将上面 3 个方法循环执行 10000 次；</p><p><strong>执行时间</strong> t1 &gt; t3 &gt; t2，也就是说 StringBuilder.append() 拼接最快，String += 最慢。</p><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><ul><li>StringBuilder.append() 拼接</li></ul><p>StringBuilder.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class StringBuilder</span><br><span class="line">    extends AbstractStringBuilder</span><br><span class="line">    implements java.io.Serializable, CharSequence</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);  // 调用父类 append 方法</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AbstractStringBuilder.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public AbstractStringBuilder append(String str) &#123;</span><br><span class="line">    if (str == null)</span><br><span class="line">        return appendNull();</span><br><span class="line">    int len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(0, len, value, count);  // 调用 String 的 getChars 方法</span><br><span class="line">    count += len;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>String.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123;</span><br><span class="line">    if (srcBegin &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    if (srcEnd &gt; value.length) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    if (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);  // 本地方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>从上面 3 段代码可知，StringBuilder.append 方法调用的是父类 AbstractStringBuilder.append，父类 append 方法调用了 String 的本地方法 System.arraycopy 实现</strong></p><ul><li>StringBuffer.append() 拼接</li></ul><p>StringBuilder.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class StringBuffer</span><br><span class="line">    extends AbstractStringBuilder</span><br><span class="line">    implements java.io.Serializable, CharSequence</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public synchronized StringBuffer append(String str) &#123;</span><br><span class="line">    toStringCache = null;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>StringBuffer.append 方法与 StringBuilder.append 方法类似，不同的是，append 方法加上了 synchronized 锁，说明该方法适用于多线程环境，但是加锁的过程需要耗时，所以执行时间比 StringBuilder.append 慢。</strong></p><ul><li>String += 拼接</li></ul><p>对下面代码进行编译，生成的 class 文件使用命令 javap -c Main.class，可以反编译得到图片中的字节码。</p><p>可以看到 += 实际调用的是 StringBuilder.append() 方法，所以速度会比 StringBuilder 慢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s = &quot;Hello&quot;;</span><br><span class="line">    s = s + &quot; World&quot;;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://note.youdao.com/yws/public/resource/27422d1c5ab3fa95a4e668c46ec74791/06E6477B2E6F4209B3DA88D5BF43E5F8?ynotemdtimestamp=1552808544738" alt="image"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以在需要拼接字符串的场合，尽量适用 StringBuilder.append() 方法，多线程环境下则推荐 StringBuffer.append() 方法，而 String += 拼接方式任何场合都不建议使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/27422d1c5ab3fa95a4e668c46ec74791/E06E2A8F7F51469DAFA40E6A9D43EA2B?ynotemdtimestamp=
      
    
    </summary>
    
      <category term="Java基础" scheme="http://suiyia.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="String" scheme="http://suiyia.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Java中的值传递</title>
    <link href="http://suiyia.github.io/2019/02/18/Java-%E4%B8%AD%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <id>http://suiyia.github.io/2019/02/18/Java-中的值传递/</id>
    <published>2019-02-18T15:12:00.000Z</published>
    <updated>2019-04-07T13:32:54.490Z</updated>
    
    <content type="html"><![CDATA[<h3 id="几个重要概念"><a href="#几个重要概念" class="headerlink" title="几个重要概念"></a>几个重要概念</h3><ul><li><p><strong>实参、形参</strong></p><ul><li><p>形式参数：定义函数名和函数体时候使用的参数，目的用来<strong>接收</strong>调用该函数时<strong>传入的参数</strong></p></li><li><p>实际参数：在调用有参函数时，主调函数与被调函数之间有数据传递关系。实际参数是<strong>调用有参方法的时候真正传递的内容</strong>。</p></li></ul></li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public void tes(String name)&#123; // 形式参数 name</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Test test = new Test();</span><br><span class="line">    test.tes(&quot;caijicoder&quot;); // 实际参数 caijicoder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><strong>值类型、引用类型：</strong></li></ul><p>值类型就是<strong>基本数据类型</strong>，8 种基本类型<strong>除外</strong>的数据类型都是引用类型。</p><p>两种类型分别表示两种内存分配方式。一个<strong>值类型</strong>数据直接在<strong>栈</strong>上分配，存储所包含的值，其值就代表数据本身。一个<strong>引用类型</strong>指向的数据在<strong>堆</strong>上分配，引用类型的值是这个堆上数据的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num = 10;</span><br><span class="line">String str = &quot;hello&quot;;</span><br></pre></td></tr></table></figure><p>num 是基本类型（值类型），值就直接保存在变量中。<br>str 是引用类型，变量中保存的只是实际对象的地址（0x10），而不是 Hello 这个字符串。</p><hr><ul><li><p><strong>值传递、引用传递：</strong></p><ul><li><p>值传递（pass by value）：指在调用函数时，将实参复制一份传递到函数中，形参接收到的内容其实是实参的一个拷贝，函数对形参的修改并不会影响到实参</p></li><li><p>引用传递（pass by reference）：指在调用函数时，将实参的地址直接传递到函数中，在函数中对参数的修改将会影响到实参</p></li></ul></li></ul><p>值传递和引用传递属于函数调用时参数的<strong>求值策略</strong>（Evaluation Strategy），这是对调用函数时，求值和传值的方式的描述，并不指传递的内容的类型。</p><p>也就是说，<strong>传递内容的类型是值类型还是引用类型（地址），与值传递、引用传递无关，并不能说传入的参数类型是值类型就是值传递</strong>。</p><hr><p><strong>接下来重点！！！</strong></p><p><strong>对于值传递，无论是值类型还是引用类型，都会在调用栈上创建一个副本：</strong></p><ul><li><p><strong>对于值类型而言，这个副本就是整个原始值的复制，对这个副本的操作，不影响原始值的内容。</strong></p></li><li><p><strong>对于引用类型而言，其副本也只是这个引用的复制，指向的仍然是同一个对象。所以对副本的操作，会影响原始值。</strong></p></li></ul><p><img src="https://note.youdao.com/yws/public/resource/5b893506b6477fb678c8a98ca5888a85/4C4F78841E6241959282C73A0BD3CD08?ynotemdtimestamp=1550503530839" alt="upload successful"></p><p><a href="https://www.zhihu.com/question/20628016/answer/28970414" target="_blank" rel="noopener">为什么 Java 只有值传递，但 C# 既有值传递，又有引用传递，这种语言设计有哪些好处？ - Hugo Gu的回答 - 知乎</a></p><h3 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h3><p>定义 Person 类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private int X = 123;</span><br><span class="line"></span><br><span class="line">    public void updateVlue(int value)&#123;  // 传入基本数据类型</span><br><span class="line">        value = value + 1;</span><br><span class="line">        System.out.println(&quot;变量value: &quot;+value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void updateObject(Person person)&#123; // 传入引用类型</span><br><span class="line">        Person E = person;</span><br><span class="line">        E.setAge(21);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void swapObject(Person A,Person B)&#123;  // 传入引用类型</span><br><span class="line">        Person C = A;</span><br><span class="line">        A = B;</span><br><span class="line">        B = C;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 例子 1</span><br><span class="line">        Main main = new Main();</span><br><span class="line">        int X = 1;</span><br><span class="line">        main.updateVlue(X);</span><br><span class="line">        System.out.println(&quot;X 的值：&quot;+X); // X = 1</span><br><span class="line">        </span><br><span class="line">        // 例子 2</span><br><span class="line">        Person A = new Person(&quot;张三&quot;,20);</span><br><span class="line">        main.updateObject(A);</span><br><span class="line">        System.out.println(&quot;A: &quot;+A.toString());  // A: Person&#123;name=&apos;张三&apos;, age=21&#125;</span><br><span class="line">        </span><br><span class="line">        // 例子 3</span><br><span class="line">        Person C = new Person(&quot;C&quot;,10);</span><br><span class="line">        Person D = new Person(&quot;D&quot;,15);</span><br><span class="line">        main.swapObject(C,D);</span><br><span class="line">        System.out.println(&quot;C: &quot;+ C.toString());  // C: Person&#123;name=&apos;C&apos;, age=10&#125;</span><br><span class="line">        System.out.println(&quot;D: &quot;+ D.toString());  // D: Person&#123;name=&apos;D&apos;, age=15&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子1：函数传入基本数据类型（值类型参数），由于 value 是 X 的一个副本，对 value 进行操作，并没有改变原来实参的值。</p><p>例子2：函数传入引用类型参数，改变了原来的值。由于<strong>值传递</strong>的缘故，传入引用类型的参数时，其值是这个地址的拷贝，指向的仍然是同一个对象，所以发生了改变。这是值传递带来的效果，与传入的对象是值类型或者引用类型没有关系！</p><p>例子3：函数传入引用类型，如果 Java 是引用传递， 那么 swapObject(Person A,Person B) 中的形参 A，B 接收的就是 C 和 D 的地址，对 A，B 进行交换应该能成功的，事实上 C 和 D 并没有交换，这从<strong>反面证明了 Java 不是引用传递。</strong></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.zhihu.com/question/31203609/answer/576030121" target="_blank" rel="noopener">Java 到底是值传递还是引用传递？ - Hollis的回答 - 知乎</a></p><p><a href="https://juejin.im/post/5bce68226fb9a05ce46a0476" target="_blank" rel="noopener">这一次，彻底解决Java的值传递和引用传递</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;几个重要概念&quot;&gt;&lt;a href=&quot;#几个重要概念&quot; class=&quot;headerlink&quot; title=&quot;几个重要概念&quot;&gt;&lt;/a&gt;几个重要概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;实参、形参&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;形式参数：定
      
    
    </summary>
    
      <category term="Java基础" scheme="http://suiyia.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis 简单介绍与 Jedis 常用操作</title>
    <link href="http://suiyia.github.io/2019/02/18/Redis%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8EJedis%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://suiyia.github.io/2019/02/18/Redis简单介绍与Jedis常用操作/</id>
    <published>2019-02-18T13:02:00.000Z</published>
    <updated>2019-04-07T13:32:54.504Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 </p></blockquote><p>主要对 <a href="http://www.redis.cn/" target="_blank" rel="noopener">Redis 中文网</a> 文档内容进行总结，并使用 Jedis 实现一些基本操作。</p><h3 id="使用-Jedis-实现-Redis-基本操作"><a href="#使用-Jedis-实现-Redis-基本操作" class="headerlink" title="使用 Jedis 实现 Redis 基本操作"></a>使用 Jedis 实现 Redis 基本操作</h3><p><a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">Jedis</a> 是一个小而精的 Redis 客户端，用 Java 实现</p><ul><li><p>strings 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String result = jedis.set(<span class="string">"name"</span>,<span class="string">"chx"</span>); <span class="comment">// 添加 String ，result = "OK"</span></span><br><span class="line">result = jedis.mset(<span class="string">"name"</span>, <span class="string">"chenhaoxiang"</span>, <span class="string">"age"</span>, <span class="string">"20"</span>, <span class="string">"email"</span>, <span class="string">"chxpostbox@outlook.com"</span>); <span class="comment">// 同时设置多个键值对 result = "OK"</span></span><br><span class="line">Boolean exists = jedis.exists(<span class="string">"name"</span>); <span class="comment">// 是否存在 key=user 的记录</span></span><br><span class="line">result = jedis.get(<span class="string">"name"</span>); <span class="comment">// 获取数据，result = "chx"</span></span><br><span class="line">Long appendres = jedis.append(<span class="string">"name"</span>, <span class="string">" is my name;"</span>); <span class="comment">// 拼接，appendres = 15，拼接后字符串长度</span></span><br><span class="line">Long delres = jedis.del(<span class="string">"name"</span>);  <span class="comment">//删除某个键值对， delres = 1</span></span><br><span class="line"><span class="comment">//键对应 value 的自增操作，具备原子性，如果键包含错误类型的值或包含无法表示为整数的字符串，则会返回错误。此操作限于64位有符号整数。ERR value is not an integer or out of range</span></span><br><span class="line"><span class="comment">//如果键不存在，则在执行操作之前将其设置为0。如果 age 不存在，操作后 age = 1；</span></span><br><span class="line">Long incrres = jedis.incr(<span class="string">"age"</span>);  <span class="comment">// 用于将键的整数值递增1。 incrres = 21，递增后的值。</span></span><br></pre></td></tr></table></figure></li><li><p>lists 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Long res1 = jedis.lpush(<span class="string">"list"</span>,<span class="string">"1"</span>); <span class="comment">// 头部插入一个元素，res1 = 1</span></span><br><span class="line">res1 = jedis.lpush(<span class="string">"list"</span>,<span class="string">"2"</span>); <span class="comment">// res1 = 2</span></span><br><span class="line">res1 = jedis.lpush(<span class="string">"list"</span>,<span class="string">"3"</span>); <span class="comment">// res1 = 3 返回该 List 的长度</span></span><br><span class="line">jedis.rpush(<span class="string">"list"</span>,<span class="string">"5"</span>); <span class="comment">// 尾部插入元素</span></span><br><span class="line">Long llen = jedis.llen(<span class="string">"list"</span>); <span class="comment">// List 长度，llen = 4</span></span><br><span class="line">List&lt;String&gt; list3 = jedis.lrange(<span class="string">"list"</span>,<span class="number">0</span>,-<span class="number">1</span>); <span class="comment">// list3 = [3,2,1,5] 按范围取出,第一个是key，第二个是起始位置，第三个是结束位置</span></span><br></pre></td></tr></table></figure></li><li><p>sets 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">res1 = jedis.sadd(<span class="string">"set"</span>,<span class="string">"1"</span>);</span><br><span class="line">res1 = jedis.sadd(<span class="string">"set"</span>,<span class="string">"2"</span>);</span><br><span class="line">res1 = jedis.sadd(<span class="string">"set"</span>,<span class="string">"3"</span>); <span class="comment">// 添加</span></span><br><span class="line">Long srem = jedis.srem(<span class="string">"set"</span>,<span class="string">"2"</span>); <span class="comment">// 移除某个元素</span></span><br><span class="line">Set&lt;String&gt; set1 = jedis.smembers(<span class="string">"set"</span>); <span class="comment">// 获取 key=set 的 Set</span></span><br><span class="line">Boolean sismember = jedis.sismember(<span class="string">"set"</span>,<span class="string">"1"</span>); <span class="comment">// key=set 的 Set 中是否存在元素 "1"</span></span><br><span class="line">String srandmember = jedis.srandmember(<span class="string">"set"</span>); <span class="comment">// 随机返回一个 set 元素</span></span><br><span class="line">List&lt;String&gt; list4 = jedis.srandmember(<span class="string">"set"</span>,<span class="number">2</span>); <span class="comment">// 随机返回指定个数个元素</span></span><br><span class="line">Long scar = jedis.scard(<span class="string">"set"</span>); <span class="comment">// set 的元素个数</span></span><br></pre></td></tr></table></figure></li><li><p>sorted sets 操作( TODO 用到再更新)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jedis.zadd(<span class="string">"zset"</span>,<span class="number">1</span>,<span class="string">"1"</span>);</span><br><span class="line">jedis.zadd(<span class="string">"zset"</span>,<span class="number">2.0</span>,<span class="string">"2"</span>);</span><br><span class="line">jedis.zadd(<span class="string">"zset"</span>,<span class="number">3</span>,<span class="string">"3"</span>);</span><br></pre></td></tr></table></figure></li><li><p>Hashes 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"chx"</span>);</span><br><span class="line">map.put(<span class="string">"age"</span>, <span class="string">"100"</span>);</span><br><span class="line">map.put(<span class="string">"email"</span>, <span class="string">"***@outlook.com"</span>);</span><br><span class="line">result = jedis.hmset(<span class="string">"user"</span>, map); <span class="comment">// 添加 Map，result = "OK"</span></span><br><span class="line">String res = jedis.hget(<span class="string">"user"</span>,<span class="string">"age"</span>); <span class="comment">// 获取 Map 指定 key 的 value，只能获取单个 key，res = 100</span></span><br><span class="line">List&lt;String&gt; list = jedis.hmget(<span class="string">"user"</span>, <span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"email"</span>); <span class="comment">// 获取 Map 指定 key 的 value，同时指定多个 key，list = [chx, 100, ***@outlook.com];</span></span><br><span class="line">Long hdel = jedis.hdel(<span class="string">"user"</span>, <span class="string">"age"</span>); <span class="comment">//删除 map 中的某个键值，hdel = 1</span></span><br><span class="line">Long hlen = jedis.hlen(<span class="string">"user"</span>); <span class="comment">// 获取 map 中的键值对个数，hlen = 2</span></span><br><span class="line">Set&lt;String&gt; set = jedis.hkeys(<span class="string">"user"</span>); <span class="comment">// 返回 map 中的所有 key</span></span><br><span class="line">Iterator&lt;String&gt; iterator = jedis.hkeys(<span class="string">"user"</span>).iterator(); <span class="comment">// 迭代遍历</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    String key = iterator.next();</span><br><span class="line">    String value = jedis.hmget(<span class="string">"user"</span>,key).get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; list2 = jedis.hvals(<span class="string">"user"</span>); <span class="comment">// 返回 map 中的所有 value</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Redis-其它名词"><a href="#Redis-其它名词" class="headerlink" title="Redis 其它名词"></a>Redis 其它名词</h3><ul><li><strong>expire 过期</strong></li></ul><p>Redis 允许为每一个 key 设置不同的过期时间，当它们到期时将自动从服务器上删除。</p><p>主动删除：client 主动访问，发现过期，立即删除</p><p>被动删除：Redis <strong>定时随机</strong>选择一些 key 进行检测，删除过期的 key，如果删除比例高于 25%，则继续选择一些 key 进行删除</p><ul><li><strong>管道(Pipelining)</strong></li></ul><p>Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。<br>发送一个命令之后只有等待服务器返回之后才会执行后续命令。</p><p>管道则可以一次发送多条命令而不必立即等待服务器返回，收到命令之后，服务器会以队列形式回复命令，管道操作比较耗内存，要注意命令的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pipeline pipeline = jedis.pipelined();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    pipeline.set(<span class="string">"1"</span>,<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">pipeline.sync();</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/freebird_lb/article/details/7778919" target="_blank" rel="noopener">Redis学习笔记7–Redis管道（pipeline）</a></p><p><a href="https://blog.csdn.net/u011489043/article/details/78769428" target="_blank" rel="noopener">分布式缓存Redis之Pipeline（管道）</a></p><ul><li><strong>事务</strong></li></ul><p>将一组 Redis 命令放到事务中执行，MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String watch = jedis.watch(<span class="string">"123"</span>);</span><br><span class="line">Transaction multi = jedis.multi();</span><br><span class="line">multi.set(<span class="string">"123"</span>,<span class="string">"123"</span>);</span><br><span class="line">List&lt;Object&gt; list1 = multi.exec();</span><br><span class="line">multi.discard();</span><br><span class="line">jedis.unwatch();</span><br></pre></td></tr></table></figure><p>multi 用于开启一个事务，exec 执行事务，watch 用于监测事务中 key 的变化，如果 key 被其它客户端改过了，那么整个事务会被取消，discard 用于取消事务</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个总结主要是了解下 Jedis 常用操作。具体细节学习需要文档、项目结合学习。</p><p>博客参考：<br><a href="https://blog.csdn.net/qq_26525215/article/details/60466222" target="_blank" rel="noopener">【Redis】Java中使用Jedis操作Redis(Maven导入包)、创建Redis连接池</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 &lt;/p&gt;

      
    
    </summary>
    
      <category term="redis" scheme="http://suiyia.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="http://suiyia.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>展望 2019 ！</title>
    <link href="http://suiyia.github.io/2019/01/02/%E5%B1%95%E6%9C%9B-2019/"/>
    <id>http://suiyia.github.io/2019/01/02/展望-2019/</id>
    <published>2019-01-02T14:28:00.000Z</published>
    <updated>2019-04-07T13:32:54.458Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/fZ0MWLYRQOfMBpVDHwq21g" target="_blank" rel="noopener">回首 2018</a>，毕业、入职，名校光环不再，浪潮褪去，原来我一直在裸泳。</p><p>作为已经工作半年的「职场新人」，仍有许多的不足和需要学习的地方。激情是年轻人应该拥有的东西，没有梦想，和咸鱼一样，我不甘心！</p><p>制定好目标，坚持的执行下去，总会有好的结果。</p><ol><li><p>坚持看书，每天花一个小时看书。自己思考、总结，把书中的想法总结出来，提升了思维也锻炼了写作能力。</p></li><li><p>坚持写博客，从公司项目中了解框架，既熟悉了业务，也运用得了框架，这应该是头两年需要技术积累的东西。</p></li><li><p>坚持锻炼，体重控制在 130 斤应该是最完美的体重，向这个目标进军，现在 140 斤。</p></li></ol><p>自己需要注意的地方：</p><ol><li><p>聆听的方式。别人与自己说话，学会聆听，学会体会别人话中表现的含义，不轻易打断别人，有时候还需要委婉地表达自己的想法。</p></li><li><p>注意社交，一个人闷着屋里，并不会造出什么轮子，随时了解外面发生的事，多个周围的同事交流，结交更多的朋友，体会不同人的想法、见解，开拓自己的视野。</p></li></ol><p>唯一愿望：</p><p>找一个可以一起吃饭、一起看电影、一起出去玩的女朋友。</p><p>结语：</p><p>人生就像一场马拉松，起步快的人，往往能提前看到美丽的风景，坚持久的人，必将得到丰厚的硕果，加油 2019 ！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fZ0MWLYRQOfMBpVDHwq21g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;回首 2018&lt;/a&gt;，毕业、入职，名校光环不再，浪潮褪去，原来我一直在裸泳。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
</feed>
