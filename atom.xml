<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸟日常</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suiyia.github.io/"/>
  <updated>2019-09-24T15:42:10.869Z</updated>
  <id>http://suiyia.github.io/</id>
  
  <author>
    <name>Answer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer题解 | 调整数组顺序使奇数位于偶数前面</title>
    <link href="http://suiyia.github.io/2019/09/24/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <id>http://suiyia.github.io/2019/09/24/剑指offer题解-调整数组顺序使奇数位于偶数前面/</id>
    <published>2019-09-24T15:40:00.000Z</published>
    <updated>2019-09-24T15:42:10.869Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:42:11 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分</p><p>并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>插入排序</p></li><li><p>从左自右找到第一个偶数，然后在该位置右边找到第一个奇数，进行交换。</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void reOrderArray(int [] array) &#123;</span><br><span class="line">    if (array.length == 0 || array.length == 1)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while (i &lt; array.length)&#123;</span><br><span class="line">    // 找到第一个偶数</span><br><span class="line">        while ((array[i] &amp; 1) == 1)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        j = i + 1;</span><br><span class="line">        while (j &lt; array.length)&#123;</span><br><span class="line">        // 找到第一个奇数</span><br><span class="line">            if ((array[j] &amp; 1) == 0)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 插入排序</span><br><span class="line">        if (j &lt; array.length)&#123;</span><br><span class="line">            int temp = array[j];</span><br><span class="line">            for (int k = j-1; k &gt;= i ; k--) &#123;</span><br><span class="line">                array[k+1] = array[k];</span><br><span class="line">            &#125;</span><br><span class="line">            array[i++] = temp;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:42:11 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 数值的整数次方</title>
    <link href="http://suiyia.github.io/2019/09/24/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <id>http://suiyia.github.io/2019/09/24/剑指offer题解-数值的整数次方/</id>
    <published>2019-09-24T14:22:00.000Z</published>
    <updated>2019-09-24T14:58:09.152Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 22:58:09 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>主要考察 指数函数 的特征以及程序的健壮性</p></li><li><p>底数不能为负数</p></li><li><p>底数为 0 时，0 的 n 次方始终为 0</p></li><li><p>指数为 0 时，且任意数的 0 次方都是 1</p></li><li><p>指数为负数时，结果是越来越小的</p></li><li><p>常规思路：循环累乘，时间复杂度 0（N）</p></li><li><p>递归思路：当n为偶数，a^n =（a^n/2）×（a^n/2），当 n为奇数，a^n = a^[(n-1)/2] × a^[(n-1)/2] * a</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 循环思路</span><br><span class="line">public double Power(double base, int exponent) &#123;</span><br><span class="line">    if (base == 0 )&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exponent == 0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean flag = false;</span><br><span class="line">    if (exponent &lt; 0)&#123;</span><br><span class="line">        exponent = -1*exponent;</span><br><span class="line">        flag = true;</span><br><span class="line">    &#125;</span><br><span class="line">    double result = 1;</span><br><span class="line">    for (int i = 0; i &lt; exponent; i++) &#123;</span><br><span class="line">        result = result * base;</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag)&#123;</span><br><span class="line">        return 1.0/result;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 递归思路</span><br><span class="line">public double Power1(double base, int expone</span><br><span class="line">    if (base == 0 )&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exponent == 0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    double result = 0.0;</span><br><span class="line">    int n = Math.abs(exponent);</span><br><span class="line">    result = Power1(base,n &gt;&gt; 1);</span><br><span class="line">    result = result * result;</span><br><span class="line">    if ((n &amp; 1) == 1)&#123;</span><br><span class="line">    // 如果指数n为奇数，则要再乘一次底数base</span><br><span class="line">        result = result * base;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exponent &lt; 0)&#123;</span><br><span class="line">    // 如果指数为负数，则应该求result的倒数</span><br><span class="line">        result = 1.0/result;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 22:58:09 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 二进制中 1 的个数</title>
    <link href="http://suiyia.github.io/2019/09/23/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://suiyia.github.io/2019/09/23/剑指offer题解-二进制中-1-的个数/</id>
    <published>2019-09-23T14:57:00.000Z</published>
    <updated>2019-09-24T14:22:21.274Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>位比较</p></li><li><p>思路1：使用<strong>整数右移</strong>与 1 进行位比较，计算总个数。但是如果是负数，高位右移将会补 1，所以可以使用 &gt;&gt;&gt; 无符号右移或者将负数变为正数再进行右移。</p></li><li><p>使用 <strong>1 左移</strong>的方式进行位比较，一直比较到 Interger.MAX_VALUE = 0x7fffffff</p></li><li><p>思路2：如果一个整数不为 0，那么这个整数至少有一位是 1。</p><p>如果我们把这个整数减 1，那么原来处在整数最右边的 1 就会变为 0，1 右边的 0 变为 1。其余所有位将不会受到影响。</p><p>然后将两者相与，如果结果不为 0，说明原来整数最右边 1 的左边里面肯定包含 1，然后减 1 继续这么循环下去，不为 0 的次数就是 1 出现的次数。</p><p>例：1100 &amp; 1011 = 1000，数字 1100 最右边的 1 左边还有一个 1</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 先变为正整数</span><br><span class="line">public int NumberOf12(int n) &#123;</span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    if (n &lt; 0)&#123;</span><br><span class="line">        n = n &amp; 0x7fffffff;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (n != 0)&#123;</span><br><span class="line">        if ((n &amp; 1) != 0)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n &gt;&gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 整数无符号右移</span><br><span class="line">public int NumberOf13(int n) &#123;</span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (n != 0)&#123;</span><br><span class="line">        if ((n &amp; 1) != 0)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n &gt;&gt;&gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1 左移</span><br><span class="line">public int NumberOf1(int n) &#123;</span><br><span class="line">if (n == 0)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int flag = 1;</span><br><span class="line">    while (flag != 0)&#123;</span><br><span class="line">    if (flag &amp; n == 1)&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = flag &lt;&lt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 思路 2</span><br><span class="line">public int NumberOf11(int n) &#123;</span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (n != 0)&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        n = n &amp; (n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 矩形覆盖</title>
    <link href="http://suiyia.github.io/2019/09/23/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
    <id>http://suiyia.github.io/2019/09/23/剑指offer题解-矩形覆盖/</id>
    <published>2019-09-23T14:49:00.000Z</published>
    <updated>2019-09-23T14:57:02.886Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li>实质是斐波拉契数列</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 递归版本</span><br><span class="line">    public int RectCover(int target) &#123;</span><br><span class="line">        if (n == 1)</span><br><span class="line">            return 1;</span><br><span class="line">        if (n == 2)</span><br><span class="line">            return 2;</span><br><span class="line">        return RectCover(n - 1) + RectCover(n - 2) * 2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 变态跳台阶</title>
    <link href="http://suiyia.github.io/2019/09/23/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://suiyia.github.io/2019/09/23/剑指offer题解-变态跳台阶/</id>
    <published>2019-09-23T13:52:00.000Z</published>
    <updated>2019-09-23T14:49:00.226Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>参考前面的斐波拉契数列</p></li><li><p>第 n 层台阶可能由：第 n-1 跳一阶过来，还可能由第 n-2 跳两阶过来等，所以总情况 f（n）= f（n-2）+ f（n-1）+ … + f(1)</p></li><li><p>递推关系式实现 f（n）= 2 * f（n-1）</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 递归版本</span><br><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line"></span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 2 * Fibonacci(n-1);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 循环</span><br><span class="line">public int Fibonacci23(int n)&#123;</span><br><span class="line">if (n == 0)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">if (n == 1)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int b = 1;</span><br><span class="line">int c = 0;</span><br><span class="line">for (int i = 1;i&lt;n;i++)&#123;</span><br><span class="line">c = 2 * b;</span><br><span class="line">        b = c;</span><br><span class="line">&#125;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 跳台阶</title>
    <link href="http://suiyia.github.io/2019/09/23/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://suiyia.github.io/2019/09/23/剑指offer题解-跳台阶/</id>
    <published>2019-09-23T13:15:00.000Z</published>
    <updated>2019-09-23T13:51:57.234Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>第 n 层台阶可能由：第 n-1 跳一阶过来，还可能由第 n-2 跳两阶过来，所以总情况 f（n）= f（n-2）+ f（n-1）</p></li><li><p>其实就是斐波拉契数列</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 递归版本</span><br><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line"></span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return Fibonacci(n-1) + Fibonacci(n-2);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 循环</span><br><span class="line">public int Fibonacci23(int n)&#123;</span><br><span class="line">if (n == 0)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">if (n == 1 || n == 2)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int a = 0;</span><br><span class="line">int b = 1;</span><br><span class="line">int c = 0;</span><br><span class="line">for (int i = 1;i&lt;n;i++)&#123;</span><br><span class="line">c = a + b;</span><br><span class="line">a = b;</span><br><span class="line">b = c;</span><br><span class="line">&#125;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多项式递推</span><br><span class="line">public int Fibonacci2(int n) &#123;</span><br><span class="line">    if(n==0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else if(n==1||n==2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else if(n==3) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 3*Fibonacci(n-3)+2*Fibonacci(n-4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 斐波拉契数列</title>
    <link href="http://suiyia.github.io/2019/09/23/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://suiyia.github.io/2019/09/23/剑指offer题解-斐波拉契数列/</id>
    <published>2019-09-23T12:39:00.000Z</published>
    <updated>2019-09-23T13:14:37.538Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项（从 0 开始，第 0 项为 0）。<br>n&lt;=39</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>递归，f（n）= f（n-1）+ f（n-2），但是每一次的迭代计算结果没有保存，很容易栈溢出</p></li><li><p>循环方式，每次的结果进行累加</p></li><li><p>多项关系式递推</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 递归版本</span><br><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line"></span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return Fibonacci(n-1) + Fibonacci(n-2);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 循环</span><br><span class="line">public int Fibonacci23(int n)&#123;</span><br><span class="line">if (n == 0)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">if (n == 1 || n == 2)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int a = 0;</span><br><span class="line">int b = 1;</span><br><span class="line">int c = 0;</span><br><span class="line">for (int i = 1;i&lt;n;i++)&#123;</span><br><span class="line">c = a + b;</span><br><span class="line">a = b;</span><br><span class="line">b = c;</span><br><span class="line">&#125;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多项式递推</span><br><span class="line">public int Fibonacci2(int n) &#123;</span><br><span class="line">    if(n==0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else if(n==1||n==2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else if(n==3) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 3*Fibonacci(n-3)+2*Fibonacci(n-4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 旋转数组的最小数字</title>
    <link href="http://suiyia.github.io/2019/09/19/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://suiyia.github.io/2019/09/19/剑指offer题解-旋转数组的最小数字/</id>
    <published>2019-09-19T15:27:00.000Z</published>
    <updated>2019-09-23T12:39:25.513Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>常规思路：从头到尾遍历一遍找到最小值，时间复杂度 O（N）</p></li><li><p>方法二</p><ul><li><p>非递减数组旋转，旋转之后可以看做是两个非递减数组的拼接，当 a[index] &gt; a[index+1] 时，最小值就是 a[index+1]。</p></li><li><p>有序数组的查找，可以选择二分查找</p></li><li><p><strong>规律（数组内元素都不相同）</strong>：若 A[mid] &gt; a[low]，那么最小值一定在 mid 及 high 之间；若 A[mid] &lt; a[low]，那么最小值一定在 low 及 mid 之间</p></li></ul></li><li><p><strong>注意点：如果 A[mid] = a[low]，那么就不能判断最小值在哪一个位置。例如 01111 旋转可以变为 11110 和 10111。只能从头到尾遍历</strong></p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li>方法二实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public int minNumberInRotateArray(int [] array) &#123;</span><br><span class="line"></span><br><span class="line">    if (array.length == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (array.length == 1)&#123;</span><br><span class="line">        return array[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = array.length - 1;</span><br><span class="line"></span><br><span class="line">    while(low &lt; high)&#123;</span><br><span class="line">        int mid = (low + high) / 2;</span><br><span class="line">        if (low == high -1)&#123;</span><br><span class="line">            return array[high];</span><br><span class="line">        &#125;</span><br><span class="line">        if (array[mid] &gt; array[low])&#123;</span><br><span class="line">                // 最小值在右边</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;else if (array[mid] &lt; array[low])&#123;</span><br><span class="line">                // 最小值在左边</span><br><span class="line">                high = mid;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            // 分辨不出最小值位置</span><br><span class="line">  return serach(array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // 从头到尾查找一遍</span><br><span class="line">    public int serach(int[] array)&#123;</span><br><span class="line">    int minValue = Integer.MAX_VALUE;</span><br><span class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        if (array[i] &lt; minValue)&#123;</span><br><span class="line">            minValue = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return minValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>数组为空，或者只有一个长度的情况，考虑数组边界问题</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 两个栈实现队列</title>
    <link href="http://suiyia.github.io/2019/09/19/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://suiyia.github.io/2019/09/19/剑指offer题解-两个栈实现队列/</id>
    <published>2019-09-19T13:13:00.000Z</published>
    <updated>2019-09-19T15:13:51.892Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>方法 1（常规思路，移动次数较多）</p><ul><li><p>stack1 专门用于 push 数据，stack2 专门 pop 数据。</p></li><li><p>调用 pop() 方法时候，stack1 数据全部 push 到 stack2，保存 stack2 最顶上元素。</p></li><li><p>pop 方法结束之前，将 stack2 的数据再推回到 stack1 中。</p></li></ul></li></ul><ul><li><p>方法 2（推荐，移动次数少）</p><ul><li><p>stack1 专门用于 push 数据。</p></li><li><p>pop 方法调用的时候，<strong>若 stack2 为空</strong>就先将 stack1 中的<strong>全部数据</strong>推到 stack2，然后 pop stack2 中的元素；否则直接 pop stack2 中的数据。</p></li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li>方法二</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</span><br><span class="line">   Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   public void push(int node) &#123;</span><br><span class="line">       stack1.push(node);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public int pop() &#123;</span><br><span class="line">       if (stack1.isEmpty() &amp;&amp; stack2.isEmpty())&#123;</span><br><span class="line">           throw new RuntimeException(&quot;Empty exception!&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       if (stack2.isEmpty())&#123;</span><br><span class="line">           while (!stack1.isEmpty())&#123;</span><br><span class="line">               stack2.push(stack1.pop());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return stack2.pop();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>pop 数据考虑边界情况，栈为空</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 重建二叉树</title>
    <link href="http://suiyia.github.io/2019/09/18/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://suiyia.github.io/2019/09/18/剑指Offer题解-重建二叉树/</id>
    <published>2019-09-18T14:32:00.000Z</published>
    <updated>2019-09-19T15:13:51.912Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>方法 1. 使用栈保存遍历链表的结果，然后 push 栈输出到 ArrayList</p></li><li><p>方法 2. 递归方式实现倒序输出</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><strong>递归方式实现</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">       if (listNode != null)&#123;</span><br><span class="line">           printListFromTailToHead(listNode.next);</span><br><span class="line">           arrayList.add(listNode.val);</span><br><span class="line">       &#125;</span><br><span class="line">       return arrayList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   class ListNode &#123;</span><br><span class="line">       int val;</span><br><span class="line">       ListNode next = null;</span><br><span class="line"></span><br><span class="line">           ListNode(int val) &#123;</span><br><span class="line">           this.val = val;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 从尾到头打印链表</title>
    <link href="http://suiyia.github.io/2019/09/17/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://suiyia.github.io/2019/09/17/剑指Offer题解-从尾到头打印链表/</id>
    <published>2019-09-17T15:18:00.000Z</published>
    <updated>2019-09-19T15:13:51.901Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>方法 1. 使用栈保存遍历链表的结果，然后 push 栈输出到 ArrayList</p></li><li><p>方法 2. 递归方式实现倒序输出</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><strong>递归方式实现</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">       if (listNode != null)&#123;</span><br><span class="line">           printListFromTailToHead(listNode.next);</span><br><span class="line">           arrayList.add(listNode.val);</span><br><span class="line">       &#125;</span><br><span class="line">       return arrayList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   class ListNode &#123;</span><br><span class="line">       int val;</span><br><span class="line">       ListNode next = null;</span><br><span class="line"></span><br><span class="line">           ListNode(int val) &#123;</span><br><span class="line">           this.val = val;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 替换空格</title>
    <link href="http://suiyia.github.io/2019/09/17/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC-%E5%89%91%E6%8C%87Offer/"/>
    <id>http://suiyia.github.io/2019/09/17/替换空格-剑指Offer/</id>
    <published>2019-09-17T13:31:00.000Z</published>
    <updated>2019-09-19T15:13:51.870Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>不使用工具类</p></li><li><p>思路：先统计空格出现次数，然后就知道了替换后的字符串长度，使用另外的字符串数组保存替换后的字符串，然后从右往左进行填充</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><p>先统计空格出现的次数，出现一次空格，那么增加的长度就是加 2，N 个空格就是增加了 N*2</p></li><li><p>然后用另外的数组保存替换后的字符</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static String replaceSpace(StringBuffer str) &#123;</span><br><span class="line"></span><br><span class="line">// 统计空格数量</span><br><span class="line">        int spaceCount = 0;</span><br><span class="line">        for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">            if (str.charAt(i) == &apos; &apos;)&#123;</span><br><span class="line">                spaceCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int length = str.length();</span><br><span class="line">        // 用另外的字符数组保存字符</span><br><span class="line">        char[] a = new char[length + spaceCount * 2];</span><br><span class="line">        </span><br><span class="line">        // 字符数组索引，从最后面开始</span><br><span class="line">        int afterIndex = length + spaceCount * 2 - 1;</span><br><span class="line">        </span><br><span class="line">        for (int j = length - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            if (str.charAt(j) != &apos; &apos;)&#123;</span><br><span class="line">            // 如果不是空格，就直接赋值，索引也跟着减</span><br><span class="line">                a[afterIndex] = str.charAt(j);</span><br><span class="line">                afterIndex --;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                a[afterIndex] = &apos;0&apos;;</span><br><span class="line">                a[afterIndex - 1] = &apos;2&apos;;</span><br><span class="line">                a[afterIndex - 2] = &apos;%&apos;;</span><br><span class="line">                afterIndex = afterIndex - 3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return String.valueOf(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>从后往前填充相对简单点</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解 | 二维数组中的查找 </title>
    <link href="http://suiyia.github.io/2019/09/16/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE-%E5%89%91%E6%8C%87Offer/"/>
    <id>http://suiyia.github.io/2019/09/16/二维数组中的查找-剑指Offer/</id>
    <published>2019-09-16T15:11:00.000Z</published>
    <updated>2019-09-19T15:11:08.513Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>时间限制：1秒 空间限制：32768K</p><h1 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h1><ul><li><p>常规思路：左上角开始，每行从左到右都轮询一次。</p><ul><li><p>时间复杂度 O（N^2）</p></li><li><p>空间复杂度 O（1）</p></li></ul></li><li><p>从右下角开始，每行从左往右轮询：上面一行相同列的元素比当前元素小，右边同行元素比当前元素大，那么不用全部元素比较。</p><ul><li><p>时间复杂度：O(行高 + 列宽)</p></li><li><p>空间复杂度：O(1)</p></li></ul></li></ul><ul><li>从右上角开始，从右往左。原理同上</li></ul><ul><li>从右下角开始，和常规思路类似</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>M 行 N 列数组，寻找元素 K</p><ul><li>左下角开始寻找</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static boolean Find(int target, int [][] array) &#123;</span><br><span class="line"></span><br><span class="line">    int i = array.length - 1;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while (i &gt;= 0 &amp;&amp; j &lt; array[0].length)&#123;</span><br><span class="line">        if (array[i][j] &gt; target) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;else if(array[i][j] &lt; target)&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li><p>数组边界问题</p></li><li><p>常规思路，遇到有序序列进行查找时，可以使用<strong>二分查找</strong>，时间复杂度将进一步降低，时间复杂度 Mlog(n)</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://suiyia.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="http://suiyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Log4j 2 基本概念</title>
    <link href="http://suiyia.github.io/2019/09/04/Log4j-2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://suiyia.github.io/2019/09/04/Log4j-2-基本概念/</id>
    <published>2019-09-04T06:52:00.000Z</published>
    <updated>2019-09-04T07:00:04.528Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h1 id="日志框架分类"><a href="#日志框架分类" class="headerlink" title="日志框架分类"></a>日志框架分类</h1><p>日志框架按照功能可以分为日志接口、日志实现两部分。</p><p>编写程序时，推荐使用<strong>日志接口</strong>的 API 进行方法调用，然后使用对应的<strong>日志实现框架</strong>打印日志。</p><ul><li><p>日志接口，日志的接口规范，它对用户提供了统一的日志接口，屏蔽了不同日志组件的差异。</p><ul><li><p><a href="https://commons.apache.org/proper/commons-logging/" target="_blank" rel="noopener">Apache Commons Logging Component</a>，2014 年之后文档没有再更新</p></li><li><p><a href="https://www.slf4j.org/" target="_blank" rel="noopener">SLF4J（Simple Logging Facade for Java）</a></p></li></ul></li><li><p>日志实现，定义具体日志打印内容</p><ul><li><p>JDKLog，java.util.logging.Logger</p></li><li><p><a href="http://logging.apache.org/log4j/1.2/" target="_blank" rel="noopener">Log4J</a>，2015 年开始已经停止维护</p></li><li><p><a href="https://logback.qos.ch/" target="_blank" rel="noopener">LOGBack</a>，继承于 Log4J</p></li><li><p><a href="https://logging.apache.org/log4j/2.x/" target="_blank" rel="noopener">Log4J2</a> Log4J 升级版，2019-08-06 版本更新至 2.12.1，API 相关用法不兼容 1.X 版本</p></li></ul></li></ul><h1 id="Log4j-2-内置概念"><a href="#Log4j-2-内置概念" class="headerlink" title="Log4j 2 内置概念"></a>Log4j 2 内置概念</h1><ul><li>Markers：为某条日志添加标志位，使用 %marker 进行输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">    private static final Marker SQL_MARKER = MarkerManager.getMarker(&quot;SQL&quot;);</span><br><span class="line">    Marker markerA = MarkerManager.getMarker(&quot;Marker A&quot;);</span><br><span class="line">    Marker markerB = MarkerManager.getMarker(&quot;Marker B&quot;);</span><br><span class="line">    logger.debug(markerA,&quot;your name is &#123;&#125; &quot;,&quot;Jack&quot;);</span><br><span class="line">    logger.debug(markerB,&quot;your name is &#123;&#125; &quot;,&quot;Ma&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log4j.xml：</span><br><span class="line">&lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M %marker - %msg%xEx%n&quot;/&gt;</span><br><span class="line"></span><br><span class="line">Console Out：</span><br><span class="line">10:14:02.639 DEBUG FlowTracing 60 test Marker A - your name is Jack </span><br><span class="line">10:14:02.642 DEBUG FlowTracing 61 test Marker B - your name is Ma</span><br></pre></td></tr></table></figure><ul><li><p>Lookups：在配置文件中添加变量、使用变量</p></li><li><p>Appenders：定义日志事件输出方式（日志文件名称、路径、什么级别日志才能输出、文件大小等等），其实就是文件流输出定义。</p><ul><li>AsyncAppender 用另外的线程记录日志，默认使用 ArrayBlockingQueue 队列进行日志记录，当发生异常时，默认会忽略异常，记得手动开启，并使用FailoverAppender 对异常情况进行补充打印输出</li><li>ConsoleAppender，控制台输出</li><li>FailoverAppender，当主 Appender 失败时，它将起作用</li><li>FileAppender，文件输出，当多个程序对同一文件进行输出时，各自程序之间的配置也不受影响</li><li>JDBCAppender，直接写到数据库</li><li>HttpAppender，http 请求发送到另外的服务接收，如果服务返回的不是 2XX，将会抛出异常。</li><li>KafkaAppender，发送到 Kafka</li><li>RollingFileAppender，可以滚动的文件输出，包含触发规则（触发滚动条件：时间、大小）、滚动规则（怎么进行更新：文件数量），默认日志文件个数为 7 个。</li><li><a href="https://logging.apache.org/log4j/2.x/manual/appenders.html" target="_blank" rel="noopener">等等</a></li></ul></li><li><p>Layouts：Appender 使用定义好的 LayOut 对 LogEvent 进行格式化输出，</p><ul><li>CSV Layouts，以 Comma Separated Value (CSV) 形式输出</li><li>JSON Layout，JSON 格式输出</li><li>Pattern Layout，用特殊的字符输出对应的内容，定制化强</li><li>XML Layout</li><li>Location Infomation，当日志中需要日志所在类、方法、代码行数这些信息时，会花费 1.3-5 倍的时间，相比不需要 Location Infomation 的场景。并且在使用异步的 Appender 时，默认的 Location Infomation 默认关闭，如果开启，会比不开启花费 30-100 倍的性能消耗</li></ul></li><li><p>Filters：决定哪些事件可以输出，哪些事件不能输出。过滤结果有 3 个结果，ACCEPT（允许）, DENY（拒绝输出）or NEUTRAL（中立、默认）。</p><ul><li>BurstFilter，当每秒日志输出事件速率大于一定值，将会抛弃掉级别低的日志</li><li>CompositeFilter，直接在 configuration 级别添加多个过滤器</li><li>DynamicThresholdFilter，根据一些属性值去动态修改该条日志的输出级别</li><li>MapFilter，如果 LogEvent 中的 MapMessage 内包含特定属性，就可以选择过滤</li><li>MarkerFilter、NoMarkerFilter，对应定义或者未定义 Marker 的事件进行过滤</li><li>RegexFilter，正则过滤 formatted or unformatted message</li><li>ThreadContextMapFilter ，对 ThreadContextMap 中的内容进行过滤</li><li>ThresholdFilter，对 Level 进行过滤</li><li>TimeFilter，根据某个时间点、时间段进行过滤</li></ul></li></ul><h1 id="3-Java-API-用法"><a href="#3-Java-API-用法" class="headerlink" title="3. Java API 用法"></a>3. Java API 用法</h1><ul><li><p>Flow Tracing</p><p>日志跟踪</p></li><li><p>Markers（标记）</p><p>对于有特定标识需求的地方，可以使用 Marker 进行标记，并且用 %marker 进行打印输出。</p></li><li><p>ThreadContext</p><p>Mapped Diagnostic Context（MDC）的实现，类似 request，可以存放 key-value 键值对，也可以销毁，使用 %X{key} 输出。</p><p>the MDC is a map which stores the context data of the particular thread where the context is running.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%X&#123;id&#125; 输出 context map 中 key = id 的值</span><br><span class="line">%X 输出 context map 所有值</span><br><span class="line"></span><br><span class="line">public void test()&#123;</span><br><span class="line">    ThreadContext.put(&quot;id&quot;, &quot;321&quot;); // Add the fishtag;</span><br><span class="line">    ThreadContext.put(&quot;name&quot;, &quot;996&quot;); // Add the fishtag;</span><br><span class="line">    logger.debug(&quot;Message 1&quot;);</span><br><span class="line">    logger.debug(&quot;Message 2&quot;);</span><br><span class="line">    ThreadContext.clearAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>log4j-slf4j-impl 是 slf4j 转接到 log4j 2 的日志输出框架。</p><p>slf4j-log4j12 是 slf4j 转接到 log4j 1.x 的日志输出框架 ，而 log4j 1.x 已经在 2015 年 8 月就停止更新了。</p><p>log4j 官方建议升级到 log4j 2</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;日志框架分类&quot;&gt;&lt;a href=&quot;#日志框架分类&quot; class=&quot;headerlink&quot; title=&quot;日志框架分类&quot;&gt;&lt;/a&gt;日志框
      
    
    </summary>
    
      <category term="日志" scheme="http://suiyia.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="Log4j" scheme="http://suiyia.github.io/tags/Log4j/"/>
    
  </entry>
  
  <entry>
    <title>浮点数整数转换精度丢失问题</title>
    <link href="http://suiyia.github.io/2019/08/10/%E6%B5%AE%E7%82%B9%E6%95%B0%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
    <id>http://suiyia.github.io/2019/08/10/浮点数整数转换精度丢失问题/</id>
    <published>2019-08-10T09:44:00.000Z</published>
    <updated>2019-09-19T10:36:57.304Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h1 id="浮点数转换精度丢失"><a href="#浮点数转换精度丢失" class="headerlink" title="浮点数转换精度丢失"></a>浮点数转换精度丢失</h1><p>在线支付对接，支付商（微信、支付宝、银联等）的接口中，定义的金额单位不一样，有时候需要对<strong>分、元</strong>进行相互转换，转换的过程中容易出现问题。</p><p>下面的例子，系统中接收的参数是元，请求接口单位是分，在转换过程中出现精度丢失，少扣了用户 1 分钱。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println((int) (0.29*100));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出： 28</span><br></pre></td></tr></table></figure><p></p><ul><li>错误原因</li></ul><p>0.29*100 = 28.999999999999996…</p><p>浮点数强制转换成整数类型会舍弃非整数部分</p><ul><li>解决方法</li></ul><p>(int) Math.round(0.29*100) -&gt; 29</p><h1 id="浮点数大小比较错误"><a href="#浮点数大小比较错误" class="headerlink" title="浮点数大小比较错误"></a>浮点数大小比较错误</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 例子 1</span><br><span class="line">System.out.println(0.1d == 0.1f);  // false</span><br><span class="line">// 例子 2</span><br><span class="line">System.out.println(10.222222225f == 10.222222229f); // true</span><br><span class="line">System.out.println(10.222222225f &gt; 10.222222229f); // false</span><br><span class="line">System.out.println(10.222222225f &lt; 10.222222229f); // false</span><br><span class="line">// 例子 3</span><br><span class="line">Double a = Double.valueOf(&quot;0.0&quot;);</span><br><span class="line">Double b = Double.valueOf(&quot;-0.0&quot;);</span><br><span class="line">System.out.println(a.equals(b));  // false</span><br></pre></td></tr></table></figure><p>浮点数由于精度问题，并不能用 ==，&gt;，&lt; 来进行大小比较，最好的方式就是<strong>定义一个精度，用差的绝对值比较，在精度范围内就认为是相等的</strong></p><p><a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.6.2" target="_blank" rel="noopener">官方文档参考</a></p><p><a href="https://blog.csdn.net/wcxiaoych/article/details/42806313" target="_blank" rel="noopener">Java中的浮点数比较 == equals 和 compare</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;浮点数转换精度丢失&quot;&gt;&lt;a href=&quot;#浮点数转换精度丢失&quot; class=&quot;headerlink&quot; title=&quot;浮点数转换精度丢失
      
    
    </summary>
    
    
      <category term="浮点数" scheme="http://suiyia.github.io/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Springboot 项目运用 Redis 缓存数据</title>
    <link href="http://suiyia.github.io/2019/08/10/Springboot-%E9%A1%B9%E7%9B%AE%E8%BF%90%E7%94%A8-Redis-%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE/"/>
    <id>http://suiyia.github.io/2019/08/10/Springboot-项目运用-Redis-缓存数据/</id>
    <published>2019-08-10T09:40:00.000Z</published>
    <updated>2019-08-10T09:51:13.059Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Springboot 项目与 Redis 结合获取数据</p><h1 id="pom-依赖"><a href="#pom-依赖" class="headerlink" title="pom 依赖"></a>pom 依赖</h1><p>主要是 mybatis、redis 的相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">  &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.18.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;8.0.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /web</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      # 数据库访问配置, 使用druid数据源</span><br><span class="line">      type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">      url: jdbc:mysql://127.0.0.1:3306/test?useunicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">      username: root</span><br><span class="line">      password: 123456</span><br><span class="line">      # 连接池配置</span><br><span class="line">      initial-size: 5</span><br><span class="line">      min-idle: 5</span><br><span class="line">      max-active: 20</span><br><span class="line">      # 连接等待超时时间</span><br><span class="line">      max-wait: 30000</span><br><span class="line">      # 配置检测可以关闭的空闲连接间隔时间</span><br><span class="line">      time-between-eviction-runs-millis: 60000</span><br><span class="line">      # 配置连接在池中的最小生存时间</span><br><span class="line">      min-evictable-idle-time-millis: 300000</span><br><span class="line">      validation-query: select &apos;1&apos; from dual</span><br><span class="line">      test-while-idle: true</span><br><span class="line">      test-on-borrow: false</span><br><span class="line">      test-on-return: false</span><br><span class="line">      # 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">      pool-prepared-statements: true</span><br><span class="line">      max-open-prepared-statements: 20</span><br><span class="line">      max-pool-prepared-statement-per-connection-size: 20</span><br><span class="line">      # 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, &apos;wall&apos;用于防火墙</span><br><span class="line">      filters: stat,wall</span><br><span class="line">      # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔</span><br><span class="line">      aop-patterns: com.springboot.servie.*</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    # Redis数据库索引（默认为0）</span><br><span class="line">    database: 0</span><br><span class="line">    # Redis服务器地址</span><br><span class="line">    host: localhost</span><br><span class="line">    # Redis服务器连接端口</span><br><span class="line">    port: 6379</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    com.example.demo.dao: debug</span><br></pre></td></tr></table></figure><h1 id="Redis-配置类"><a href="#Redis-配置类" class="headerlink" title="Redis 配置类"></a>Redis 配置类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig extends CachingConfigurerSupport &#123;</span><br><span class="line"></span><br><span class="line">    // 自定义缓存key生成策略</span><br><span class="line">    @Override</span><br><span class="line">    @Bean</span><br><span class="line">    public KeyGenerator keyGenerator() &#123;</span><br><span class="line">        return new KeyGenerator() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object generate(Object target, java.lang.reflect.Method method, Object... params) &#123;</span><br><span class="line">                StringBuffer sb = new StringBuffer();</span><br><span class="line">                sb.append(target.getClass().getName());</span><br><span class="line">                sb.append(method.getName());</span><br><span class="line">                for (Object obj : params) &#123;</span><br><span class="line">                    sb.append(obj.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                return sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 缓存管理器</span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) &#123;</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.create(connectionFactory);</span><br><span class="line">        return cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        StringRedisTemplate template = new StringRedisTemplate(factory);</span><br><span class="line">        setSerializer(template);// 设置序列化工具</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setSerializer(StringRedisTemplate template) &#123;</span><br><span class="line">        @SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="dao-层以及实现"><a href="#dao-层以及实现" class="headerlink" title="dao 层以及实现"></a>dao 层以及实现</h1><p>使用 MyBatis 注解方式实现数据访问<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface StudentManager &#123;</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update student set sname=#&#123;sname&#125;,ssex=#&#123;ssex&#125; where sno=#&#123;sno&#125;&quot;)</span><br><span class="line">    int update(Student student);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from student where sno=#&#123;sno&#125;&quot;)</span><br><span class="line">    void deleteStudentBySno(String sno);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from student where sno=#&#123;sno&#125;&quot;)</span><br><span class="line">    @Results(id = &quot;student&quot;, value = &#123; @Result(property = &quot;sno&quot;, column = &quot;sno&quot;, javaType = String.class),</span><br><span class="line">        @Result(property = &quot;sname&quot;, column = &quot;sname&quot;, javaType = String.class),</span><br><span class="line">        @Result(property = &quot;ssex&quot;, column = &quot;ssex&quot;, javaType = String.class) &#125;)</span><br><span class="line">    Student queryStudentBySno(String sno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="service-层及实现"><a href="#service-层及实现" class="headerlink" title="service 层及实现"></a>service 层及实现</h1><p>queryStudentBySno 方法使用了注解 @Cacheable(key=”#p0”)，即将 id 作为 redis 中的 key 值</p><ul><li>@CacheConfig(cacheNames = “student”) 一个类中可能会有多个缓存操作，而这些缓存操作可能是重复的</li><li>@Cacheable 是用来声明方法是可缓存的</li><li>@CachePut 主要用于数据新增和修改操作上</li><li>@CacheEvict 通常用在删除方法上，用来从缓存中移除相应数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@CacheConfig(cacheNames = &quot;student&quot;)</span><br><span class="line">public interface StudentService &#123;</span><br><span class="line"></span><br><span class="line">    @CachePut(key = &quot;#p0.sno&quot;)</span><br><span class="line">    Student update(Student student);</span><br><span class="line"></span><br><span class="line">    @CacheEvict(key = &quot;#p0&quot;, allEntries = true)</span><br><span class="line">    void deleteStudentBySno(String sno);</span><br><span class="line"></span><br><span class="line">    @Cacheable(key = &quot;#p0&quot;)</span><br><span class="line">    Student queryStudentBySno(String sno);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class StudentServiceImpl implements StudentService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentManager studentManager;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Student update(Student student) &#123;</span><br><span class="line">        this.studentManager.update(student);</span><br><span class="line">        return this.studentManager.queryStudentBySno(student.getSno());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void deleteStudentBySno(String sno) &#123;</span><br><span class="line">        this.studentManager.deleteStudentBySno(sno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Student queryStudentBySno(String sno) &#123;</span><br><span class="line">        return this.studentManager.queryStudentBySno(sno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Test-用例"><a href="#Test-用例" class="headerlink" title="Test 用例"></a>Test 用例</h1><p>第一次从数据库中读取，第二次直接从缓存读取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class DemoApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentService studentService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() &#123;</span><br><span class="line">        System.out.println(studentService.queryStudentBySno(&quot;001&quot;).toString());</span><br><span class="line">        System.out.println(studentService.queryStudentBySno(&quot;001&quot;).toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2019-08-10 17:27:32.739 DEBUG 7140 --- [           main] c.e.d.d.S.queryStudentBySno              : ==&gt;  Preparing: select * from student where sno=? </span><br><span class="line">2019-08-10 17:27:33.053 DEBUG 7140 --- [           main] c.e.d.d.S.queryStudentBySno              : ==&gt; Parameters: 001(String)</span><br><span class="line">2019-08-10 17:27:33.108 DEBUG 7140 --- [           main] c.e.d.d.S.queryStudentBySno              : &lt;==      Total: 1</span><br><span class="line">Student(sno=001, sname=KangKang, ssex=M )</span><br><span class="line">Student(sno=001, sname=KangKang, ssex=M )</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Sprin
      
    
    </summary>
    
      <category term="Spring学习" scheme="http://suiyia.github.io/categories/Spring%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Redis" scheme="http://suiyia.github.io/tags/Redis/"/>
    
      <category term="Springboot" scheme="http://suiyia.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>Springboot 使用 MyBatis 实现增删改查</title>
    <link href="http://suiyia.github.io/2019/08/10/Springboot-%E4%BD%BF%E7%94%A8-MyBatis-%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>http://suiyia.github.io/2019/08/10/Springboot-使用-MyBatis-实现增删改查/</id>
    <published>2019-08-10T09:39:00.000Z</published>
    <updated>2019-08-10T09:51:13.110Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>Springboot 项目结合 Mybatis 实现 CRUD 增删改查</p><h2 id="基本-Mysql-脚本"><a href="#基本-Mysql-脚本" class="headerlink" title="基本 Mysql 脚本"></a>基本 Mysql 脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line"> sno VARCHAR(10) NOT NULL ,</span><br><span class="line">    sname VARCHAR(10) NOT NULL ,</span><br><span class="line">    ssex VARCHAR(2) NOT NULL </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO STUDENT VALUES (&apos;001&apos;, &apos;KangKang&apos;, &apos;M &apos;);</span><br><span class="line">INSERT INTO STUDENT VALUES (&apos;002&apos;, &apos;Mike&apos;, &apos;M &apos;);</span><br><span class="line">INSERT INTO STUDEN VALUES (&apos;003&apos;, &apos;Jane&apos;, &apos;F &apos;);</span><br></pre></td></tr></table></figure><h2 id="pom-基本包依赖"><a href="#pom-基本包依赖" class="headerlink" title="pom 基本包依赖"></a>pom 基本包依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;8.0.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="配置文件-application-yml"><a href="#配置文件-application-yml" class="headerlink" title="配置文件 application.yml"></a>配置文件 application.yml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /web</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      # 数据库访问配置, 使用druid数据源</span><br><span class="line">      type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">      url: jdbc:mysql://127.0.0.1:3306/test?useunicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">      username: root</span><br><span class="line">      password: 123456</span><br><span class="line">      # 连接池配置</span><br><span class="line">      initial-size: 5</span><br><span class="line">      min-idle: 5</span><br><span class="line">      max-active: 20</span><br><span class="line">      # 连接等待超时时间</span><br><span class="line">      max-wait: 30000</span><br><span class="line">      # 配置检测可以关闭的空闲连接间隔时间</span><br><span class="line">      time-between-eviction-runs-millis: 60000</span><br><span class="line">      # 配置连接在池中的最小生存时间</span><br><span class="line">      min-evictable-idle-time-millis: 300000</span><br><span class="line">      validation-query: select &apos;1&apos; from dual</span><br><span class="line">      test-while-idle: true</span><br><span class="line">      test-on-borrow: false</span><br><span class="line">      test-on-return: false</span><br><span class="line">      # 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">      pool-prepared-statements: true</span><br><span class="line">      max-open-prepared-statements: 20</span><br><span class="line">      max-pool-prepared-statement-per-connection-size: 20</span><br><span class="line">      # 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, &apos;wall&apos;用于防火墙</span><br><span class="line">      filters: stat,wall</span><br><span class="line">      # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔</span><br><span class="line">      aop-patterns: com.springboot.servie.*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      # WebStatFilter配置</span><br><span class="line">      web-stat-filter:</span><br><span class="line">        enabled: true</span><br><span class="line">        # 添加过滤规则</span><br><span class="line">        url-pattern: /*</span><br><span class="line">        # 忽略过滤的格式</span><br><span class="line">        exclusions: &apos;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&apos;</span><br><span class="line"></span><br><span class="line">      # StatViewServlet配置</span><br><span class="line">      stat-view-servlet:</span><br><span class="line">        enabled: true</span><br><span class="line">        # 访问路径为/druid时，跳转到StatViewServlet</span><br><span class="line">        url-pattern: /druid/*</span><br><span class="line">        # 是否能够重置数据</span><br><span class="line">        reset-enable: false</span><br><span class="line">        # 需要账号密码才能访问控制台</span><br><span class="line">        login-username: druid</span><br><span class="line">        login-password: druid123</span><br><span class="line">        # IP白名单</span><br><span class="line">        # allow: 127.0.0.1</span><br><span class="line">        #　IP黑名单（共同存在时，deny优先于allow）</span><br><span class="line">        # deny: 192.168.1.218</span><br><span class="line"></span><br><span class="line">      # 配置StatFilter</span><br><span class="line">      filter:</span><br><span class="line">        stat:</span><br><span class="line">          log-slow-sql: true</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br><span class="line">  configuration-properties: BEFORE</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li><p>接口+注解形式实现数据库读取写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface StudentManagerWithInject &#123;</span><br><span class="line"></span><br><span class="line">    @Insert(&quot;insert into student(sno,sname,ssex)values(#&#123;sno&#125;,#&#123;name&#125;,#&#123;ssex&#125;)&quot;)</span><br><span class="line">    int add(Student student);</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update student set sname=#&#123;name&#125;,ssex=#&#123;sex&#125; where sno=#&#123;sno&#125;&quot;)</span><br><span class="line">    int update(Student student);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from student where sno=#&#123;sno&#125;&quot;)</span><br><span class="line">    int deleteBySno(String sno);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from student where sno=#&#123;sno&#125;&quot;)</span><br><span class="line">    @Results(id = &quot;student&quot;,value= &#123;</span><br><span class="line">        @Result(property = &quot;sno&quot;, column = &quot;sno&quot;, javaType = String.class),</span><br><span class="line">        @Result(property = &quot;name&quot;, column = &quot;sname&quot;, javaType = String.class),</span><br><span class="line">        @Result(property = &quot;sex&quot;, column = &quot;ssex&quot;, javaType = String.class)</span><br><span class="line">    &#125;)</span><br><span class="line">    Student queryStudentBySno(String sno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自动装配实现业务逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TestController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentManagerWithInject studentManagerWithInject;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentMapperWithXML studentMapperWithXML;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/querystudent&quot;,method = RequestMethod.GET)</span><br><span class="line">    public Student queryStudentBySno(</span><br><span class="line">        @RequestParam String sno)&#123;</span><br><span class="line">        return studentManagerWithInject.queryStudentBySno(sno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/querystudentwithxml&quot;,method = RequestMethod.GET)</span><br><span class="line">    public Student queryStudentWithXMLBySno(</span><br><span class="line">        @RequestParam String sno)&#123;</span><br><span class="line">        return studentMapperWithXML.queryStudentBySno(sno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用接口，得到结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/web/querystudent?sno=001</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">&#123;</span><br><span class="line">  &quot;sno&quot;: &quot;001&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;KangKang&quot;,</span><br><span class="line">  &quot;sex&quot;: &quot;M &quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><p>一般项目会增加一个 service 服务层，一个服务可能对应多个数据库操作，这里节省时间就没有加，工作中还是根据项目规范来。</p></li><li><p><a href="https://github.com/wuyouzhuguli/SpringAll" target="_blank" rel="noopener">学习参考</a></p></li><li><p><a href="https://github.com/suiyia/JavaReposity/tree/master/springboot4all" target="_blank" rel="noopener">源码第一章节</a></p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;内容&lt;/h2&gt;&lt;p&gt;Sprin
      
    
    </summary>
    
      <category term="Spring学习" scheme="http://suiyia.github.io/categories/Spring%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Springboot" scheme="http://suiyia.github.io/tags/Springboot/"/>
    
      <category term="MyBatis" scheme="http://suiyia.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Springboot 与 AOP 实现</title>
    <link href="http://suiyia.github.io/2019/08/10/Springboot-%E4%B8%8E-AOP-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://suiyia.github.io/2019/08/10/Springboot-与-AOP-实现/</id>
    <published>2019-08-10T09:39:00.000Z</published>
    <updated>2019-08-10T09:51:13.073Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Springboot 项目 AOP 实现，记录方法的执行过程</p><h1 id="pom-依赖"><a href="#pom-依赖" class="headerlink" title="pom 依赖"></a>pom 依赖</h1><p>druid、JdbcTemplate、aop</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;8.0.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">  &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.18.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;RELEASE&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><p>Mysql 脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SYS_LOG (</span><br><span class="line">   ID INT(20) NOT NULL COMMENT &apos;用户名&apos; PRIMARY KEY AUTO_INCREMENT ,</span><br><span class="line">   USERNAME VARCHAR(50) NULL COMMENT &apos;用户名&apos;,</span><br><span class="line">   OPERATION VARCHAR(50) NULL COMMENT &apos;用户操作&apos;,</span><br><span class="line">   TIME INT(11) NULL COMMENT &apos;响应时间&apos;,</span><br><span class="line">   METHOD VARCHAR(1024) NULL COMMENT &apos;请求方法&apos;,</span><br><span class="line">   PARAMS VARCHAR(1024) NULL COMMENT &apos;请求参数&apos;,</span><br><span class="line">   IP VARCHAR(64) NULL COMMENT &apos;IP地址&apos;,</span><br><span class="line">   CREATE_TIME DATE NULL COMMENT &apos;创建时间&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>实体类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import lombok.ToString;</span><br><span class="line"></span><br><span class="line">@Setter</span><br><span class="line">@Getter</span><br><span class="line">@ToString</span><br><span class="line">public class SysLog implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String operation;</span><br><span class="line">    private Integer time;</span><br><span class="line">    private String method;</span><br><span class="line">    private String params;</span><br><span class="line">    private String ip;</span><br><span class="line">    private Date createTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个方法级别的 @Log 注解，需要监控的方法加上该注解就行</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Log &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义 dao 方法，保存日志到数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SysLogDao &#123;</span><br><span class="line">    void saveSysLog(SysLog sysLog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SysLogDaoImpl implements SysLogDao &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void saveSysLog(SysLog sysLog) &#123;</span><br><span class="line">        StringBuffer sql = new StringBuffer(&quot;insert into sys_log &quot;);</span><br><span class="line">        sql.append(&quot;(username,operation,time,method,params,ip,create_time) &quot;);</span><br><span class="line">        sql.append(&quot;values(:username,:operation,:time,:method,&quot;);</span><br><span class="line">        sql.append(&quot;:params,:ip,:createTime)&quot;);</span><br><span class="line"></span><br><span class="line">        NamedParameterJdbcTemplate npjt = new NamedParameterJdbcTemplate(this.jdbcTemplate.getDataSource());</span><br><span class="line">        npjt.update(sql.toString(), new BeanPropertySqlParameterSource(sysLog));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>切面切点定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LogAspect &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SysLogDao sysLogDao;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;@annotation(com.example.demo.annotion.Log)&quot;)</span><br><span class="line">    public void pointcut()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;pointcut()&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint proceedingJoinPoint)&#123;</span><br><span class="line">        Object result = null;</span><br><span class="line">        long beginTime = System.currentTimeMillis();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 执行方法</span><br><span class="line">            result = proceedingJoinPoint.proceed();</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        // 执行时长(毫秒)</span><br><span class="line">        long time = System.currentTimeMillis() - beginTime;</span><br><span class="line">        // 保存日志</span><br><span class="line">        saveLog(proceedingJoinPoint, time);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void saveLog(ProceedingJoinPoint joinPoint, long time) &#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        SysLog sysLog = new SysLog();</span><br><span class="line">        Log logAnnotation = method.getAnnotation(Log.class);</span><br><span class="line">        if (logAnnotation != null) &#123;</span><br><span class="line">            // 注解上的描述</span><br><span class="line">            sysLog.setOperation(logAnnotation.value());</span><br><span class="line">        &#125;</span><br><span class="line">        // 请求的方法名</span><br><span class="line">        String className = joinPoint.getTarget().getClass().getName();</span><br><span class="line">        String methodName = signature.getName();</span><br><span class="line">        sysLog.setMethod(className + &quot;.&quot; + methodName + &quot;()&quot;);</span><br><span class="line">        // 请求的方法参数值</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        // 请求的方法参数名称</span><br><span class="line">        LocalVariableTableParameterNameDiscoverer u = new LocalVariableTableParameterNameDiscoverer();</span><br><span class="line">        String[] paramNames = u.getParameterNames(method);</span><br><span class="line">        if (args != null &amp;&amp; paramNames != null) &#123;</span><br><span class="line">            String params = &quot;&quot;;</span><br><span class="line">            for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                params += &quot;  &quot; + paramNames[i] + &quot;: &quot; + args[i];</span><br><span class="line">            &#125;</span><br><span class="line">            sysLog.setParams(params);</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取request</span><br><span class="line">        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        // 设置IP地址</span><br><span class="line">        sysLog.setIp(IPUtils.getIpAddr(request));</span><br><span class="line">        // 模拟一个用户名</span><br><span class="line">        sysLog.setUsername(&quot;mrbird&quot;);</span><br><span class="line">        sysLog.setTime((int) time);</span><br><span class="line">        sysLog.setCreateTime(new Date());</span><br><span class="line">        // 保存系统日志</span><br><span class="line">        sysLogDao.saveSysLog(sysLog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class IPUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取IP地址</span><br><span class="line">     *</span><br><span class="line">     * 使用Nginx等反向代理软件， 则不能通过request.getRemoteAddr()获取IP地址 如果使用了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP地址，X-Forwarded-For中第一个非unknown的有效IP字符串，则为真实IP地址</span><br><span class="line">     */</span><br><span class="line">    public static String getIpAddr(HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">        String ip = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;0:0:0:0:0:0:0:1&quot;.equals(ip) ? &quot;127.0.0.1&quot; : ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Controller 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TestController &#123;</span><br><span class="line"></span><br><span class="line">    @Log(&quot;执行方法一&quot;)</span><br><span class="line">    @GetMapping(&quot;/one&quot;)</span><br><span class="line">    public void methodOne(String name) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Log(&quot;执行方法二&quot;)</span><br><span class="line">    @GetMapping(&quot;/two&quot;)</span><br><span class="line">    public void methodTwo() throws InterruptedException &#123;</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Log(&quot;执行方法三&quot;)</span><br><span class="line">    @GetMapping(&quot;/three&quot;)</span><br><span class="line">    public void methodThree(String name, String age) &#123; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/web/one?name=KangKang</span><br><span class="line"></span><br><span class="line">http://localhost:8080/web/two</span><br><span class="line"></span><br><span class="line">http://localhost:8080/web/three?name=Mike&amp;age=25</span><br><span class="line"></span><br><span class="line">&gt; select * from sys_log order by id;</span><br><span class="line">IDUSERNAMEOPERATIONTIMEMETHODPARAMSIPCREATE_TIME</span><br><span class="line">1mrbird执行方法一3com.example.demo.web.TestController.methodOne()  name: KangKang127.0.0.12019-08-10</span><br><span class="line">2mrbird执行方法二2002com.example.demo.web.TestController.methodTwo()127.0.0.12019-08-10</span><br><span class="line">3mrbird执行方法三0com.example.demo.web.TestController.methodThree()  name: Mike  age: 25127.0.0.12019-08-10</span><br><span class="line">4mrbird执行方法三0com.example.demo.web.TestController.methodThree()  name: Mike  age: 25127.0.0.12019-08-10</span><br><span class="line">5mrbird执行方法二2001com.example.demo.web.TestController.methodTwo()127.0.0.12019-08-10</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>切面对项目响应时间的影响待测试，现在用的项目基本没有应用到切面，等有实际落地需求在改进学习下</li><li><a href="https://github.com/suiyia/JavaReposity/tree/master/springboot4all" target="_blank" rel="noopener">源码</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Sprin
      
    
    </summary>
    
      <category term="Spring学习" scheme="http://suiyia.github.io/categories/Spring%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Springboot" scheme="http://suiyia.github.io/tags/Springboot/"/>
    
      <category term="AOP" scheme="http://suiyia.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>HashMap、HashTable、ConcurrentHashMap 区别</title>
    <link href="http://suiyia.github.io/2019/04/07/HashMap%E3%80%81HashTable%E3%80%81ConcurrentHashMap-%E5%8C%BA%E5%88%AB/"/>
    <id>http://suiyia.github.io/2019/04/07/HashMap、HashTable、ConcurrentHashMap-区别/</id>
    <published>2019-04-07T06:24:00.000Z</published>
    <updated>2019-04-07T13:38:48.975Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><blockquote><p>简单总结 HashMap、Hashtable、ConcurrentHashMap 之间的区别，基于 JDK 1.8.0_191</p></blockquote><p>先说结论，暂时有以下几个需要注意的不同点：</p><ol><li>继承、实现接口不同</li><li>初始大小、扩容倍数不同</li><li>线程安全</li><li>NULL KEY，NULL VALUE 支持不同</li><li>计算 Hash 值的方式不同</li></ol><h3 id="1-继承、实现接口不同"><a href="#1-继承、实现接口不同" class="headerlink" title="1. 继承、实现接口不同"></a>1. 继承、实现接口不同</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125;</span><br><span class="line">    </span><br><span class="line">public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;    </span><br><span class="line"></span><br><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable &#123;</span><br></pre></td></tr></table></figure><ul><li>HashMap、ConcurrentHashMap 都继承于 AbstractMap 抽象类，但 Hashtable 继承于 Dictionary 抽象类。</li><li>AbstractMap 实现了 Map 接口，而 Dictionary 没有。这使得 AbstractMap 具有更多的功能，而 Dictionary 逐渐被弃用。</li></ul><h3 id="2-初始大小、扩容倍数不同"><a href="#2-初始大小、扩容倍数不同" class="headerlink" title="2. 初始大小、扩容倍数不同"></a>2. 初始大小、扩容倍数不同</h3><p>HashMap<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">扩容部分代码：</span><br><span class="line">newThr = oldThr &lt;&lt; 1; // double threshold</span><br></pre></td></tr></table></figure><p></p><p>Hashtable<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Hashtable() &#123;</span><br><span class="line">    this(11, 0.75f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">扩容部分代码：</span><br><span class="line">int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</span><br></pre></td></tr></table></figure><p></p><p>ConcurrentHashMap<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The default initial table capacity.  Must be a power of 2</span><br><span class="line"> * (i.e., at least 1) and at most MAXIMUM_CAPACITY.</span><br><span class="line"> */</span><br><span class="line">private static final int DEFAULT_CAPACITY = 16;</span><br></pre></td></tr></table></figure><p></p><ul><li>初始大小：HashMap、ConcurrentHashMap 都是 16，Hashtable 是 11</li><li>扩容倍数：HashMap、ConcurrentHashMap 2 倍、Hashtable (2n + 1) 倍。</li></ul><h3 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3. 线程安全"></a>3. 线程安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable:</span><br><span class="line">public synchronized V put(K key, V value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">HashMap:</span><br><span class="line">public V put(K key, V value) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>Hashtable 添加元素方法加上了 synchronized 关键字，HashMap 没有，说明 HashMap 不适用于多线程环境。</li><li>ConcurrentHashMap 添加元素时，只对需要变更的地方加锁。</li></ul><h3 id="4-NULL-KEY，NULL-VALUE-支持不同"><a href="#4-NULL-KEY，NULL-VALUE-支持不同" class="headerlink" title="4. NULL KEY，NULL VALUE 支持不同"></a>4. NULL KEY，NULL VALUE 支持不同</h3><p>通过观察它们的 put 方法，得到以下结论：</p><ul><li>Hashtable、ConcurrentHashMap 的 key、value 都不能为 null。</li><li>HashMap value 可以为 null，而 key 为 null 时，该元素会放在 HashMap 第一位。</li></ul><h3 id="5-key-的索引计算方法不同"><a href="#5-key-的索引计算方法不同" class="headerlink" title="5. key 的索引计算方法不同"></a>5. key 的索引计算方法不同</h3><p>计算元素存放位置，会经过两步转化。Object -&gt; int -&gt; index，先将 key 使用 hash 方法转换为一个整数数字，然后对整型数字进行转化，得到这个对象在 map 中的索引。</p><p>Hashtable<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int hash = key.hashCode();</span><br><span class="line">int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br></pre></td></tr></table></figure><p></p><p>HashMap<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>Hashtable 直接使用对象的 hashCode，然后再使用除留余数法来获得最终的位置。</li><li>HashMap 在对象的 hashCode 之上，将 hashCode 的高16位和低16位进行异或，得到最终的位置。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>后面学习将对 HashMap，ConcurrentHashMap 源码进行分析总结。</p><p><a href="https://blog.csdn.net/varyall/article/details/81277296" target="_blank" rel="noopener">ConcurrentHashMap的扩容机制（jdk1.8）</a></p><p><a href="http://www.10tiao.com/html/710/201903/2650123468/2.html" target="_blank" rel="noopener">HashMap 和Hashtable的区别</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;blockquote&gt;&lt;p&gt;简单总结 HashMap、Hashtable、ConcurrentHashMap 之间的区别，基于 JDK 1.8.0_
      
    
    </summary>
    
      <category term="Java基础" scheme="http://suiyia.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="集合" scheme="http://suiyia.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>ArraryList、LinkList和Vector的区别</title>
    <link href="http://suiyia.github.io/2019/03/24/ArraryList%E3%80%81LinkList%E5%92%8CVector%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://suiyia.github.io/2019/03/24/ArraryList、LinkList和Vector的区别/</id>
    <published>2019-03-24T05:53:00.000Z</published>
    <updated>2019-04-07T13:32:54.477Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --><blockquote><p>本文基于 JDK 1.8.0_191</p></blockquote><h3 id="1-源码对比"><a href="#1-源码对比" class="headerlink" title="1. 源码对比"></a>1. 源码对比</h3><ul><li>实现接口类对比</li><li>扩容机制对比</li><li>线程安全</li></ul><h4 id="1-1-实现接口类对比"><a href="#1-1-实现接口类对比" class="headerlink" title="1.1 实现接口类对比"></a>1.1 实现接口类对比</h4><p><img src="https://raw.githubusercontent.com/suiyia/images/master/20190324112747.jpeg?token=ALIF2JNoBZxx5ZeHPivS9QGmNve5iPdbks5clvlwwA%3D%3D" alt=""><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">        </span><br><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable    </span><br><span class="line">    </span><br><span class="line">public class Vector&lt;E&gt;</span><br><span class="line">    extends AbstractList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p></p><ul><li><p>它们都实现 List 接口，说明具备列表的增加、删除、遍历元素等特性。</p></li><li><p>ArrayList、Vector 额外实现 RandomAccess 接口，说明他们能在常量时间复杂度内快速随机访问元素。</p></li><li><p>LinkedList 额外实现 Queue 接口，具备队列的入队、出队等特性。</p></li></ul><h4 id="1-2-扩容机制对比"><a href="#1-2-扩容机制对比" class="headerlink" title="1.2 扩容机制对比"></a>1.2 扩容机制对比</h4><p>ArrayList<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_CAPACITY = 10;  // 定义初始大小</span><br><span class="line"></span><br><span class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;  // 定义列表存储元素数量最大值 </span><br><span class="line"></span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;   // 现有元素数量 </span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);  // 增加后元素的数量 = 1 + 0.5 </span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)    // 增加后的元素数量 &lt; 现有的空间，不扩容</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);  // 增加后的元素数量 &gt; 大于最大值，尝试分配 Integer.MAX_VALUE 个元素，可能会抛出 OutOfMemoryError  </span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Vector<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Vector() &#123;</span><br><span class="line">    this(10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected int capacityIncrement;  // 扩容数量值，Vector 初始化不指定时默认为 0</span><br><span class="line"></span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); // 当扩容数量值小于 0，那么扩容比例为原来的两倍；否则扩容的数量为这个值。</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>LinkList<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient int size = 0;</span><br></pre></td></tr></table></figure><p></p><ul><li>初始大小：ArrayList、Vector 默认为 10，LinkList 不指定默认为 0</li><li>扩容比例：ArrayList 以 1.5 倍进行扩容；Vector 不指定扩容比例时默认为 2 倍进行扩容</li></ul><h4 id="1-3-线程安全性"><a href="#1-3-线程安全性" class="headerlink" title="1.3 线程安全性"></a>1.3 线程安全性</h4><p>ArrayList<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected transient int modCount = 0;</span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Vector<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected transient int modCount = 0;</span><br><span class="line"></span><br><span class="line">public synchronized void addElement(E obj) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + 1);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Vector add() 方法上增加了 synchronized 关键字，使得 Vector 支持多线程环境下的元素增加删除修改操作。</p><h3 id="2-增删改性能对比"><a href="#2-增删改性能对比" class="headerlink" title="2. 增删改性能对比"></a>2. 增删改性能对比</h3><p>根据数据结构中知识:</p><p>顺序表查找元素时间复杂度为 O(1)，适用于随机查找元素的场景。</p><p>链表增减元素时间复杂度为 O(1)，适用于增减元素比较多的场景。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList arrayList = new ArrayList();</span><br><span class="line">    LinkedList linkedList = new LinkedList();</span><br><span class="line">    Vector vector = new Vector();</span><br><span class="line">    long t1, t2;</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        arrayList.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;ArrayList add:&quot; + (t2 - t1));</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        linkedList.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;linkedList add:&quot; + (t2 - t1));</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        vector.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;vector add:&quot; + (t2 - t1));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">ArrayList add:6810212</span><br><span class="line">linkedList add:3463194</span><br><span class="line">vector add:4442985</span><br></pre></td></tr></table></figure><p>添加元素，ArrayList 花费时间比 LinkList 时间长。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList arrayList = new ArrayList();</span><br><span class="line">    LinkedList linkedList = new LinkedList();</span><br><span class="line">    Vector vector = new Vector();</span><br><span class="line">    long t1, t2;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">        arrayList.add(i);</span><br><span class="line">        linkedList.add(i);</span><br><span class="line">        vector.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        arrayList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;ArrayList get:&quot; + (t2 - t1));</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        linkedList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;linkedList get:&quot; + (t2 - t1));</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        vector.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;vector get:&quot; + (t2 - t1));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">ArrayList get:72482</span><br><span class="line">linkedList get:107975370</span><br><span class="line">vector get:242634</span><br></pre></td></tr></table></figure><p></p><p>查找元素上，ArrayList 最快</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>将 ArrayList、LinkList 和 Vetor 进行了简单对比，总体来说：</p><ul><li>在查找元素比较频繁的场合，推荐使用 ArrayList；在修改元素比较频繁的场合，推荐使用 LinkList。</li><li>Vetor 与 ArrayList 类似，区别在于扩容比例、线程安全方面。</li><li>性能对比测试结果可能存在添加元素 ArrayList 花费时间比 LinkList 多的情况， 这个原因</li></ul><p>参考：</p><p><a href="https://www.hollischuang.com/archives/1349" target="_blank" rel="noopener">ArrayList vs LinkedList vs Vector 区别</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 23:24:48 GMT+0800 (GMT+08:00) --&gt;&lt;blockquote&gt;&lt;p&gt;本文基于 JDK 1.8.0_191&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;1-源码对比&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="Java基础" scheme="http://suiyia.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="集合" scheme="http://suiyia.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
</feed>
